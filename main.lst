CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************   9. May 2012  17:13  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     003C  0053 gRingBuf    EQU   0x3C
     0025  0054 result      EQU   0x25
     0020  0055 value       EQU   0x20
     0021  0056 writeNext   EQU   0x21
     0026  0057 ch          EQU   0x26
     0022  0058 putstr      EQU   0x22
     0023  0059 ps          EQU   0x23
     007F  0060 array       EQU   0x7F
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 2

ADDR CODE  LINE SOURCE

     007F  0061 length      EQU   0x7F
     007F  0062 i           EQU   0x7F
     002A  0063 adress      EQU   0x2A
     002B  0064 data        EQU   0x2B
     0000  0065 GIE_status  EQU   0
     002E  0066 adress_2    EQU   0x2E
     002F  0067 data_2      EQU   0x2F
     0026  0068 array_2     EQU   0x26
     0027  0069 adress_3    EQU   0x27
     0028  0070 length_2    EQU   0x28
     0029  0071 i_2         EQU   0x29
     007F  0072 array_3     EQU   0x7F
     007F  0073 adress_4    EQU   0x7F
     007F  0074 length_3    EQU   0x7F
     007F  0075 i_3         EQU   0x7F
     007F  0076 temp        EQU   0x7F
     0025  0077 byte        EQU   0x25
     0026  0078 p_crcH      EQU   0x26
     0027  0079 p_crcL      EQU   0x27
     0028  0080 index       EQU   0x28
     0029  0081 crcH        EQU   0x29
     002A  0082 crcL        EQU   0x2A
     007F  0083 data_3      EQU   0x7F
     007F  0084 length_4    EQU   0x7F
     007F  0085 crcH_out    EQU   0x7F
     007F  0086 crcL_out    EQU   0x7F
     007F  0087 crcH_2      EQU   0x7F
     007F  0088 crcL_2      EQU   0x7F
     007F  0089 i_4         EQU   0x7F
     007F  0090 byte_2      EQU   0x7F
     0025  0091 p_crcH_2    EQU   0x25
     0026  0092 p_crcL_2    EQU   0x26
     007F  0093 data_4      EQU   0x7F
     003B  0094 data_5      EQU   0x3B
     007F  0095 array_4     EQU   0x7F
     007F  0096 length_5    EQU   0x7F
     007F  0097 i_5         EQU   0x7F
     0034  0098 array_r     EQU   0x34
     0036  0099 array_g     EQU   0x36
     0038  0100 array_b     EQU   0x38
     003A  0101 k           EQU   0x3A
     0023  0102 k_2         EQU   0x23
     002E  0103 address     EQU   0x2E
     002F  0104 r           EQU   0x2F
     0030  0105 g           EQU   0x30
     0031  0106 b           EQU   0x31
     0032  0107 k_3         EQU   0x32
     0033  0108 mask        EQU   0x33
     0023  0109 cmdPointer  EQU   0x23
     0024  0110 r_2         EQU   0x24
     0025  0111 g_2         EQU   0x25
     0026  0112 b_2         EQU   0x26
     0027  0113 i_6         EQU   0x27
     0028  0114 temp_2      EQU   0x28
     0029  0115 temp1       EQU   0x29
     004F  0116 gCmdBuf     EQU   0x4F
     0063  0117 gERROR      EQU   0x63
     0020  0118 temp_3      EQU   0x20
     0022  0119 i_7         EQU   0x22
     0022  0120 new_byte    EQU   0x22
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 3

ADDR CODE  LINE SOURCE

     0023  0121 temp_4      EQU   0x23
     0024  0122 j           EQU   0x24
     0025  0123 CmdPointer  EQU   0x25
     0022  0124 pointer     EQU   0x22
     0024  0125 ci          EQU   0x24
           0126 
0000 2814  0127 	GOTO main
           0128 
           0129   ; FILE main.c
           0130 			;//Nils Weiﬂ 
           0131 			;//05.09.2011
           0132 			;//Compiler CC5x/
           0133 			;//#define TEST
           0134 			;
           0135 			;#define NO_CRC
           0136 			;
           0137 			;#pragma sharedAllocation
           0138 			;
           0139 			;//*********************** ENUMERATIONS *********************************************
           0140 			;#define TRUE  1
           0141 			;#define FALSE 0
           0142 			;
           0143 			;#define STX 0xFF
           0144 			;#define SET_COLOR 0xFD
           0145 			;#define SET_FADE 0xFC
           0146 			;#define SET_RUN 0xFB
           0147 			;#define WAIT 0xFE
           0148 			;#define SET_ON 0xFA
           0149 			;#define SET_OFF 0xF9
           0150 			;#define DELETE 0xF8
           0151 			;
           0152 			;// *** ERRORBITS
           0153 			;#define crc_failure 0
           0154 			;#define eeprom_failure 1
           0155 			;
           0156 			;#define FRAMELENGTH 16			// *** max length of one commandframe
           0157 			;#define CmdPointerAddr 0xff		// *** Address at EERPOM. Commandpointer indicates the nummer of commands
           0158 			;#define CmdLoopPointerAddr 0xfd // *** Address at EEPROM. CommandLoopPointer indicates the next command. Used in Loop-Mode
           0159 			;#define CmdWidth 10				// *** Number of Bytes for one command
           0160 			;
           0161 			;//*********************** INCLUDEDATEIEN *********************************************
           0162 			;#pragma codepage 1
     0000  0163 	ORG 0x0800
           0164 
           0165   ; FILE include_files\RingBuf.c
           0166 			;
           0167 			;//#include "unused_files/RingBuf.h"
           0168 			;//#include "RingBuf.h"
           0169 			;
           0170 			;
           0171 			;#message Global variables are defined in RingBuf.c
           0172 			;
           0173 			;struct RingBuffer gRingBuf;
           0174 			;
           0175 			;void RingBufInit(void)
           0176 			;{
           0177 _const1
0800 0020  0178 	MOVLB 0
0801 00A4  0179 	MOVWF ci
0802 3008  0180 	MOVLW 8
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 4

ADDR CODE  LINE SOURCE

0803 0023  0181 	MOVLB 3
0804 0092  0182 	MOVWF EEADRH
0805 0020  0183 	MOVLB 0
0806 0C24  0184 	RRF   ci,W
0807 397F  0185 	ANDLW 127
0808 3E1D  0186 	ADDLW 29
0809 0023  0187 	MOVLB 3
080A 0091  0188 	MOVWF EEADRL
080B 1803  0189 	BTFSC 0x03,Carry
080C 0A92  0190 	INCF  EEADRH,1
080D 0023  0191 	MOVLB 3
080E 1795  0192 	BSF   0x195,EEPGD
080F 1415  0193 	BSF   0x195,RD
0810 0000  0194 	NOP  
0811 0000  0195 	NOP  
0812 0020  0196 	MOVLB 0
0813 1824  0197 	BTFSC ci,0
0814 2819  0198 	GOTO  m001
0815 0023  0199 	MOVLB 3
0816 0813  0200 	MOVF  EEDATL,W
0817 397F  0201 	ANDLW 127
0818 0008  0202 	RETURN
0819 0023  0203 m001	MOVLB 3
081A 0D13  0204 	RLF   EEDATL,W
081B 0D14  0205 	RLF   EEDATH,W
081C 0008  0206 	RETURN
081D 22A0  0207 	DW    0x22A0
081E 2952  0208 	DW    0x2952
081F 294F  0209 	DW    0x294F
0820 103A  0210 	DW    0x103A
0821 32D2  0211 	DW    0x32D2
0822 32E3  0212 	DW    0x32E3
0823 3B69  0213 	DW    0x3B69
0824 3165  0214 	DW    0x3165
0825 3375  0215 	DW    0x3375
0826 32E6  0216 	DW    0x32E6
0827 1072  0217 	DW    0x1072
0828 3AE6  0218 	DW    0x3AE6
0829 366C  0219 	DW    0x366C
082A 1000  0220 	DW    0x1000
082B 2945  0221 	DW    0x2945
082C 27D2  0222 	DW    0x27D2
082D 1D52  0223 	DW    0x1D52
082E 21A0  0224 	DW    0x21A0
082F 21D2  0225 	DW    0x21D2
0830 21AD  0226 	DW    0x21AD
0831 32E8  0227 	DW    0x32E8
0832 35E3  0228 	DW    0x35E3
0833 3320  0229 	DW    0x3320
0834 34E1  0230 	DW    0x34E1
0835 32EC  0231 	DW    0x32EC
0836 0064  0232 	DW    0x64
0837 22A0  0233 	DW    0x22A0
0838 2952  0234 	DW    0x2952
0839 294F  0235 	DW    0x294F
083A 103A  0236 	DW    0x103A
083B 22C5  0237 	DW    0x22C5
083C 2950  0238 	DW    0x2950
083D 26CF  0239 	DW    0x26CF
083E 34A0  0240 	DW    0x34A0
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 5

ADDR CODE  LINE SOURCE

083F 1073  0241 	DW    0x1073
0840 3AE6  0242 	DW    0x3AE6
0841 366C  0243 	DW    0x366C
0842 0000  0244 	DW    0x0
           0245 RingBufInit
           0246 			;	gRingBuf.read = 0;
0843 0020  0247 	MOVLB 0
0844 01CC  0248 	CLRF  gRingBuf+16
           0249 			;	gRingBuf.write = 0;
0845 01CD  0250 	CLRF  gRingBuf+17
           0251 			;	gRingBuf.error_full = 0;
0846 104E  0252 	BCF   gRingBuf+18,0
           0253 			;}
0847 0008  0254 	RETURN
           0255 			;
           0256 			;char RingBufGet(void)
           0257 			;{
           0258 RingBufGet
           0259 			;	char result = gRingBuf.data[gRingBuf.read];
0848 303C  0260 	MOVLW 60
0849 0020  0261 	MOVLB 0
084A 074C  0262 	ADDWF gRingBuf+16,W
084B 0084  0263 	MOVWF FSR0L
084C 0185  0264 	CLRF  FSR0H
084D 0800  0265 	MOVF  INDF0,W
084E 00A5  0266 	MOVWF result
           0267 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
084F 0A4C  0268 	INCF  gRingBuf+16,W
0850 390F  0269 	ANDLW 15
0851 00CC  0270 	MOVWF gRingBuf+16
           0271 			;	return result;
0852 0825  0272 	MOVF  result,W
0853 0008  0273 	RETURN
           0274 			;}
           0275 			;
           0276 			;void RingBufPut(char value)
           0277 			;{
           0278 RingBufPut
0854 0020  0279 	MOVLB 0
0855 00A0  0280 	MOVWF value
           0281 			;	char writeNext = RingBufInc(gRingBuf.write);
0856 0A4D  0282 	INCF  gRingBuf+17,W
0857 390F  0283 	ANDLW 15
0858 00A1  0284 	MOVWF writeNext
           0285 			;	if(writeNext != gRingBuf.read)
0859 0821  0286 	MOVF  writeNext,W
085A 064C  0287 	XORWF gRingBuf+16,W
085B 1903  0288 	BTFSC 0x03,Zero_
085C 2866  0289 	GOTO  m002
           0290 			;	{
           0291 			;		gRingBuf.data[gRingBuf.write] = value;
085D 303C  0292 	MOVLW 60
085E 074D  0293 	ADDWF gRingBuf+17,W
085F 0084  0294 	MOVWF FSR0L
0860 0185  0295 	CLRF  FSR0H
0861 0820  0296 	MOVF  value,W
0862 0080  0297 	MOVWF INDF0
           0298 			;		gRingBuf.write = writeNext;
0863 0821  0299 	MOVF  writeNext,W
0864 00CD  0300 	MOVWF gRingBuf+17
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 6

ADDR CODE  LINE SOURCE

           0301 			;	}
           0302 			;	else gRingBuf.error_full = 1;
0865 2868  0303 	GOTO  m003
0866 0020  0304 m002	MOVLB 0
0867 144E  0305 	BSF   gRingBuf+18,0
           0306 			;}
0868 0008  0307 m003	RETURN
           0308 
           0309   ; FILE include_files\usart.c
           0310 			;// Include-Datei f¸r Serielle Kommunikation ¸ber Hardwaremodul des Pic
           0311 			; //
           0312 			; //
           0313 			; // Nils Weiﬂ
           0314 			; // 29.11.2010
           0315 			; // Compiler CC5x
           0316 			;
           0317 			;//*******  Initialisierungs-Funktion  *************************************************
           0318 			;void USARTinit()
           0319 			;{
           0320 USARTinit
           0321 			;	//USART TX Pin als Ausgang
           0322 			;	TRISC.6 = 0;
0869 0021  0323 	MOVLB 1
086A 130E  0324 	BCF   TRISC,6
           0325 			;
           0326 			;    BRGH=1;					// High Baudrate activated
086B 0023  0327 	MOVLB 3
086C 151E  0328 	BSF   0x19E,BRGH
           0329 			;	BRG16=0;
086D 119F  0330 	BCF   0x19F,BRG16
           0331 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
086E 3019  0332 	MOVLW 25
086F 009B  0333 	MOVWF SPBRGL
           0334 			;	SPBRGH=0;
0870 019C  0335 	CLRF  SPBRGH
           0336 			;    SPEN = 1;               // Set_Serial_Pins;
0871 179D  0337 	BSF   0x19D,SPEN
           0338 			;    SYNC = 0;               // Set_Async_Mode;
0872 121E  0339 	BCF   0x19E,SYNC
           0340 			;    TX9 = 0;                // Set_8bit_Tx;
0873 131E  0341 	BCF   0x19E,TX9
           0342 			;    RX9 = 0;                // Set_8bit_Rx;
0874 131D  0343 	BCF   0x19D,RX9
           0344 			;    CREN = 1;               // Enable_Rx;
0875 161D  0345 	BSF   0x19D,CREN
           0346 			;    TXEN = 1;               // Enable_Tx;
0876 169E  0347 	BSF   0x19E,TXEN
           0348 			;    RCIE=1;                 // Rx Interrupt aus
0877 0021  0349 	MOVLB 1
0878 1691  0350 	BSF   0x91,RCIE
           0351 			;	ADDEN=0;				// Disable Adressdetection
0879 0023  0352 	MOVLB 3
087A 119D  0353 	BCF   0x19D,ADDEN
           0354 			;}
087B 0008  0355 	RETURN
           0356 			;
           0357 			;//*******  Sende-char-Funktion  *************************************************
           0358 			;void USARTsend(unsigned char ch)
           0359 			;{
           0360 USARTsend
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 7

ADDR CODE  LINE SOURCE

087C 0020  0361 	MOVLB 0
087D 00A6  0362 	MOVWF ch
           0363 			;	while(!TXIF);
087E 0020  0364 m004	MOVLB 0
087F 1E11  0365 	BTFSS 0x11,TXIF
0880 287E  0366 	GOTO  m004
           0367 			;	TXREG=ch;
0881 0020  0368 	MOVLB 0
0882 0826  0369 	MOVF  ch,W
0883 0023  0370 	MOVLB 3
0884 009A  0371 	MOVWF TXREG
           0372 			;}
0885 0008  0373 	RETURN
           0374 			;
           0375 			;//*******  Sende-String-Funktion  *************************************************
           0376 			;void USARTsend_str(const char *putstr)
           0377 			;{
           0378 USARTsend_str
           0379 			; char ps;
           0380 			; ps = *putstr;
0886 0020  0381 	MOVLB 0
0887 0822  0382 	MOVF  putstr,W
0888 2000  0383 	CALL  _const1
0889 0020  0384 	MOVLB 0
088A 00A3  0385 	MOVWF ps
           0386 			;
           0387 			;  while(ps > 0)
088B 0020  0388 m005	MOVLB 0
088C 08A3  0389 	MOVF  ps,1
088D 1903  0390 	BTFSC 0x03,Zero_
088E 289C  0391 	GOTO  m006
           0392 			;   {
           0393 			;    putstr++;
088F 0AA2  0394 	INCF  putstr,1
           0395 			;    if (ps == 0) break;
0890 08A3  0396 	MOVF  ps,1
0891 1903  0397 	BTFSC 0x03,Zero_
0892 289C  0398 	GOTO  m006
           0399 			;   	USARTsend(ps);
0893 0020  0400 	MOVLB 0
0894 0823  0401 	MOVF  ps,W
0895 207C  0402 	CALL  USARTsend
           0403 			;    ps = *putstr;
0896 0020  0404 	MOVLB 0
0897 0822  0405 	MOVF  putstr,W
0898 2000  0406 	CALL  _const1
0899 0020  0407 	MOVLB 0
089A 00A3  0408 	MOVWF ps
           0409 			;   }
089B 288B  0410 	GOTO  m005
           0411 			;}
089C 0008  0412 m006	RETURN
           0413 			;
           0414 			;//*******  Sende-Array-Funktion  *************************************************
           0415 			;void USARTsend_arr(char *array, char length)
           0416 			;{
           0417 USARTsend_arr
089D 00FF  0418 	MOVWF length
           0419 			;	if(array == 0) return;
089E 08FF  0420 	MOVF  array,1
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 8

ADDR CODE  LINE SOURCE

089F 1903  0421 	BTFSC 0x03,Zero_
08A0 0008  0422 	RETURN
           0423 			;	char i;
           0424 			;	for(i=0;i<length;i++)
08A1 01FF  0425 	CLRF  i
08A2 087F  0426 m007	MOVF  length,W
08A3 027F  0427 	SUBWF i,W
08A4 1803  0428 	BTFSC 0x03,Carry
08A5 28AE  0429 	GOTO  m008
           0430 			;	{
           0431 			;		USARTsend(*array);
08A6 0185  0432 	CLRF  FSR0H
08A7 087F  0433 	MOVF  array,W
08A8 0084  0434 	MOVWF FSR0L
08A9 0800  0435 	MOVF  INDF0,W
08AA 207C  0436 	CALL  USARTsend
           0437 			;		array++;
08AB 0AFF  0438 	INCF  array,1
           0439 			;	}
08AC 0AFF  0440 	INCF  i,1
08AD 28A2  0441 	GOTO  m007
           0442 			;}
08AE 0008  0443 m008	RETURN
           0444 
           0445   ; FILE include_files\eeprom_nt.c
           0446 			;//Funktionen f¸r EEPROM-Zugriffe
           0447 			;
           0448 			;//Nils Weiﬂ 
           0449 			;//05.09.2011
           0450 			;//Compiler CC5x
           0451 			;
           0452 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0453 			;
           0454 			;void EEPROM_WR(char adress, char data)
           0455 			;{
           0456 EEPROM_WR
08AF 0020  0457 	MOVLB 0
08B0 00AB  0458 	MOVWF data
           0459 			;	bit GIE_status; 
           0460 			;	//EEADRH = (char)(adress<<8);
           0461 			;    EEADRL = (char)adress;        // Adresse in Adressregister ¸bertragen
08B1 082A  0462 	MOVF  adress,W
08B2 0023  0463 	MOVLB 3
08B3 0091  0464 	MOVWF EEADRL
           0465 			;	EEDATL = data;          // Daten in Datenregister ¸bertragen
08B4 0020  0466 	MOVLB 0
08B5 082B  0467 	MOVF  data,W
08B6 0023  0468 	MOVLB 3
08B7 0093  0469 	MOVWF EEDATL
           0470 			;    CFGS = 0;
08B8 1315  0471 	BCF   0x195,CFGS
           0472 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
08B9 1395  0473 	BCF   0x195,EEPGD
           0474 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
08BA 1515  0475 	BSF   0x195,WREN
           0476 			;	GIE_status=GIE;			
08BB 0020  0477 	MOVLB 0
08BC 102C  0478 	BCF   0x2C,GIE_status
08BD 1B8B  0479 	BTFSC 0x0B,GIE
08BE 142C  0480 	BSF   0x2C,GIE_status
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 9

ADDR CODE  LINE SOURCE

           0481 			;    GIE=0;                  // Interrups verbieten
08BF 138B  0482 	BCF   0x0B,GIE
           0483 			;    EECON2 = 0x55;
08C0 3055  0484 	MOVLW 85
08C1 0023  0485 	MOVLB 3
08C2 0096  0486 	MOVWF EECON2
           0487 			;    EECON2 = 0xAA;
08C3 30AA  0488 	MOVLW 170
08C4 0096  0489 	MOVWF EECON2
           0490 			;	WR=1; 					// Starten des Schreibens
08C5 1495  0491 	BSF   0x195,WR
           0492 			;    GIE=GIE_status;                  // Interrups erlauben
08C6 0020  0493 	MOVLB 0
08C7 1C2C  0494 	BTFSS 0x2C,GIE_status
08C8 138B  0495 	BCF   0x0B,GIE
08C9 182C  0496 	BTFSC 0x2C,GIE_status
08CA 178B  0497 	BSF   0x0B,GIE
           0498 			;	WREN=0;
08CB 0023  0499 	MOVLB 3
08CC 1115  0500 	BCF   0x195,WREN
           0501 			;	while(WR);
08CD 0023  0502 m009	MOVLB 3
08CE 1895  0503 	BTFSC 0x195,WR
08CF 28CD  0504 	GOTO  m009
           0505 			;}
08D0 0008  0506 	RETURN
           0507 			;
           0508 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0509 			;
           0510 			;char EEPROM_RD(char adress)
           0511 			;{
           0512 EEPROM_RD
08D1 0020  0513 	MOVLB 0
08D2 00AE  0514 	MOVWF adress_2
           0515 			;    char data;
           0516 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister ¸bertragen
           0517 			;    EEADRL = (char)(adress);
08D3 082E  0518 	MOVF  adress_2,W
08D4 0023  0519 	MOVLB 3
08D5 0091  0520 	MOVWF EEADRL
           0521 			;	CFGS=0;
08D6 1315  0522 	BCF   0x195,CFGS
           0523 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
08D7 1395  0524 	BCF   0x195,EEPGD
           0525 			;    RD=1;                   // Starten des Lesesn
08D8 1415  0526 	BSF   0x195,RD
           0527 			;    data = EEDATL;       // Daten aus Datenregister auslesen
08D9 0813  0528 	MOVF  EEDATL,W
08DA 0020  0529 	MOVLB 0
08DB 00AF  0530 	MOVWF data_2
           0531 			;    return data;
08DC 082F  0532 	MOVF  data_2,W
08DD 0008  0533 	RETURN
           0534 			;}
           0535 			;
           0536 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0537 			;
           0538 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0539 			;{
           0540 EEPROM_WR_BLK
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 10

ADDR CODE  LINE SOURCE

08DE 0020  0541 	MOVLB 0
08DF 00A8  0542 	MOVWF length_2
           0543 			;	if(!array) return;
08E0 08A6  0544 	MOVF  array_2,1
08E1 1903  0545 	BTFSC 0x03,Zero_
08E2 0008  0546 	RETURN
           0547 			;	char i;
           0548 			;	for(i=0;i<length;i++)
08E3 0020  0549 	MOVLB 0
08E4 01A9  0550 	CLRF  i_2
08E5 0020  0551 m010	MOVLB 0
08E6 0828  0552 	MOVF  length_2,W
08E7 0229  0553 	SUBWF i_2,W
08E8 1803  0554 	BTFSC 0x03,Carry
08E9 28F6  0555 	GOTO  m011
           0556 			;	{
           0557 			;		EEPROM_WR(adress,*array);
08EA 0827  0558 	MOVF  adress_3,W
08EB 00AA  0559 	MOVWF adress
08EC 0185  0560 	CLRF  FSR0H
08ED 0826  0561 	MOVF  array_2,W
08EE 0084  0562 	MOVWF FSR0L
08EF 0800  0563 	MOVF  INDF0,W
08F0 20AF  0564 	CALL  EEPROM_WR
           0565 			;		adress++;
08F1 0020  0566 	MOVLB 0
08F2 0AA7  0567 	INCF  adress_3,1
           0568 			;		array++;
08F3 0AA6  0569 	INCF  array_2,1
           0570 			;	}
08F4 0AA9  0571 	INCF  i_2,1
08F5 28E5  0572 	GOTO  m010
           0573 			;}
08F6 0008  0574 m011	RETURN
           0575 			;
           0576 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0577 			;
           0578 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0579 			;{
           0580 EEPROM_RD_BLK
08F7 00FF  0581 	MOVWF length_3
           0582 			;	if(!array) return;
08F8 08FF  0583 	MOVF  array_3,1
08F9 1903  0584 	BTFSC 0x03,Zero_
08FA 0008  0585 	RETURN
           0586 			;	char i, temp;
           0587 			;	for(i=0;i<length;i++)
08FB 01FF  0588 	CLRF  i_3
08FC 087F  0589 m012	MOVF  length_3,W
08FD 027F  0590 	SUBWF i_3,W
08FE 1803  0591 	BTFSC 0x03,Carry
08FF 290C  0592 	GOTO  m013
           0593 			;	{
           0594 			;		temp = EEPROM_RD(adress);
0900 087F  0595 	MOVF  adress_4,W
0901 20D1  0596 	CALL  EEPROM_RD
0902 00FF  0597 	MOVWF temp
           0598 			;		array[i] = temp;
0903 087F  0599 	MOVF  i_3,W
0904 077F  0600 	ADDWF array_3,W
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 11

ADDR CODE  LINE SOURCE

0905 0084  0601 	MOVWF FSR0L
0906 0185  0602 	CLRF  FSR0H
0907 087F  0603 	MOVF  temp,W
0908 0080  0604 	MOVWF INDF0
           0605 			;		adress++;
0909 0AFF  0606 	INCF  adress_4,1
           0607 			;	}
090A 0AFF  0608 	INCF  i_3,1
090B 28FC  0609 	GOTO  m012
           0610 
           0611   ; FILE include_files\eeprom.h
           0612 			;#ifndef _EEPROM_H_
           0613 			;#define _EEPROM_H_
           0614 			;
           0615 			;//Funktionen f¬∏r EEPROM-Zugriffe
           0616 			;
           0617 			;//Nils WeiÔ¨Ç 
           0618 			;//05.09.2011
           0619 			;//Compiler CC5x
           0620 			;
           0621 			;void EEPROM_WR(char adress, char data);
           0622 			;char EEPROM_RD(char adress);
           0623 			;void EEPROM_WR_BLK(char *array, char adress, char length);
           0624 			;void EEPROM_RD_BLK(char *array, char adress, char length);
           0625 			;
           0626 			;#include "include_files\eeprom_nt.c"
090C 0008  0627 m013	RETURN
           0628 
           0629   ; FILE include_files\crc.c
           0630 			; // Include-Datei zum Erstellen von CRC Pr¸fsummen
           0631 			; //
           0632 			; //
           0633 			; // Nils Weiﬂ
           0634 			; // 14.04.2012
           0635 			; // Compiler CC5x
           0636 			;
           0637 			;// 16-bit CCIT CRC
           0638 			;
           0639 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0640 			;{
           0641 addCRC
           0642 			;	char index;
           0643 			;	char crcH,crcL;
           0644 			;	crcH = *p_crcH;
090D 0185  0645 	CLRF  FSR0H
090E 0020  0646 	MOVLB 0
090F 0826  0647 	MOVF  p_crcH,W
0910 0084  0648 	MOVWF FSR0L
0911 0800  0649 	MOVF  INDF0,W
0912 00A9  0650 	MOVWF crcH
           0651 			;	crcL = *p_crcL;
0913 0185  0652 	CLRF  FSR0H
0914 0827  0653 	MOVF  p_crcL,W
0915 0084  0654 	MOVWF FSR0L
0916 0800  0655 	MOVF  INDF0,W
0917 00AA  0656 	MOVWF crcL
           0657 			;
           0658 			;	MOVF(byte,0);
0918 0825  0659 	MOVF  byte,W
           0660 			;	
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 12

ADDR CODE  LINE SOURCE

           0661 			;	XORWF(crcH,0);
0919 0629  0662 	XORWF crcH,W
           0663 			;	MOVWF(index);
091A 00A8  0664 	MOVWF index
           0665 			;	ANDLW(0xf0);
091B 39F0  0666 	ANDLW 240
           0667 			;	SWAPF(index,1);
091C 0EA8  0668 	SWAPF index,1
           0669 			;	XORWF(index,1);
091D 06A8  0670 	XORWF index,1
           0671 			;	
           0672 			;	MOVF(index,0);
091E 0828  0673 	MOVF  index,W
           0674 			;	ANDLW(0xf0);
091F 39F0  0675 	ANDLW 240
           0676 			;	XORWF(crcL,0);
0920 062A  0677 	XORWF crcL,W
           0678 			;	MOVWF(crcH);
0921 00A9  0679 	MOVWF crcH
           0680 			;	
           0681 			;	RLF(index,0);
0922 0D28  0682 	RLF   index,W
           0683 			;	RLF(index,0);
0923 0D28  0684 	RLF   index,W
           0685 			;	XORWF(crcH,1);
0924 06A9  0686 	XORWF crcH,1
           0687 			;	ANDLW(0xe0);
0925 39E0  0688 	ANDLW 224
           0689 			;	XORWF(crcH,1);
0926 06A9  0690 	XORWF crcH,1
           0691 			;		
           0692 			;	SWAPF(index,1);
0927 0EA8  0693 	SWAPF index,1
           0694 			;	XORWF(index,0);
0928 0628  0695 	XORWF index,W
           0696 			;	MOVWF(crcL);
0929 00AA  0697 	MOVWF crcL
           0698 			;
           0699 			;	*p_crcH = crcH;
092A 0185  0700 	CLRF  FSR0H
092B 0826  0701 	MOVF  p_crcH,W
092C 0084  0702 	MOVWF FSR0L
092D 0829  0703 	MOVF  crcH,W
092E 0080  0704 	MOVWF INDF0
           0705 			;	*p_crcL = crcL;
092F 0185  0706 	CLRF  FSR0H
0930 0827  0707 	MOVF  p_crcL,W
0931 0084  0708 	MOVWF FSR0L
0932 082A  0709 	MOVF  crcL,W
0933 0080  0710 	MOVWF INDF0
           0711 			;
           0712 			;}
0934 0008  0713 	RETURN
           0714 			;
           0715 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0716 			;{
           0717 CRC
           0718 			;	if(!crcH_out)return;
0935 08FF  0719 	MOVF  crcH_out,1
0936 1903  0720 	BTFSC 0x03,Zero_
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 13

ADDR CODE  LINE SOURCE

0937 0008  0721 	RETURN
           0722 			;	if(!crcL_out)return;
0938 08FF  0723 	MOVF  crcL_out,1
0939 1903  0724 	BTFSC 0x03,Zero_
093A 0008  0725 	RETURN
           0726 			;	if(!data)return;
093B 08FF  0727 	MOVF  data_3,1
093C 1903  0728 	BTFSC 0x03,Zero_
093D 0008  0729 	RETURN
           0730 			;	char crcH,crcL,i,byte;
           0731 			;	crcH=0xff;
093E 30FF  0732 	MOVLW 255
093F 00FF  0733 	MOVWF crcH_2
           0734 			;	crcL=0xff;
0940 30FF  0735 	MOVLW 255
0941 00FF  0736 	MOVWF crcL_2
           0737 			;
           0738 			;	for(i=0;i<length;i++)
0942 01FF  0739 	CLRF  i_4
0943 087F  0740 m014	MOVF  length_4,W
0944 027F  0741 	SUBWF i_4,W
0945 1803  0742 	BTFSC 0x03,Carry
0946 2957  0743 	GOTO  m015
           0744 			;	{
           0745 			;		byte = data[i];
0947 087F  0746 	MOVF  i_4,W
0948 077F  0747 	ADDWF data_3,W
0949 0084  0748 	MOVWF FSR0L
094A 0185  0749 	CLRF  FSR0H
094B 0800  0750 	MOVF  INDF0,W
094C 00FF  0751 	MOVWF byte_2
           0752 			;		addCRC(byte,&crcH,&crcL);
094D 087F  0753 	MOVF  byte_2,W
094E 0020  0754 	MOVLB 0
094F 00A5  0755 	MOVWF byte
0950 307F  0756 	MOVLW 127
0951 00A6  0757 	MOVWF p_crcH
0952 307F  0758 	MOVLW 127
0953 00A7  0759 	MOVWF p_crcL
0954 210D  0760 	CALL  addCRC
           0761 			;	}
0955 0AFF  0762 	INCF  i_4,1
0956 2943  0763 	GOTO  m014
           0764 			;	
           0765 			;	*crcH_out = crcH;
0957 0185  0766 m015	CLRF  FSR0H
0958 087F  0767 	MOVF  crcH_out,W
0959 0084  0768 	MOVWF FSR0L
095A 087F  0769 	MOVF  crcH_2,W
095B 0080  0770 	MOVWF INDF0
           0771 			;	*crcL_out = crcL;
095C 0185  0772 	CLRF  FSR0H
095D 087F  0773 	MOVF  crcL_out,W
095E 0084  0774 	MOVWF FSR0L
095F 087F  0775 	MOVF  crcL_2,W
0960 0080  0776 	MOVWF INDF0
           0777 			;}
0961 0008  0778 	RETURN
           0779 			;
           0780 			;void newCRC(char* p_crcH, char* p_crcL)
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 14

ADDR CODE  LINE SOURCE

           0781 			;{
           0782 newCRC
           0783 			;    if(!p_crcH) return;
0962 0020  0784 	MOVLB 0
0963 08A5  0785 	MOVF  p_crcH_2,1
0964 1903  0786 	BTFSC 0x03,Zero_
0965 0008  0787 	RETURN
           0788 			;    if(!p_crcL) return;
0966 0020  0789 	MOVLB 0
0967 08A6  0790 	MOVF  p_crcL_2,1
0968 1903  0791 	BTFSC 0x03,Zero_
0969 0008  0792 	RETURN
           0793 			;    *p_crcH = 0xff;
096A 0185  0794 	CLRF  FSR0H
096B 0020  0795 	MOVLB 0
096C 0825  0796 	MOVF  p_crcH_2,W
096D 0084  0797 	MOVWF FSR0L
096E 30FF  0798 	MOVLW 255
096F 0080  0799 	MOVWF INDF0
           0800 			;    *p_crcL = 0xff;
0970 0185  0801 	CLRF  FSR0H
0971 0826  0802 	MOVF  p_crcL_2,W
0972 0084  0803 	MOVWF FSR0L
0973 30FF  0804 	MOVLW 255
0974 0080  0805 	MOVWF INDF0
           0806 			;}
0975 0008  0807 	RETURN
           0808 
           0809   ; FILE include_files\spi.c
           0810 			;//Nils Weiﬂ 
           0811 			;//20.04.2012
           0812 			;//Compiler CC5x
           0813 			;void spi_init()
           0814 			;{
           0815 spi_init
           0816 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
0976 0021  0817 	MOVLB 1
0977 118E  0818 	BCF   TRISC,3
           0819 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
0978 160E  0820 	BSF   TRISC,4
           0821 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
0979 128E  0822 	BCF   TRISC,5
           0823 			;	SSPM1 = 0;
097A 0024  0824 	MOVLB 4
097B 1095  0825 	BCF   0x215,SSPM1
           0826 			;	SMP = 0;
097C 1394  0827 	BCF   0x214,SMP
           0828 			;	CKP = 1;
097D 1615  0829 	BSF   0x215,CKP
           0830 			;	CKE = 0;
097E 1314  0831 	BCF   0x214,CKE
           0832 			;	SSPEN = 1;
097F 1695  0833 	BSF   0x215,SSPEN
           0834 			;}
0980 0008  0835 	RETURN
           0836 			;
           0837 			;void spi_send(char data)
           0838 			;{
           0839 spi_send
0981 00FF  0840 	MOVWF data_4
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 15

ADDR CODE  LINE SOURCE

           0841 			;	SSPBUF = data;	
0982 087F  0842 	MOVF  data_4,W
0983 0024  0843 	MOVLB 4
0984 0091  0844 	MOVWF SSPBUF
           0845 			;	while(!SSPIF);
0985 0020  0846 m016	MOVLB 0
0986 1D91  0847 	BTFSS 0x11,SSPIF
0987 2985  0848 	GOTO  m016
           0849 			;}
0988 0008  0850 	RETURN
           0851 			;
           0852 			;char spi_receive(char data)
           0853 			;{
           0854 spi_receive
0989 0020  0855 	MOVLB 0
098A 00BB  0856 	MOVWF data_5
           0857 			;	SSPBUF = data;	
098B 083B  0858 	MOVF  data_5,W
098C 0024  0859 	MOVLB 4
098D 0091  0860 	MOVWF SSPBUF
           0861 			;	while(SSPIF == 0);
098E 0020  0862 m017	MOVLB 0
098F 1D91  0863 	BTFSS 0x11,SSPIF
0990 298E  0864 	GOTO  m017
           0865 			;	return SSPBUF;
0991 0024  0866 	MOVLB 4
0992 0811  0867 	MOVF  SSPBUF,W
0993 0008  0868 	RETURN
           0869 			;}
           0870 			;/***
           0871 			;**	This function sends the array to the LED controller(WS2801)
           0872 			;**  it starts with the last byte to get a correct output
           0873 			;***/
           0874 			;void spi_send_arr(char *array, char length)
           0875 			;{
           0876 spi_send_arr
0994 00FF  0877 	MOVWF length_5
           0878 			;	if(array == 0) return;
0995 08FF  0879 	MOVF  array_4,1
0996 1903  0880 	BTFSC 0x03,Zero_
0997 0008  0881 	RETURN
           0882 			;	char i;
           0883 			;	for(i = length; i == 0; i-- )
0998 087F  0884 	MOVF  length_5,W
0999 00FF  0885 	MOVWF i_5
099A 08FF  0886 m018	MOVF  i_5,1
099B 1D03  0887 	BTFSS 0x03,Zero_
099C 29A5  0888 	GOTO  m019
           0889 			;	{
           0890 			;		spi_send(array[i]);
099D 087F  0891 	MOVF  i_5,W
099E 077F  0892 	ADDWF array_4,W
099F 0084  0893 	MOVWF FSR0L
09A0 0185  0894 	CLRF  FSR0H
09A1 0800  0895 	MOVF  INDF0,W
09A2 2181  0896 	CALL  spi_send
           0897 			;	} 
09A3 03FF  0898 	DECF  i_5,1
09A4 299A  0899 	GOTO  m018
           0900 			;}
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 16

ADDR CODE  LINE SOURCE

09A5 0008  0901 m019	RETURN
           0902 			;
           0903 			;void spi_send_ledbuf(char *array_r, char *array_g, char *array_b)
           0904 			;{
           0905 spi_send_ledbuf
           0906 			;	char k = 0;
09A6 0020  0907 	MOVLB 0
09A7 01BA  0908 	CLRF  k
           0909 			;	for(;k < NUM_OF_LED;k++)
09A8 3020  0910 m020	MOVLW 32
09A9 0020  0911 	MOVLB 0
09AA 023A  0912 	SUBWF k,W
09AB 1803  0913 	BTFSC 0x03,Carry
09AC 29CD  0914 	GOTO  m021
           0915 			;	{
           0916 			;		spi_receive(*array_b);
09AD 0839  0917 	MOVF  array_b+1,W
09AE 0085  0918 	MOVWF FSR0H
09AF 0838  0919 	MOVF  array_b,W
09B0 0084  0920 	MOVWF FSR0L
09B1 0800  0921 	MOVF  INDF0,W
09B2 2189  0922 	CALL  spi_receive
           0923 			;		spi_receive(*array_g);
09B3 0020  0924 	MOVLB 0
09B4 0837  0925 	MOVF  array_g+1,W
09B5 0085  0926 	MOVWF FSR0H
09B6 0836  0927 	MOVF  array_g,W
09B7 0084  0928 	MOVWF FSR0L
09B8 0800  0929 	MOVF  INDF0,W
09B9 2189  0930 	CALL  spi_receive
           0931 			;		spi_receive(*array_r);
09BA 0020  0932 	MOVLB 0
09BB 0835  0933 	MOVF  array_r+1,W
09BC 0085  0934 	MOVWF FSR0H
09BD 0834  0935 	MOVF  array_r,W
09BE 0084  0936 	MOVWF FSR0L
09BF 0800  0937 	MOVF  INDF0,W
09C0 2189  0938 	CALL  spi_receive
           0939 			;		array_b++;
09C1 0020  0940 	MOVLB 0
09C2 0AB8  0941 	INCF  array_b,1
09C3 1903  0942 	BTFSC 0x03,Zero_
09C4 0AB9  0943 	INCF  array_b+1,1
           0944 			;		array_g++;
09C5 0AB6  0945 	INCF  array_g,1
09C6 1903  0946 	BTFSC 0x03,Zero_
09C7 0AB7  0947 	INCF  array_g+1,1
           0948 			;		array_r++;
09C8 0AB4  0949 	INCF  array_r,1
09C9 1903  0950 	BTFSC 0x03,Zero_
09CA 0AB5  0951 	INCF  array_r+1,1
           0952 			;	}
09CB 0ABA  0953 	INCF  k,1
09CC 29A8  0954 	GOTO  m020
           0955 
           0956   ; FILE include_files\spi.h
           0957 			;#ifndef _SPI_H_
           0958 			;#define _SPI_H_
           0959 			;
           0960 			;//Nils Weiﬂ 
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 17

ADDR CODE  LINE SOURCE

           0961 			;//20.04.2012
           0962 			;//Compiler CC5x
           0963 			;
           0964 			;
           0965 			;void spi_init();
           0966 			;void spi_send(char data);
           0967 			;char spi_receive(char data);
           0968 			;void spi_send_arr(char *array, char length);
           0969 			;void spi_send_ledbuf(char *array_r, char *array_g, char *array_b);
           0970 			;
           0971 			;#include "include_files\spi.c"
09CD 0008  0972 m021	RETURN
           0973 
           0974   ; FILE include_files\ledstrip.c
           0975 			;//Nils Weiﬂ 
           0976 			;//20.04.2012
           0977 			;//Compiler CC5x 
           0978 			;
           0979 			;struct LedBuffer gLedBuf;
           0980 			;
           0981 			;void ledstrip_init(void)
           0982 			;{
           0983 ledstrip_init
           0984 			;	char k;
           0985 			;	for(k = 0;k < NUM_OF_LED; k++)
09CE 0020  0986 	MOVLB 0
09CF 01A3  0987 	CLRF  k_2
09D0 3020  0988 m022	MOVLW 32
09D1 0020  0989 	MOVLB 0
09D2 0223  0990 	SUBWF k_2,W
09D3 1803  0991 	BTFSC 0x03,Carry
09D4 29EF  0992 	GOTO  m023
           0993 			;	{
           0994 			;		gLedBuf.led_array_r[k] = 0;
09D5 3020  0995 	MOVLW 32
09D6 0085  0996 	MOVWF FSR0+1
09D7 3044  0997 	MOVLW 68
09D8 0723  0998 	ADDWF k_2,W
09D9 0084  0999 	MOVWF FSR0
09DA 1803  1000 	BTFSC 0x03,Carry
09DB 0A85  1001 	INCF  FSR0+1,1
09DC 0180  1002 	CLRF  INDF0
           1003 			;		gLedBuf.led_array_g[k] = 0;
09DD 3020  1004 	MOVLW 32
09DE 0085  1005 	MOVWF FSR0+1
09DF 3064  1006 	MOVLW 100
09E0 0723  1007 	ADDWF k_2,W
09E1 0084  1008 	MOVWF FSR0
09E2 1803  1009 	BTFSC 0x03,Carry
09E3 0A85  1010 	INCF  FSR0+1,1
09E4 0180  1011 	CLRF  INDF0
           1012 			;		gLedBuf.led_array_b[k] = 0;
09E5 3020  1013 	MOVLW 32
09E6 0085  1014 	MOVWF FSR0+1
09E7 3084  1015 	MOVLW 132
09E8 0723  1016 	ADDWF k_2,W
09E9 0084  1017 	MOVWF FSR0
09EA 1803  1018 	BTFSC 0x03,Carry
09EB 0A85  1019 	INCF  FSR0+1,1
09EC 0180  1020 	CLRF  INDF0
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 18

ADDR CODE  LINE SOURCE

           1021 			;	}
09ED 0AA3  1022 	INCF  k_2,1
09EE 29D0  1023 	GOTO  m022
           1024 			;}
09EF 0008  1025 m023	RETURN
           1026 			;
           1027 			;/***
           1028 			;*** This funktion sets the values of the global LedBuffer
           1029 			;*** only Led's where the address bit is 1 will be set to the new color
           1030 			;***/
           1031 			;
           1032 			;void ledstrip_set_color(char *address, char r, char g, char b)
           1033 			;{	
           1034 ledstrip_set_color
09F0 0020  1035 	MOVLB 0
09F1 00B1  1036 	MOVWF b
           1037 			;	char k,mask;
           1038 			;	mask = 0b00000001;
09F2 3001  1039 	MOVLW 1
09F3 00B3  1040 	MOVWF mask
           1041 			;	for(k = 0; k < NUM_OF_LED; k++)
09F4 01B2  1042 	CLRF  k_3
09F5 3020  1043 m024	MOVLW 32
09F6 0020  1044 	MOVLB 0
09F7 0232  1045 	SUBWF k_3,W
09F8 1803  1046 	BTFSC 0x03,Carry
09F9 2A26  1047 	GOTO  m027
           1048 			;	{	
           1049 			;		if(0 != (*address & mask))
09FA 0185  1050 	CLRF  FSR0H
09FB 082E  1051 	MOVF  address,W
09FC 0084  1052 	MOVWF FSR0L
09FD 0833  1053 	MOVF  mask,W
09FE 0500  1054 	ANDWF INDF0,W
09FF 1903  1055 	BTFSC 0x03,Zero_
0A00 2A1C  1056 	GOTO  m025
           1057 			;		{
           1058 			;			gLedBuf.led_array_r[k] = r;
0A01 3020  1059 	MOVLW 32
0A02 0085  1060 	MOVWF FSR0+1
0A03 3044  1061 	MOVLW 68
0A04 0732  1062 	ADDWF k_3,W
0A05 0084  1063 	MOVWF FSR0
0A06 1803  1064 	BTFSC 0x03,Carry
0A07 0A85  1065 	INCF  FSR0+1,1
0A08 082F  1066 	MOVF  r,W
0A09 0080  1067 	MOVWF INDF0
           1068 			;			gLedBuf.led_array_g[k] = g;
0A0A 3020  1069 	MOVLW 32
0A0B 0085  1070 	MOVWF FSR0+1
0A0C 3064  1071 	MOVLW 100
0A0D 0732  1072 	ADDWF k_3,W
0A0E 0084  1073 	MOVWF FSR0
0A0F 1803  1074 	BTFSC 0x03,Carry
0A10 0A85  1075 	INCF  FSR0+1,1
0A11 0830  1076 	MOVF  g,W
0A12 0080  1077 	MOVWF INDF0
           1078 			;			gLedBuf.led_array_b[k] = b;
0A13 3020  1079 	MOVLW 32
0A14 0085  1080 	MOVWF FSR0+1
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 19

ADDR CODE  LINE SOURCE

0A15 3084  1081 	MOVLW 132
0A16 0732  1082 	ADDWF k_3,W
0A17 0084  1083 	MOVWF FSR0
0A18 1803  1084 	BTFSC 0x03,Carry
0A19 0A85  1085 	INCF  FSR0+1,1
0A1A 0831  1086 	MOVF  b,W
0A1B 0080  1087 	MOVWF INDF0
           1088 			;		}
           1089 			;		RLF(mask,1);
0A1C 0020  1090 m025	MOVLB 0
0A1D 0DB3  1091 	RLF   mask,1
           1092 			;		if(Carry == 1) 
0A1E 1C03  1093 	BTFSS 0x03,Carry
0A1F 2A23  1094 	GOTO  m026
           1095 			;		{
           1096 			;			address++;
0A20 0AAE  1097 	INCF  address,1
           1098 			;			mask= 0b00000001;
0A21 3001  1099 	MOVLW 1
0A22 00B3  1100 	MOVWF mask
           1101 			;		}
           1102 			;	}
0A23 0020  1103 m026	MOVLB 0
0A24 0AB2  1104 	INCF  k_3,1
0A25 29F5  1105 	GOTO  m024
           1106 			;	spi_send_ledbuf(&gLedBuf.led_array_r[0],&gLedBuf.led_array_g[0],&gLedBuf.led_array_b[0]);
0A26 3044  1107 m027	MOVLW 68
0A27 0020  1108 	MOVLB 0
0A28 00B4  1109 	MOVWF array_r
0A29 3020  1110 	MOVLW 32
0A2A 00B5  1111 	MOVWF array_r+1
0A2B 3064  1112 	MOVLW 100
0A2C 00B6  1113 	MOVWF array_g
0A2D 3020  1114 	MOVLW 32
0A2E 00B7  1115 	MOVWF array_g+1
0A2F 3084  1116 	MOVLW 132
0A30 00B8  1117 	MOVWF array_b
0A31 3020  1118 	MOVLW 32
0A32 00B9  1119 	MOVWF array_b+1
0A33 29A6  1120 	GOTO  spi_send_ledbuf
           1121 			;}
           1122 			;
           1123 			;/** This function extracts the parameters for the set_color command
           1124 			;*** from the EEPROM in relation to the CmdWidth and give the values 
           1125 			;*** to the next function with controls the led's
           1126 			;
           1127 			;*** BYTES according to Pointer: x=Commandpointer w=Commandwith
           1128 			;							   x-w     x-w+1   x-w+2   x-w+3  x-w+4     x-w+5         x-w+6        x-w+7                            
                                     x
           1129 			;*** Example: EEPROM DATA: <SET_COLOR> <ADDR0> <ADDR1> <ADDR2> <ADDR3> <RED_VALUE> <GREEN_VALUE> <BLUE_VALUE> <not important> <not important> <SET_COLOR(nextCom
                   mand)>
           1130 			;*/ 
           1131 			;void sub_func_set_color(char *cmdPointer)
           1132 			;{
           1133 sub_func_set_color
           1134 			;	char r,g,b,i, temp,temp1,address[4];
           1135 			;	
           1136 			;	r = EEPROM_RD(*cmdPointer - CmdWidth + 5);
0A34 0185  1137 	CLRF  FSR0H
0A35 0020  1138 	MOVLB 0
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 20

ADDR CODE  LINE SOURCE

0A36 0823  1139 	MOVF  cmdPointer,W
0A37 0084  1140 	MOVWF FSR0L
0A38 3005  1141 	MOVLW 5
0A39 0200  1142 	SUBWF INDF0,W
0A3A 20D1  1143 	CALL  EEPROM_RD
0A3B 0020  1144 	MOVLB 0
0A3C 00A4  1145 	MOVWF r_2
           1146 			;	g = EEPROM_RD(*cmdPointer - CmdWidth + 6);
0A3D 0185  1147 	CLRF  FSR0H
0A3E 0823  1148 	MOVF  cmdPointer,W
0A3F 0084  1149 	MOVWF FSR0L
0A40 3004  1150 	MOVLW 4
0A41 0200  1151 	SUBWF INDF0,W
0A42 20D1  1152 	CALL  EEPROM_RD
0A43 0020  1153 	MOVLB 0
0A44 00A5  1154 	MOVWF g_2
           1155 			;	b = EEPROM_RD(*cmdPointer - CmdWidth + 7);
0A45 0185  1156 	CLRF  FSR0H
0A46 0823  1157 	MOVF  cmdPointer,W
0A47 0084  1158 	MOVWF FSR0L
0A48 3003  1159 	MOVLW 3
0A49 0200  1160 	SUBWF INDF0,W
0A4A 20D1  1161 	CALL  EEPROM_RD
0A4B 0020  1162 	MOVLB 0
0A4C 00A6  1163 	MOVWF b_2
           1164 			;	for(i=0;i<4;i++)
0A4D 01A7  1165 	CLRF  i_6
0A4E 3004  1166 m028	MOVLW 4
0A4F 0020  1167 	MOVLB 0
0A50 0227  1168 	SUBWF i_6,W
0A51 1803  1169 	BTFSC 0x03,Carry
0A52 2A68  1170 	GOTO  m029
           1171 			;	{
           1172 			;		temp1 = *cmdPointer;
0A53 0185  1173 	CLRF  FSR0H
0A54 0823  1174 	MOVF  cmdPointer,W
0A55 0084  1175 	MOVWF FSR0L
0A56 0800  1176 	MOVF  INDF0,W
0A57 00A9  1177 	MOVWF temp1
           1178 			;		temp1 = temp1 - CmdWidth + 1 + i;
0A58 3009  1179 	MOVLW 9
0A59 0229  1180 	SUBWF temp1,W
0A5A 0727  1181 	ADDWF i_6,W
0A5B 00A9  1182 	MOVWF temp1
           1183 			;		temp = EEPROM_RD(temp1);
0A5C 0829  1184 	MOVF  temp1,W
0A5D 20D1  1185 	CALL  EEPROM_RD
0A5E 0020  1186 	MOVLB 0
0A5F 00A8  1187 	MOVWF temp_2
           1188 			;		address[i] = temp;
0A60 302A  1189 	MOVLW 42
0A61 0727  1190 	ADDWF i_6,W
0A62 0084  1191 	MOVWF FSR0L
0A63 0185  1192 	CLRF  FSR0H
0A64 0828  1193 	MOVF  temp_2,W
0A65 0080  1194 	MOVWF INDF0
           1195 			;	}
0A66 0AA7  1196 	INCF  i_6,1
0A67 2A4E  1197 	GOTO  m028
           1198 			;	
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 21

ADDR CODE  LINE SOURCE

           1199 			;#ifdef TEST
           1200 			;	USARTsend_str("Command:");
           1201 			;	USARTsend_num(address[0],'#');
           1202 			;	USARTsend_num(address[1],'#');
           1203 			;	USARTsend_num(address[2],'#');
           1204 			;	USARTsend_num(address[3],'#');
           1205 			;	USARTsend_num(r,'R');
           1206 			;	USARTsend_num(g,'G');
           1207 			;	USARTsend_num(b,'B');
           1208 			;#endif	
           1209 			;	ledstrip_set_color(&address[0],r,g,b);
0A68 302A  1210 m029	MOVLW 42
0A69 0020  1211 	MOVLB 0
0A6A 00AE  1212 	MOVWF address
0A6B 0824  1213 	MOVF  r_2,W
0A6C 00AF  1214 	MOVWF r
0A6D 0825  1215 	MOVF  g_2,W
0A6E 00B0  1216 	MOVWF g
0A6F 0826  1217 	MOVF  b_2,W
0A70 29F0  1218 	GOTO  ledstrip_set_color
           1219 
           1220   ; FILE include_files\ledstrip.h
           1221 			;#ifndef _LEDSTRIP_H_
           1222 			;#define _LEDSTRIP_H_
           1223 			;
           1224 			;//Nils Weiﬂ 
           1225 			;//20.04.2012
           1226 			;//Compiler CC5x
           1227 			;
           1228 			;#include "include_files\eeprom.h"
           1229 			;
           1230 			;#define NUM_OF_LED 32
           1231 			;
           1232 			;struct LedBuffer{
           1233 			;	char led_array_r[NUM_OF_LED];
           1234 			;	char led_array_g[NUM_OF_LED];
           1235 			;	char led_array_b[NUM_OF_LED];
           1236 			;	//char led_ctrl_array[BUFFERSIZE];
           1237 			;	};
           1238 			;extern struct LedBuffer gLedBuf;
           1239 			;
           1240 			;void ledstrip_init(void);
           1241 			;void ledstrip_set_color(char *address,char r,char g,char b);
           1242 			;void sub_func_set_color(char *cmdPointer);
           1243 			;
           1244 			;#include "include_files\spi.h"
           1245 			;#include "include_files\ledstrip.c"
           1246 
           1247   ; FILE main.c
           1248 			;#include "inline.h"
           1249 			;#include "include_files\Ringbuf.h"
           1250 			;#include "include_files\usart.h"
           1251 			;#include "include_files\eeprom.h"        
           1252 			;#include "include_files\crc.c"
           1253 			;#include "include_files\ledstrip.h"
           1254 			;#include "include_files\spi.h"
           1255 			;#include "include_files\timer.h"
           1256 			;//*********************** GLOBAL VARIABLES *******************************************
           1257 			;struct CommandBuffer{
           1258 			;    char cmd_counter;
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 22

ADDR CODE  LINE SOURCE

           1259 			;    char frame_counter;
           1260 			;    char cmd_buf[FRAMELENGTH];
           1261 			;    char crcH;
           1262 			;    char crcL;
           1263 			;};
           1264 			;static struct CommandBuffer gCmdBuf;
           1265 			;static char gERROR;
           1266 			;
           1267 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           1268 			;#pragma origin 4					//Adresse des Interrupts	
     0000  1269 	ORG 0x0004
           1270 			;interrupt InterruptRoutine(void)
           1271 			;{
           1272 InterruptRoutine
           1273 			;	if (RCIF)
0004 0020  1274 	MOVLB 0
0005 1E91  1275 	BTFSS 0x11,RCIF
0006 2813  1276 	GOTO  m031
           1277 			;	{
           1278 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184E  1279 	BTFSC gRingBuf+18,0
0008 280F  1280 	GOTO  m030
0009 0023  1281 	MOVLB 3
000A 0819  1282 	MOVF  RCREG,W
000B 3188  1283 	MOVLP 8
000C 2054  1284 	CALL  RingBufPut
000D 3180  1285 	MOVLP 0
           1286 			;		else 
000E 2813  1287 	GOTO  m031
           1288 			;		{
           1289 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           1290 			;			char temp = RCREG;
000F 0023  1291 m030	MOVLB 3
0010 0819  1292 	MOVF  RCREG,W
0011 0020  1293 	MOVLB 0
0012 00A0  1294 	MOVWF temp_3
           1295 			;		}
           1296 			;	}
           1297 			;}
0013 0009  1298 m031	RETFIE
           1299 			;
           1300 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           1301 			;void init_all();
           1302 			;void throw_errors();
           1303 			;void get_commands();
           1304 			;void execute_commands();
           1305 			;void sub_func_set_color(char *cmdPointer);
           1306 			;
           1307 			;//*********************** HAUPTPROGRAMM **********************************************
           1308 			;void main(void)
           1309 			;{
           1310 main
           1311 			;	init_all();
0014 2019  1312 	CALL  init_all
           1313 			;    while(1)
           1314 			;    {	
           1315 			;        throw_errors();
0015 2062  1316 m032	CALL  throw_errors
           1317 			;		get_commands();
0016 207E  1318 	CALL  get_commands
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 23

ADDR CODE  LINE SOURCE

           1319 			;		execute_commands();
0017 211B  1320 	CALL  execute_commands
           1321 			;    }
0018 2815  1322 	GOTO  m032
           1323 			;}
           1324 			;//*********************** UNTERPROGRAMME **********************************************
           1325 			;
           1326 			;void init_all()
           1327 			;{
           1328 init_all
           1329 			;	
           1330 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           1331 			;	OSCCON = 0b01110010;
0019 3072  1332 	MOVLW 114
001A 0021  1333 	MOVLB 1
001B 0099  1334 	MOVWF OSCCON
           1335 			;	RingBufInit();
001C 3188  1336 	MOVLP 8
001D 2043  1337 	CALL  RingBufInit
001E 3180  1338 	MOVLP 0
           1339 			;	//initialise UART interface
           1340 			;	USARTinit();
001F 3188  1341 	MOVLP 8
0020 2069  1342 	CALL  USARTinit
0021 3180  1343 	MOVLP 0
           1344 			;	spi_init();
0022 3188  1345 	MOVLP 8
0023 2176  1346 	CALL  spi_init
0024 3180  1347 	MOVLP 0
           1348 			;	ledstrip_init();
0025 3188  1349 	MOVLP 8
0026 21CE  1350 	CALL  ledstrip_init
0027 3180  1351 	MOVLP 0
           1352 			;
           1353 			;/** EEPROM contains FF in every Cell after inital start,
           1354 			;*** so I have to delet the pointer address
           1355 			;*** otherwise the PIC thinks he has the EEPROM full with commands
           1356 			;**/
           1357 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0028 30FF  1358 	MOVLW 255
0029 3188  1359 	MOVLP 8
002A 20D1  1360 	CALL  EEPROM_RD
002B 3180  1361 	MOVLP 0
002C 3AFF  1362 	XORLW 255
002D 1D03  1363 	BTFSS 0x03,Zero_
002E 2836  1364 	GOTO  m033
           1365 			;	EEPROM_WR(CmdPointerAddr, 0);
002F 30FF  1366 	MOVLW 255
0030 0020  1367 	MOVLB 0
0031 00AA  1368 	MOVWF adress
0032 3000  1369 	MOVLW 0
0033 3188  1370 	MOVLP 8
0034 20AF  1371 	CALL  EEPROM_WR
0035 3180  1372 	MOVLP 0
           1373 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
0036 30FD  1374 m033	MOVLW 253
0037 0020  1375 	MOVLB 0
0038 00AA  1376 	MOVWF adress
0039 3000  1377 	MOVLW 0
003A 3188  1378 	MOVLP 8
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 24

ADDR CODE  LINE SOURCE

003B 20AF  1379 	CALL  EEPROM_WR
003C 3180  1380 	MOVLP 0
           1381 			;	
           1382 			;	//Ausgang f¸r FET initalisieren
           1383 			;	TRISC.0 = 0;
003D 0021  1384 	MOVLB 1
003E 100E  1385 	BCF   TRISC,0
           1386 			;	//Spannungsversorgung f¸r LED's einschalten
           1387 			;	PORTC.0 = 0;
003F 0020  1388 	MOVLB 0
0040 100E  1389 	BCF   PORTC,0
           1390 			;
           1391 			;	//To Factory Restore WLAN Modul
           1392 			;	//TRISA.0=0;
           1393 			;	//PORTA.0 = 1;
           1394 			;    
           1395 			;    // *** load globals variables
           1396 			;    gERROR = 0;
0041 01E3  1397 	CLRF  gERROR
           1398 			;    gCmdBuf.cmd_counter = 0;
0042 01CF  1399 	CLRF  gCmdBuf
           1400 			;    gCmdBuf.frame_counter = 0;
0043 01D0  1401 	CLRF  gCmdBuf+1
           1402 			;	
           1403 			;	char i;
           1404 			;	for(i=0;i<FRAMELENGTH;i++)
0044 01A2  1405 	CLRF  i_7
0045 3010  1406 m034	MOVLW 16
0046 0020  1407 	MOVLB 0
0047 0222  1408 	SUBWF i_7,W
0048 1803  1409 	BTFSC 0x03,Carry
0049 2851  1410 	GOTO  m035
           1411 			;	{
           1412 			;        gCmdBuf.cmd_buf[i] = 0;
004A 3051  1413 	MOVLW 81
004B 0722  1414 	ADDWF i_7,W
004C 0084  1415 	MOVWF FSR0L
004D 0185  1416 	CLRF  FSR0H
004E 0180  1417 	CLRF  INDF0
           1418 			;	}
004F 0AA2  1419 	INCF  i_7,1
0050 2845  1420 	GOTO  m034
           1421 			;    
           1422 			;	// *** allow interrupts
           1423 			;	RCIE=1;
0051 0021  1424 m035	MOVLB 1
0052 1691  1425 	BSF   0x91,RCIE
           1426 			;	PEIE=1;
0053 170B  1427 	BSF   0x0B,PEIE
           1428 			;	GIE=1;
0054 178B  1429 	BSF   0x0B,GIE
           1430 			;	// *** send ready after init
           1431 			;	USARTsend('R');
0055 3052  1432 	MOVLW 82
0056 3188  1433 	MOVLP 8
0057 207C  1434 	CALL  USARTsend
0058 3180  1435 	MOVLP 0
           1436 			;	USARTsend('D');
0059 3044  1437 	MOVLW 68
005A 3188  1438 	MOVLP 8
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 25

ADDR CODE  LINE SOURCE

005B 207C  1439 	CALL  USARTsend
005C 3180  1440 	MOVLP 0
           1441 			;	USARTsend('Y');
005D 3059  1442 	MOVLW 89
005E 3188  1443 	MOVLP 8
005F 207C  1444 	CALL  USARTsend
0060 3180  1445 	MOVLP 0
           1446 			;
           1447 			;	
           1448 			;}
0061 0008  1449 	RETURN
           1450 			;
           1451 			;void throw_errors()
           1452 			;{
           1453 throw_errors
           1454 			;	if(RingBufHasError) 
0062 0020  1455 	MOVLB 0
0063 1C4E  1456 	BTFSS gRingBuf+18,0
0064 2869  1457 	GOTO  m036
           1458 			;	{
           1459 			;		USARTsend_str(" ERROR: Receivebuffer full");
0065 01A2  1460 	CLRF  putstr
0066 3188  1461 	MOVLP 8
0067 2086  1462 	CALL  USARTsend_str
0068 3180  1463 	MOVLP 0
           1464 			;	}
           1465 			;	if(gERROR.crc_failure)
0069 0020  1466 m036	MOVLB 0
006A 1C63  1467 	BTFSS gERROR,0
006B 2873  1468 	GOTO  m037
           1469 			;	{
           1470 			;		USARTsend_str(" ERROR: CRC-Check failed");
006C 301B  1471 	MOVLW 27
006D 00A2  1472 	MOVWF putstr
006E 3188  1473 	MOVLP 8
006F 2086  1474 	CALL  USARTsend_str
0070 3180  1475 	MOVLP 0
           1476 			;		gERROR.crc_failure = 0;
0071 0020  1477 	MOVLB 0
0072 1063  1478 	BCF   gERROR,0
           1479 			;	}
           1480 			;	if(gERROR.eeprom_failure)
0073 0020  1481 m037	MOVLB 0
0074 1CE3  1482 	BTFSS gERROR,1
0075 287D  1483 	GOTO  m038
           1484 			;	{
           1485 			;		USARTsend_str(" ERROR: EEPROM is full");
0076 3034  1486 	MOVLW 52
0077 00A2  1487 	MOVWF putstr
0078 3188  1488 	MOVLP 8
0079 2086  1489 	CALL  USARTsend_str
007A 3180  1490 	MOVLP 0
           1491 			;		gERROR.eeprom_failure = 0;
007B 0020  1492 	MOVLB 0
007C 10E3  1493 	BCF   gERROR,1
           1494 			;	}
           1495 			;}
007D 0008  1496 m038	RETURN
           1497 			;
           1498 			;/** This function reads one byte from the ringbuffer and check
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 26

ADDR CODE  LINE SOURCE

           1499 			;*** for framestart, framelength, or databyte 
           1500 			;*** if a frame is complete, the function save the frame as a new
           1501 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
           1502 			;**/
           1503 			;void get_commands()
           1504 			;{	
           1505 get_commands
           1506 			;	if(RingBufIsNotEmpty)
007E 0020  1507 	MOVLB 0
007F 084D  1508 	MOVF  gRingBuf+17,W
0080 064C  1509 	XORWF gRingBuf+16,W
0081 1903  1510 	BTFSC 0x03,Zero_
0082 291A  1511 	GOTO  m048
           1512 			;	{
           1513 			;		// *** preload variables and 
           1514 			;		// *** get new_byte from ringbuffer
           1515 			;		char new_byte, temp, j;
           1516 			;		temp = 0;
0083 01A3  1517 	CLRF  temp_4
           1518 			;		j = 0;
0084 01A4  1519 	CLRF  j
           1520 			;		// *** get new byte
           1521 			;		new_byte = RingBufGet();	
0085 3188  1522 	MOVLP 8
0086 2048  1523 	CALL  RingBufGet
0087 3180  1524 	MOVLP 0
0088 0020  1525 	MOVLB 0
0089 00A2  1526 	MOVWF new_byte
           1527 			;		// *** do I wait for databytes?
           1528 			;		if(gCmdBuf.frame_counter == 0)
008A 08D0  1529 	MOVF  gCmdBuf+1,1
008B 1D03  1530 	BTFSS 0x03,Zero_
008C 28BE  1531 	GOTO  m040
           1532 			;		{
           1533 			;			// *** I don't wait for databytes
           1534 			;			// *** Do I receive a Start_of_Text sign
           1535 			;			if(new_byte == STX)
008D 0F22  1536 	INCFSZ new_byte,W
008E 28A5  1537 	GOTO  m039
           1538 			;			{
           1539 			;				// *** increse the cmd_counter
           1540 			;				gCmdBuf.cmd_counter = 1;
008F 3001  1541 	MOVLW 1
0090 00CF  1542 	MOVWF gCmdBuf
           1543 			;				// *** Write the startsign at the begin of the buffer
           1544 			;				gCmdBuf.cmd_buf[0] = new_byte;
0091 0822  1545 	MOVF  new_byte,W
0092 00D1  1546 	MOVWF gCmdBuf+2
           1547 			;                // *** Reset crc Variables
           1548 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
0093 3061  1549 	MOVLW 97
0094 00A5  1550 	MOVWF p_crcH_2
0095 3062  1551 	MOVLW 98
0096 00A6  1552 	MOVWF p_crcL_2
0097 3188  1553 	MOVLP 8
0098 2162  1554 	CALL  newCRC
0099 3180  1555 	MOVLP 0
           1556 			;                // *** add new_byte to crc checksum
           1557 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
009A 0020  1558 	MOVLB 0
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 27

ADDR CODE  LINE SOURCE

009B 0822  1559 	MOVF  new_byte,W
009C 00A5  1560 	MOVWF byte
009D 3061  1561 	MOVLW 97
009E 00A6  1562 	MOVWF p_crcH
009F 3062  1563 	MOVLW 98
00A0 00A7  1564 	MOVWF p_crcL
00A1 3188  1565 	MOVLP 8
00A2 210D  1566 	CALL  addCRC
00A3 3180  1567 	MOVLP 0
           1568 			;			}
           1569 			;			else
00A4 291A  1570 	GOTO  m048
           1571 			;			{	
           1572 			;				// *** to avoid arrayoverflow
           1573 			;				temp = FRAMELENGTH - 2;
00A5 300E  1574 m039	MOVLW 14
00A6 0020  1575 	MOVLB 0
00A7 00A3  1576 	MOVWF temp_4
           1577 			;				// *** check if I get the framelength byte
           1578 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
00A8 0823  1579 	MOVF  temp_4,W
00A9 0222  1580 	SUBWF new_byte,W
00AA 1803  1581 	BTFSC 0x03,Carry
00AB 291A  1582 	GOTO  m048
00AC 0B4F  1583 	DECFSZ gCmdBuf,W
00AD 291A  1584 	GOTO  m048
           1585 			;				{
           1586 			;					gCmdBuf.frame_counter = new_byte;
00AE 0822  1587 	MOVF  new_byte,W
00AF 00D0  1588 	MOVWF gCmdBuf+1
           1589 			;					gCmdBuf.cmd_buf[1] = new_byte;
00B0 0822  1590 	MOVF  new_byte,W
00B1 00D2  1591 	MOVWF gCmdBuf+3
           1592 			;					gCmdBuf.cmd_counter = 2;
00B2 3002  1593 	MOVLW 2
00B3 00CF  1594 	MOVWF gCmdBuf
           1595 			;                    // *** add new_byte to crc checksum
           1596 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00B4 0822  1597 	MOVF  new_byte,W
00B5 00A5  1598 	MOVWF byte
00B6 3061  1599 	MOVLW 97
00B7 00A6  1600 	MOVWF p_crcH
00B8 3062  1601 	MOVLW 98
00B9 00A7  1602 	MOVWF p_crcL
00BA 3188  1603 	MOVLP 8
00BB 210D  1604 	CALL  addCRC
00BC 3180  1605 	MOVLP 0
           1606 			;				}
           1607 			;			}
           1608 			;		}
           1609 			;		else
00BD 291A  1610 	GOTO  m048
           1611 			;		{
           1612 			;			// *** I wait for Databytes, so I save all bytes 
           1613 			;			// *** that I get until my framecounter is > 0
           1614 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
00BE 3051  1615 m040	MOVLW 81
00BF 0020  1616 	MOVLB 0
00C0 074F  1617 	ADDWF gCmdBuf,W
00C1 0084  1618 	MOVWF FSR0L
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 28

ADDR CODE  LINE SOURCE

00C2 0185  1619 	CLRF  FSR0H
00C3 0822  1620 	MOVF  new_byte,W
00C4 0080  1621 	MOVWF INDF0
           1622 			;			gCmdBuf.cmd_counter++;
00C5 0ACF  1623 	INCF  gCmdBuf,1
           1624 			;			
           1625 			;            // *** add new_byte to crc checksum
           1626 			;			if(gCmdBuf.frame_counter > 2)
00C6 3003  1627 	MOVLW 3
00C7 0250  1628 	SUBWF gCmdBuf+1,W
00C8 1C03  1629 	BTFSS 0x03,Carry
00C9 28D3  1630 	GOTO  m041
           1631 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00CA 0822  1632 	MOVF  new_byte,W
00CB 00A5  1633 	MOVWF byte
00CC 3061  1634 	MOVLW 97
00CD 00A6  1635 	MOVWF p_crcH
00CE 3062  1636 	MOVLW 98
00CF 00A7  1637 	MOVWF p_crcL
00D0 3188  1638 	MOVLP 8
00D1 210D  1639 	CALL  addCRC
00D2 3180  1640 	MOVLP 0
           1641 			;			gCmdBuf.frame_counter--;
00D3 0020  1642 m041	MOVLB 0
00D4 0BD0  1643 	DECFSZ gCmdBuf+1,1
           1644 			;			// *** now I have to check if my framecounter is null.
           1645 			;			// *** If it's null my string is complete 
           1646 			;			// *** and I can give the string to the crc check function.
           1647 			;			if(gCmdBuf.frame_counter == 0)
00D5 291A  1648 	GOTO  m048
           1649 			;			{
           1650 			;#ifdef NO_CRC
           1651 			;				if(1==1)
           1652 			;#else
           1653 			;                // *** verify crc checksum
           1654 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           1655 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           1656 			;#endif
           1657 			;                {
           1658 			;					// *** Execute the simple Commands
           1659 			;					switch(gCmdBuf.cmd_buf[2])
00D6 0853  1660 	MOVF  gCmdBuf+4,W
00D7 3AF8  1661 	XORLW 248
00D8 1903  1662 	BTFSC 0x03,Zero_
00D9 28E1  1663 	GOTO  m042
00DA 3A02  1664 	XORLW 2
00DB 1903  1665 	BTFSC 0x03,Zero_
00DC 28E9  1666 	GOTO  m043
00DD 3A03  1667 	XORLW 3
00DE 1903  1668 	BTFSC 0x03,Zero_
00DF 28EC  1669 	GOTO  m044
00E0 28EF  1670 	GOTO  m045
           1671 			;					{
           1672 			;						case DELETE: 
           1673 			;							{
           1674 			;								EEPROM_WR(CmdPointerAddr,0);
00E1 30FF  1675 m042	MOVLW 255
00E2 0020  1676 	MOVLB 0
00E3 00AA  1677 	MOVWF adress
00E4 3000  1678 	MOVLW 0
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 29

ADDR CODE  LINE SOURCE

00E5 3188  1679 	MOVLP 8
00E6 20AF  1680 	CALL  EEPROM_WR
00E7 3180  1681 	MOVLP 0
           1682 			;								return;
00E8 0008  1683 	RETURN
           1684 			;							}
           1685 			;						case SET_ON: 
           1686 			;							{
           1687 			;								BCF(PORTC.0); 
00E9 0020  1688 m043	MOVLB 0
00EA 100E  1689 	BCF   PORTC,0
           1690 			;								return;
00EB 0008  1691 	RETURN
           1692 			;								}
           1693 			;						case SET_OFF: 
           1694 			;							{
           1695 			;								BSF(PORTC.0); 
00EC 0020  1696 m044	MOVLB 0
00ED 140E  1697 	BSF   PORTC,0
           1698 			;								return;
00EE 0008  1699 	RETURN
           1700 			;							}
           1701 			;					}
           1702 			;                    char CmdPointer = EEPROM_RD(CmdPointerAddr);
00EF 30FF  1703 m045	MOVLW 255
00F0 3188  1704 	MOVLP 8
00F1 20D1  1705 	CALL  EEPROM_RD
00F2 3180  1706 	MOVLP 0
00F3 0020  1707 	MOVLB 0
00F4 00A5  1708 	MOVWF CmdPointer
           1709 			;					// *** check if there is enough space in the EEPROM for the next command
           1710 			;                    if(CmdPointer < (CmdPointerAddr - CmdWidth))
00F5 30F5  1711 	MOVLW 245
00F6 0225  1712 	SUBWF CmdPointer,W
00F7 1803  1713 	BTFSC 0x03,Carry
00F8 2901  1714 	GOTO  m046
           1715 			;                    {
           1716 			;                        // *** calculate the next address for EEPROM write
           1717 			;                        EEPROM_WR(CmdPointerAddr,(CmdPointer + CmdWidth));
00F9 30FF  1718 	MOVLW 255
00FA 00AA  1719 	MOVWF adress
00FB 300A  1720 	MOVLW 10
00FC 0725  1721 	ADDWF CmdPointer,W
00FD 3188  1722 	MOVLP 8
00FE 20AF  1723 	CALL  EEPROM_WR
00FF 3180  1724 	MOVLP 0
           1725 			;                    }
           1726 			;                    else 
0100 2904  1727 	GOTO  m047
           1728 			;                    {
           1729 			;                        // *** EEPROM is full with commands
           1730 			;                        // *** Some errorhandling should be here
           1731 			;						gERROR.eeprom_failure = 1;
0101 0020  1732 m046	MOVLB 0
0102 14E3  1733 	BSF   gERROR,1
           1734 			;                        return;
0103 0008  1735 	RETURN
           1736 			;                    } 
           1737 			;					// *** Write the new command without STX and CRC
           1738 			;					EEPROM_WR_BLK(&gCmdBuf.cmd_buf[2], CmdPointer, (gCmdBuf.cmd_counter -4));
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 30

ADDR CODE  LINE SOURCE

0104 3053  1739 m047	MOVLW 83
0105 0020  1740 	MOVLB 0
0106 00A6  1741 	MOVWF array_2
0107 0825  1742 	MOVF  CmdPointer,W
0108 00A7  1743 	MOVWF adress_3
0109 3004  1744 	MOVLW 4
010A 024F  1745 	SUBWF gCmdBuf,W
010B 3188  1746 	MOVLP 8
010C 20DE  1747 	CALL  EEPROM_WR_BLK
010D 3180  1748 	MOVLP 0
           1749 			;					// *** Send a Message('G'et 'C'ommand) when a new Command is received successfull
           1750 			;					USARTsend('G');
010E 3047  1751 	MOVLW 71
010F 3188  1752 	MOVLP 8
0110 207C  1753 	CALL  USARTsend
0111 3180  1754 	MOVLP 0
           1755 			;					USARTsend('C');
0112 3043  1756 	MOVLW 67
0113 3188  1757 	MOVLP 8
0114 207C  1758 	CALL  USARTsend
0115 3180  1759 	MOVLP 0
           1760 			;#ifdef TEST
           1761 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           1762 			;#endif
           1763 			;                }
           1764 			;                else
0116 291A  1765 	GOTO  m048
           1766 			;                {
           1767 			;                    // *** Do some error handling in case of an CRC failure here
           1768 			;					gERROR.crc_failure = 1;
0117 0020  1769 	MOVLB 0
0118 1463  1770 	BSF   gERROR,0
           1771 			;                    return;
0119 0008  1772 	RETURN
           1773 			;                }
           1774 			;			}
           1775 			;		}
           1776 			;	}
           1777 			;}
011A 0008  1778 m048	RETURN
           1779 			;
           1780 			;/** This function reads the pointer for commands in the EEPROM from a defined address 
           1781 			;*** in the EEPROM. After this one by one command is executed by this function. 
           1782 			;**/ 
           1783 			;void execute_commands()
           1784 			;{
           1785 execute_commands
           1786 			;	// *** get the pointer to commands in the EEPROM
           1787 			;	char pointer = EEPROM_RD(CmdPointerAddr);
011B 30FF  1788 	MOVLW 255
011C 3188  1789 	MOVLP 8
011D 20D1  1790 	CALL  EEPROM_RD
011E 3180  1791 	MOVLP 0
011F 0020  1792 	MOVLB 0
0120 00A2  1793 	MOVWF pointer
           1794 			;	// *** are there commands to execute?
           1795 			;	if(pointer != 0)
0121 08A2  1796 	MOVF  pointer,1
0122 1903  1797 	BTFSC 0x03,Zero_
0123 2941  1798 	GOTO  m051
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 31

ADDR CODE  LINE SOURCE

           1799 			;	{
           1800 			;		// *** commands available, check what to do
           1801 			;		switch(EEPROM_RD(pointer - CmdWidth)) 
0124 300A  1802 	MOVLW 10
0125 0222  1803 	SUBWF pointer,W
0126 3188  1804 	MOVLP 8
0127 20D1  1805 	CALL  EEPROM_RD
0128 3180  1806 	MOVLP 0
0129 3AFD  1807 	XORLW 253
012A 1903  1808 	BTFSC 0x03,Zero_
012B 2933  1809 	GOTO  m049
012C 3A01  1810 	XORLW 1
012D 1903  1811 	BTFSC 0x03,Zero_
012E 2939  1812 	GOTO  m050
012F 3A07  1813 	XORLW 7
0130 1903  1814 	BTFSC 0x03,Zero_
0131 2939  1815 	GOTO  m050
0132 2939  1816 	GOTO  m050
           1817 			;		{	
           1818 			;			case SET_COLOR: 
           1819 			;			{
           1820 			;				sub_func_set_color(&pointer);
0133 3022  1821 m049	MOVLW 34
0134 0020  1822 	MOVLB 0
0135 00A3  1823 	MOVWF cmdPointer
0136 3188  1824 	MOVLP 8
0137 2234  1825 	CALL  sub_func_set_color
0138 3180  1826 	MOVLP 0
           1827 			;				break;
           1828 			;			}
           1829 			;			case SET_FADE: {break;}
           1830 			;			case SET_RUN: {break;}
           1831 			;		}
           1832 			;		// *** set commandpointer to the next command
           1833 			;		EEPROM_WR(CmdPointerAddr, (pointer - CmdWidth));
0139 30FF  1834 m050	MOVLW 255
013A 0020  1835 	MOVLB 0
013B 00AA  1836 	MOVWF adress
013C 300A  1837 	MOVLW 10
013D 0222  1838 	SUBWF pointer,W
013E 3188  1839 	MOVLP 8
013F 20AF  1840 	CALL  EEPROM_WR
0140 3180  1841 	MOVLP 0
           1842 			;	}
           1843 			;}
0141 0008  1844 m051	RETURN
           1845 
           1846 	END
           1847 
           1848 
           1849 ; *** KEY INFO ***
           1850 
           1851 ; 0x0004 P0   16 word(s)  0 % : InterruptRoutine
           1852 ; 0x0019 P0   73 word(s)  3 % : init_all
           1853 ; 0x0062 P0   28 word(s)  1 % : throw_errors
           1854 ; 0x007E P0  157 word(s)  7 % : get_commands
           1855 ; 0x011B P0   39 word(s)  1 % : execute_commands
           1856 ; 0x0014 P0    5 word(s)  0 % : main
           1857 
           1858 ; 0x0843 P1    5 word(s)  0 % : RingBufInit
CC5X Version 3.4E,   File: main.c               9. May 2012  17:13   Page 32

ADDR CODE  LINE SOURCE

           1859 ; 0x0848 P1   12 word(s)  0 % : RingBufGet
           1860 ; 0x0854 P1   21 word(s)  1 % : RingBufPut
           1861 ; 0x0869 P1   19 word(s)  0 % : USARTinit
           1862 ; 0x087C P1   10 word(s)  0 % : USARTsend
           1863 ; 0x0886 P1   23 word(s)  1 % : USARTsend_str
           1864 ; 0x089D P1   18 word(s)  0 % : USARTsend_arr
           1865 ; 0x0800 P1   67 word(s)  3 % : _const1
           1866 ; 0x08AF P1   34 word(s)  1 % : EEPROM_WR
           1867 ; 0x08D1 P1   13 word(s)  0 % : EEPROM_RD
           1868 ; 0x08DE P1   25 word(s)  1 % : EEPROM_WR_BLK
           1869 ; 0x08F7 P1   22 word(s)  1 % : EEPROM_RD_BLK
           1870 ; 0x090D P1   40 word(s)  1 % : addCRC
           1871 ; 0x0935 P1   45 word(s)  2 % : CRC
           1872 ; 0x0962 P1   20 word(s)  0 % : newCRC
           1873 ; 0x09CE P1   34 word(s)  1 % : ledstrip_init
           1874 ; 0x09F0 P1   68 word(s)  3 % : ledstrip_set_color
           1875 ; 0x0A34 P1   61 word(s)  2 % : sub_func_set_color
           1876 ; 0x0976 P1   11 word(s)  0 % : spi_init
           1877 ; 0x0981 P1    8 word(s)  0 % : spi_send
           1878 ; 0x0989 P1   11 word(s)  0 % : spi_receive
           1879 ; 0x0994 P1   18 word(s)  0 % : spi_send_arr
           1880 ; 0x09A6 P1   40 word(s)  1 % : spi_send_ledbuf
           1881 
           1882 ; RAM usage: 164 bytes (28 local), 348 bytes free
           1883 ; Maximum call level: 3 (+2 for interrupt)
           1884 ;  Codepage 0 has  319 word(s) :  15 %
           1885 ;  Codepage 1 has  625 word(s) :  30 %
           1886 ;  Codepage 2 has    0 word(s) :   0 %
           1887 ;  Codepage 3 has    0 word(s) :   0 %
           1888 ; Total of 944 code words (11 %)
