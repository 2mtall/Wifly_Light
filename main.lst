CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  13. May 2012  14:11  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gCmdBuf     EQU   0x4C
     005F  0055 gERROR      EQU   0x5F
     0060  0056 gComState   EQU   0x60
     0020  0057 temp        EQU   0x20
     0022  0058 i           EQU   0x22
     0022  0059 new_byte    EQU   0x22
     0023  0060 temp_2      EQU   0x23
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 2

ADDR CODE  LINE SOURCE

     0024  0061 j           EQU   0x24
     0025  0062 CmdPointer  EQU   0x25
     0022  0063 pointer     EQU   0x22
     0025  0064 byte        EQU   0x25
     0026  0065 p_crcH      EQU   0x26
     0027  0066 p_crcL      EQU   0x27
     0028  0067 index       EQU   0x28
     0029  0068 crcH        EQU   0x29
     002A  0069 crcL        EQU   0x2A
     007F  0070 data        EQU   0x7F
     007F  0071 length      EQU   0x7F
     007F  0072 crcH_out    EQU   0x7F
     007F  0073 crcL_out    EQU   0x7F
     007F  0074 crcH_2      EQU   0x7F
     007F  0075 crcL_2      EQU   0x7F
     007F  0076 i_2         EQU   0x7F
     007F  0077 byte_2      EQU   0x7F
     0025  0078 p_crcH_2    EQU   0x25
     0026  0079 p_crcL_2    EQU   0x26
     002A  0080 adress      EQU   0x2A
     002B  0081 data_2      EQU   0x2B
     0000  0082 GIE_status  EQU   0
     002E  0083 adress_2    EQU   0x2E
     002F  0084 data_3      EQU   0x2F
     0026  0085 array       EQU   0x26
     0027  0086 adress_3    EQU   0x27
     0028  0087 length_2    EQU   0x28
     0029  0088 i_3         EQU   0x29
     007F  0089 array_2     EQU   0x7F
     007F  0090 adress_4    EQU   0x7F
     007F  0091 length_3    EQU   0x7F
     007F  0092 i_4         EQU   0x7F
     007F  0093 temp_3      EQU   0x7F
     0023  0094 k           EQU   0x23
     002E  0095 address     EQU   0x2E
     002F  0096 r           EQU   0x2F
     0030  0097 g           EQU   0x30
     0031  0098 b           EQU   0x31
     0032  0099 k_2         EQU   0x32
     0033  0100 mask        EQU   0x33
     0023  0101 cmdPointer  EQU   0x23
     0024  0102 r_2         EQU   0x24
     0025  0103 g_2         EQU   0x25
     0026  0104 b_2         EQU   0x26
     0027  0105 i_5         EQU   0x27
     0028  0106 temp_4      EQU   0x28
     0029  0107 temp1       EQU   0x29
     0025  0108 result      EQU   0x25
     0020  0109 value       EQU   0x20
     0021  0110 writeNext   EQU   0x21
     0038  0111 data_4      EQU   0x38
     007F  0112 array_3     EQU   0x7F
     007F  0113 length_4    EQU   0x7F
     007F  0114 i_6         EQU   0x7F
     0034  0115 array_4     EQU   0x34
     0036  0116 end         EQU   0x36
     0026  0117 ch          EQU   0x26
     0022  0118 string      EQU   0x22
     0023  0119 ps          EQU   0x23
     007F  0120 array_5     EQU   0x7F
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 3

ADDR CODE  LINE SOURCE

     007F  0121 length_5    EQU   0x7F
     007F  0122 i_7         EQU   0x7F
     0024  0123 ci          EQU   0x24
           0124 
0000 2855  0125 	GOTO main
           0126 
           0127   ; FILE main.c
           0128 			;//Nils Weiﬂ 
           0129 			;//05.09.2011
           0130 			;//Compiler CC5x/
           0131 			;//#define USE_UNION
           0132 			;//#define TEST
           0133 			;#define NO_CRC
           0134 			;#define MPLAB_IDE
           0135 			;
           0136 			;#include "platform.h"
           0137 			;#pragma sharedAllocation
           0138 			;
           0139 			;//*********************** ENUMERATIONS *********************************************
           0140 			;#define TRUE  1
           0141 			;#define FALSE 0
           0142 			;
           0143 			;#define STX 0xFF
           0144 			;#define SET_COLOR 0xFD
           0145 			;#define SET_FADE 0xFC
           0146 			;#define SET_RUN 0xFB
           0147 			;#define WAIT 0xFE
           0148 			;#define SET_ON 0xFA
           0149 			;#define SET_OFF 0xF9
           0150 			;#define DELETE 0xF8
           0151 			;#ifndef USE_UNION
           0152 			;#define CmdPointerAddr 0xff		// *** Address at EERPOM. Commandpointer indicates the nummer of commands
           0153 			;#define CmdLoopPointerAddr 0xfd // *** Address at EEPROM. CommandLoopPointer indicates the next command. Used in Loop-Mode
           0154 			;#endif
           0155 			;//*********************** INCLUDEDATEIEN *********************************************
           0156 			;#pragma codepage 1
     0000  0157 	ORG 0x0800
           0158 
           0159   ; FILE main.c
           0160 			;#ifdef USE_UNION
           0161 			;#include "commandstorage.h"
           0162 			;#endif
           0163 			;#include "RingBuf.h"		//clean
           0164 			;#include "usart.h"			//clean
           0165 			;#include "eeprom.h"       	//clean 
           0166 			;#include "crc.h"			//clean
           0167 			;#include "ledstrip.h"		//under construction
           0168 			;#include "spi.h"			//clean
           0169 			;#include "timer.h"
           0170 			;
           0171 			;//*********************** GLOBAL VARIABLES *******************************************
           0172 			;#ifdef USE_UNION
           0173 			;#define FRAMELENGTH (sizeof(struct led_cmd) + 5)			// *** max length of one commandframe
           0174 			;#else
           0175 			;#define FRAMELENGTH 15
           0176 			;#endif
           0177 			;
           0178 			;struct CommandBuffer{
           0179 			;    char cmd_counter;
           0180 			;    char frame_counter;
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 4

ADDR CODE  LINE SOURCE

           0181 			;    char cmd_buf[FRAMELENGTH];
           0182 			;    char crcH;
           0183 			;    char crcL;
           0184 			;};
           0185 			;static struct CommandBuffer gCmdBuf;
           0186 			;
           0187 			;// *** ERRORBITS
           0188 			;static struct {
           0189 			;		char crc_failure:1;
           0190 			;		char eeprom_failure:1;
           0191 			;}gERROR;
           0192 			;static char gComState;
           0193 			;
           0194 			;//********************************* MACROS *******************************************
           0195 			;
           0196 			;#define ClearCmdBuf  		\
           0197 			;{							\
           0198 			;	gCmdBuf.cmd_counter = 0;\
           0199 			;	gCmdBuf.frame_counter = 0; \
           0200 			;}
           0201 			;
           0202 			;#ifndef X86
           0203 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0204 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0205 	ORG 0x0004
           0206 			;interrupt InterruptRoutine(void)
           0207 			;{
           0208 InterruptRoutine
           0209 			;	if (RCIF)
0004 0020  0210 	MOVLB 0
0005 1E91  0211 	BTFSS 0x11,RCIF
0006 2811  0212 	GOTO  m002
           0213 			;	{
           0214 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0215 	BTFSC gRingBuf+18,0
0008 280D  0216 	GOTO  m001
0009 0023  0217 	MOVLB 3
000A 0819  0218 	MOVF  RCREG,W
000B 22BC  0219 	CALL  RingBufPut
           0220 			;		else 
000C 2811  0221 	GOTO  m002
           0222 			;		{
           0223 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           0224 			;			char temp = RCREG;
000D 0023  0225 m001	MOVLB 3
000E 0819  0226 	MOVF  RCREG,W
000F 0020  0227 	MOVLB 0
0010 00A0  0228 	MOVWF temp
           0229 			;		}
           0230 			;	}
           0231 			;}
0011 0009  0232 m002	RETFIE
           0233 			;#endif /* #ifndef X86 */
           0234 			;
           0235 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0236 			;void init_all();
           0237 			;void throw_errors();
           0238 			;void get_commands();
           0239 			;void execute_commands();
           0240 			;
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 5

ADDR CODE  LINE SOURCE

           0241 			;//*********************** HAUPTPROGRAMM **********************************************
           0242 			;void main(void)
           0243 			;{
           0244 _const1
0012 0020  0245 	MOVLB 0
0013 00A4  0246 	MOVWF ci
0014 3000  0247 	MOVLW 0
0015 0023  0248 	MOVLB 3
0016 0092  0249 	MOVWF EEADRH
0017 0020  0250 	MOVLB 0
0018 0C24  0251 	RRF   ci,W
0019 397F  0252 	ANDLW 127
001A 3E2F  0253 	ADDLW 47
001B 0023  0254 	MOVLB 3
001C 0091  0255 	MOVWF EEADRL
001D 1803  0256 	BTFSC 0x03,Carry
001E 0A92  0257 	INCF  EEADRH,1
001F 0023  0258 	MOVLB 3
0020 1795  0259 	BSF   0x195,EEPGD
0021 1415  0260 	BSF   0x195,RD
0022 0000  0261 	NOP  
0023 0000  0262 	NOP  
0024 0020  0263 	MOVLB 0
0025 1824  0264 	BTFSC ci,0
0026 282B  0265 	GOTO  m003
0027 0023  0266 	MOVLB 3
0028 0813  0267 	MOVF  EEDATL,W
0029 397F  0268 	ANDLW 127
002A 0008  0269 	RETURN
002B 0023  0270 m003	MOVLB 3
002C 0D13  0271 	RLF   EEDATL,W
002D 0D14  0272 	RLF   EEDATH,W
002E 0008  0273 	RETURN
002F 22A0  0274 	DW    0x22A0
0030 2952  0275 	DW    0x2952
0031 294F  0276 	DW    0x294F
0032 103A  0277 	DW    0x103A
0033 32D2  0278 	DW    0x32D2
0034 32E3  0279 	DW    0x32E3
0035 3B69  0280 	DW    0x3B69
0036 3165  0281 	DW    0x3165
0037 3375  0282 	DW    0x3375
0038 32E6  0283 	DW    0x32E6
0039 1072  0284 	DW    0x1072
003A 3AE6  0285 	DW    0x3AE6
003B 366C  0286 	DW    0x366C
003C 1000  0287 	DW    0x1000
003D 2945  0288 	DW    0x2945
003E 27D2  0289 	DW    0x27D2
003F 1D52  0290 	DW    0x1D52
0040 21A0  0291 	DW    0x21A0
0041 21D2  0292 	DW    0x21D2
0042 21AD  0293 	DW    0x21AD
0043 32E8  0294 	DW    0x32E8
0044 35E3  0295 	DW    0x35E3
0045 3320  0296 	DW    0x3320
0046 34E1  0297 	DW    0x34E1
0047 32EC  0298 	DW    0x32EC
0048 0064  0299 	DW    0x64
0049 22A0  0300 	DW    0x22A0
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 6

ADDR CODE  LINE SOURCE

004A 2952  0301 	DW    0x2952
004B 294F  0302 	DW    0x294F
004C 103A  0303 	DW    0x103A
004D 22C5  0304 	DW    0x22C5
004E 2950  0305 	DW    0x2950
004F 26CF  0306 	DW    0x26CF
0050 34A0  0307 	DW    0x34A0
0051 1073  0308 	DW    0x1073
0052 3AE6  0309 	DW    0x3AE6
0053 366C  0310 	DW    0x366C
0054 0000  0311 	DW    0x0
           0312 main
           0313 			;	init_all();
0055 205A  0314 	CALL  init_all
           0315 			;    while(1)
           0316 			;    {	
           0317 			;        throw_errors();
0056 2090  0318 m004	CALL  throw_errors
           0319 			;		get_commands();
0057 20A9  0320 	CALL  get_commands
           0321 			;		execute_commands();
0058 2134  0322 	CALL  execute_commands
           0323 			;    }
0059 2856  0324 	GOTO  m004
           0325 			;}
           0326 			;//*********************** UNTERPROGRAMME **********************************************
           0327 			;
           0328 			;void init_all()
           0329 			;{
           0330 init_all
           0331 			;#ifndef X86
           0332 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           0333 			;	OSCCON = 0b01110010;
005A 3072  0334 	MOVLW 114
005B 0021  0335 	MOVLB 1
005C 0099  0336 	MOVWF OSCCON
           0337 			;#endif /* #ifndef X86 */
           0338 			;	RingBufInit();
005D 22AB  0339 	CALL  RingBufInit
           0340 			;	//initialise UART interface
           0341 			;	USARTinit();
005E 2319  0342 	CALL  USARTinit
           0343 			;	spi_init();
005F 22D1  0344 	CALL  spi_init
           0345 			;	ledstrip_init();
0060 221A  0346 	CALL  ledstrip_init
           0347 			;
           0348 			;/** EEPROM contains FF in every cell after inital start,
           0349 			;*** so I have to delet the pointer address
           0350 			;*** otherwise the PIC thinks he has the EEPROM full with commands
           0351 			;**/
           0352 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0061 30FF  0353 	MOVLW 255
0062 21DE  0354 	CALL  EEPROM_RD
0063 3AFF  0355 	XORLW 255
0064 1D03  0356 	BTFSS 0x03,Zero_
0065 286B  0357 	GOTO  m005
           0358 			;	EEPROM_WR(CmdPointerAddr, 0);
0066 30FF  0359 	MOVLW 255
0067 0020  0360 	MOVLB 0
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 7

ADDR CODE  LINE SOURCE

0068 00AA  0361 	MOVWF adress
0069 3000  0362 	MOVLW 0
006A 21BC  0363 	CALL  EEPROM_WR
           0364 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
006B 30FD  0365 m005	MOVLW 253
006C 0020  0366 	MOVLB 0
006D 00AA  0367 	MOVWF adress
006E 3000  0368 	MOVLW 0
006F 21BC  0369 	CALL  EEPROM_WR
           0370 			;	
           0371 			;#ifndef X86
           0372 			;	//Ausgang f¸r FET initalisieren
           0373 			;	TRISC.0 = 0;
0070 0021  0374 	MOVLB 1
0071 100E  0375 	BCF   TRISC,0
           0376 			;	//Spannungsversorgung f¸r LED's einschalten
           0377 			;	PORTC.0 = 0;
0072 0020  0378 	MOVLB 0
0073 100E  0379 	BCF   PORTC,0
           0380 			;#endif /* #ifndef X86 */
           0381 			;
           0382 			;	//To Factory Restore WLAN Modul
           0383 			;	//TRISA.0 = 0;
           0384 			;	//PORTA.0 = 1;
           0385 			;    
           0386 			;    // *** load globals variables
           0387 			;    gERROR.crc_failure = 0;
0074 105F  0388 	BCF   gERROR,0
           0389 			;    gERROR.eeprom_failure = 0;
0075 10DF  0390 	BCF   gERROR,1
           0391 			;    gCmdBuf.cmd_counter = 0;
0076 01CC  0392 	CLRF  gCmdBuf
           0393 			;    gCmdBuf.frame_counter = 0;
0077 01CD  0394 	CLRF  gCmdBuf+1
           0395 			;	gComState = 0;
0078 01E0  0396 	CLRF  gComState
           0397 			;	
           0398 			;	char i;
           0399 			;	for(i=0;i<FRAMELENGTH;i++)
0079 01A2  0400 	CLRF  i
007A 300F  0401 m006	MOVLW 15
007B 0020  0402 	MOVLB 0
007C 0222  0403 	SUBWF i,W
007D 1803  0404 	BTFSC 0x03,Carry
007E 2886  0405 	GOTO  m007
           0406 			;	{
           0407 			;        gCmdBuf.cmd_buf[i] = 0;
007F 304E  0408 	MOVLW 78
0080 0722  0409 	ADDWF i,W
0081 0084  0410 	MOVWF FSR0L
0082 0185  0411 	CLRF  FSR0H
0083 0180  0412 	CLRF  INDF0
           0413 			;	}
0084 0AA2  0414 	INCF  i,1
0085 287A  0415 	GOTO  m006
           0416 			;
           0417 			;#ifndef X86
           0418 			;	// *** allow interrupts
           0419 			;	RCIE=1;
0086 0021  0420 m007	MOVLB 1
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 8

ADDR CODE  LINE SOURCE

0087 1691  0421 	BSF   0x91,RCIE
           0422 			;	PEIE=1;
0088 170B  0423 	BSF   0x0B,PEIE
           0424 			;	GIE=1;
0089 178B  0425 	BSF   0x0B,GIE
           0426 			;#endif /* #ifndef X86 */
           0427 			;	// *** send ready after init
           0428 			;	USARTsend('R');
008A 3052  0429 	MOVLW 82
008B 232C  0430 	CALL  USARTsend
           0431 			;	USARTsend('D');
008C 3044  0432 	MOVLW 68
008D 232C  0433 	CALL  USARTsend
           0434 			;	USARTsend('Y');
008E 3059  0435 	MOVLW 89
008F 2B2C  0436 	GOTO  USARTsend
           0437 			;
           0438 			;	
           0439 			;}
           0440 			;
           0441 			;void throw_errors()
           0442 			;{
           0443 throw_errors
           0444 			;	if(RingBufHasError) 
0090 0020  0445 	MOVLB 0
0091 1C4B  0446 	BTFSS gRingBuf+18,0
0092 2898  0447 	GOTO  m008
           0448 			;	{
           0449 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0450 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0451 			;		ClearCmdBuf;
0093 01CC  0452 	CLRF  gCmdBuf
0094 01CD  0453 	CLRF  gCmdBuf+1
           0454 			;		USARTsend_str(" ERROR: Receivebuffer full");
0095 01A2  0455 	CLRF  string
0096 2336  0456 	CALL  USARTsend_str
           0457 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0458 			;		RingBufInit();
0097 22AB  0459 	CALL  RingBufInit
           0460 			;	}
           0461 			;	if(gERROR.crc_failure)
0098 0020  0462 m008	MOVLB 0
0099 1C5F  0463 	BTFSS gERROR,0
009A 28A0  0464 	GOTO  m009
           0465 			;	{
           0466 			;		USARTsend_str(" ERROR: CRC-Check failed");
009B 301B  0467 	MOVLW 27
009C 00A2  0468 	MOVWF string
009D 2336  0469 	CALL  USARTsend_str
           0470 			;		gERROR.crc_failure = 0;
009E 0020  0471 	MOVLB 0
009F 105F  0472 	BCF   gERROR,0
           0473 			;	}
           0474 			;	if(gERROR.eeprom_failure)
00A0 0020  0475 m009	MOVLB 0
00A1 1CDF  0476 	BTFSS gERROR,1
00A2 28A8  0477 	GOTO  m010
           0478 			;	{
           0479 			;		USARTsend_str(" ERROR: EEPROM is full");
00A3 3034  0480 	MOVLW 52
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 9

ADDR CODE  LINE SOURCE

00A4 00A2  0481 	MOVWF string
00A5 2336  0482 	CALL  USARTsend_str
           0483 			;		gERROR.eeprom_failure = 0;
00A6 0020  0484 	MOVLB 0
00A7 10DF  0485 	BCF   gERROR,1
           0486 			;	}
           0487 			;}
00A8 0008  0488 m010	RETURN
           0489 			;
           0490 			;/** This function reads one byte from the ringbuffer and check
           0491 			;*** for framestart, framelength, or databyte 
           0492 			;*** if a frame is complete, the function save the frame as a new
           0493 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
           0494 			;**/
           0495 			;void get_commands()
           0496 			;{	
           0497 get_commands
           0498 			;	if(RingBufHasError)
00A9 0020  0499 	MOVLB 0
00AA 1C4B  0500 	BTFSS gRingBuf+18,0
00AB 28AE  0501 	GOTO  m011
           0502 			;	{
           0503 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0504 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0505 			;		ClearCmdBuf;
00AC 01CC  0506 	CLRF  gCmdBuf
00AD 01CD  0507 	CLRF  gCmdBuf+1
           0508 			;	}
           0509 			;
           0510 			;	if(RingBufIsNotEmpty)
00AE 0020  0511 m011	MOVLB 0
00AF 084A  0512 	MOVF  gRingBuf+17,W
00B0 0649  0513 	XORWF gRingBuf+16,W
00B1 1903  0514 	BTFSC 0x03,Zero_
00B2 2933  0515 	GOTO  m021
           0516 			;	{
           0517 			;		// *** preload variables and 
           0518 			;		// *** get new_byte from ringbuffer
           0519 			;		char new_byte, temp, j;
           0520 			;		temp = 0;
00B3 01A3  0521 	CLRF  temp_2
           0522 			;		j = 0;
00B4 01A4  0523 	CLRF  j
           0524 			;		// *** get new byte
           0525 			;		new_byte = RingBufGet();	
00B5 22B0  0526 	CALL  RingBufGet
00B6 0020  0527 	MOVLB 0
00B7 00A2  0528 	MOVWF new_byte
           0529 			;		// *** do I wait for databytes?
           0530 			;		if(gCmdBuf.frame_counter == 0)
00B8 08CD  0531 	MOVF  gCmdBuf+1,1
00B9 1D03  0532 	BTFSS 0x03,Zero_
00BA 28E6  0533 	GOTO  m013
           0534 			;		{
           0535 			;			// *** I don't wait for databytes
           0536 			;			// *** Do I receive a Start_of_Text sign
           0537 			;			if(new_byte == STX)
00BB 0F22  0538 	INCFSZ new_byte,W
00BC 28CF  0539 	GOTO  m012
           0540 			;			{
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 10

ADDR CODE  LINE SOURCE

           0541 			;				// *** increse the cmd_counter
           0542 			;				gCmdBuf.cmd_counter = 1;
00BD 3001  0543 	MOVLW 1
00BE 00CC  0544 	MOVWF gCmdBuf
           0545 			;				// *** Write the startsign at the begin of the buffer
           0546 			;				gCmdBuf.cmd_buf[0] = new_byte;
00BF 0822  0547 	MOVF  new_byte,W
00C0 00CE  0548 	MOVWF gCmdBuf+2
           0549 			;                // *** Reset crc Variables
           0550 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
00C1 305D  0551 	MOVLW 93
00C2 00A5  0552 	MOVWF p_crcH_2
00C3 305E  0553 	MOVLW 94
00C4 00A6  0554 	MOVWF p_crcL_2
00C5 21A8  0555 	CALL  newCRC
           0556 			;                // *** add new_byte to crc checksum
           0557 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00C6 0020  0558 	MOVLB 0
00C7 0822  0559 	MOVF  new_byte,W
00C8 00A5  0560 	MOVWF byte
00C9 305D  0561 	MOVLW 93
00CA 00A6  0562 	MOVWF p_crcH
00CB 305E  0563 	MOVLW 94
00CC 00A7  0564 	MOVWF p_crcL
00CD 2153  0565 	CALL  addCRC
           0566 			;			}
           0567 			;			else
00CE 2933  0568 	GOTO  m021
           0569 			;			{	
           0570 			;				// *** to avoid arrayoverflow
           0571 			;				temp = FRAMELENGTH - 2;
00CF 300D  0572 m012	MOVLW 13
00D0 0020  0573 	MOVLB 0
00D1 00A3  0574 	MOVWF temp_2
           0575 			;				// *** check if I get the framelength byte
           0576 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
00D2 0823  0577 	MOVF  temp_2,W
00D3 0222  0578 	SUBWF new_byte,W
00D4 1803  0579 	BTFSC 0x03,Carry
00D5 2933  0580 	GOTO  m021
00D6 0B4C  0581 	DECFSZ gCmdBuf,W
00D7 2933  0582 	GOTO  m021
           0583 			;				{
           0584 			;					gCmdBuf.frame_counter = new_byte;
00D8 0822  0585 	MOVF  new_byte,W
00D9 00CD  0586 	MOVWF gCmdBuf+1
           0587 			;					gCmdBuf.cmd_buf[1] = new_byte;
00DA 0822  0588 	MOVF  new_byte,W
00DB 00CF  0589 	MOVWF gCmdBuf+3
           0590 			;					gCmdBuf.cmd_counter = 2;
00DC 3002  0591 	MOVLW 2
00DD 00CC  0592 	MOVWF gCmdBuf
           0593 			;                    // *** add new_byte to crc checksum
           0594 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00DE 0822  0595 	MOVF  new_byte,W
00DF 00A5  0596 	MOVWF byte
00E0 305D  0597 	MOVLW 93
00E1 00A6  0598 	MOVWF p_crcH
00E2 305E  0599 	MOVLW 94
00E3 00A7  0600 	MOVWF p_crcL
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 11

ADDR CODE  LINE SOURCE

00E4 2153  0601 	CALL  addCRC
           0602 			;				}
           0603 			;			}
           0604 			;		}
           0605 			;		else
00E5 2933  0606 	GOTO  m021
           0607 			;		{
           0608 			;			// *** I wait for Databytes, so I save all bytes 
           0609 			;			// *** that I get until my framecounter is > 0
           0610 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
00E6 304E  0611 m013	MOVLW 78
00E7 0020  0612 	MOVLB 0
00E8 074C  0613 	ADDWF gCmdBuf,W
00E9 0084  0614 	MOVWF FSR0L
00EA 0185  0615 	CLRF  FSR0H
00EB 0822  0616 	MOVF  new_byte,W
00EC 0080  0617 	MOVWF INDF0
           0618 			;			gCmdBuf.cmd_counter++;
00ED 0ACC  0619 	INCF  gCmdBuf,1
           0620 			;			
           0621 			;            // *** add new_byte to crc checksum
           0622 			;			if(gCmdBuf.frame_counter > 2)
00EE 3003  0623 	MOVLW 3
00EF 024D  0624 	SUBWF gCmdBuf+1,W
00F0 1C03  0625 	BTFSS 0x03,Carry
00F1 28F9  0626 	GOTO  m014
           0627 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00F2 0822  0628 	MOVF  new_byte,W
00F3 00A5  0629 	MOVWF byte
00F4 305D  0630 	MOVLW 93
00F5 00A6  0631 	MOVWF p_crcH
00F6 305E  0632 	MOVLW 94
00F7 00A7  0633 	MOVWF p_crcL
00F8 2153  0634 	CALL  addCRC
           0635 			;			gCmdBuf.frame_counter--;
00F9 0020  0636 m014	MOVLB 0
00FA 0BCD  0637 	DECFSZ gCmdBuf+1,1
           0638 			;			// *** now I have to check if my framecounter is null.
           0639 			;			// *** If it's null my string is complete 
           0640 			;			// *** and I can give the string to the crc check function.
           0641 			;			if(gCmdBuf.frame_counter == 0)
00FB 2933  0642 	GOTO  m021
           0643 			;			{
           0644 			;#ifdef NO_CRC
           0645 			;				if(1==1)
           0646 			;#else
           0647 			;                // *** verify crc checksum
           0648 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           0649 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           0650 			;#endif
           0651 			;                {
           0652 			;					// *** Execute the simple Commands
           0653 			;					switch(gCmdBuf.cmd_buf[2])
00FC 0850  0654 	MOVF  gCmdBuf+4,W
00FD 3AF8  0655 	XORLW 248
00FE 1903  0656 	BTFSC 0x03,Zero_
00FF 2907  0657 	GOTO  m015
0100 3A02  0658 	XORLW 2
0101 1903  0659 	BTFSC 0x03,Zero_
0102 290C  0660 	GOTO  m016
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 12

ADDR CODE  LINE SOURCE

0103 3A03  0661 	XORLW 3
0104 1903  0662 	BTFSC 0x03,Zero_
0105 290F  0663 	GOTO  m017
0106 2912  0664 	GOTO  m018
           0665 			;					{
           0666 			;						case DELETE: 
           0667 			;							{
           0668 			;								EEPROM_WR(CmdPointerAddr,0);
0107 30FF  0669 m015	MOVLW 255
0108 0020  0670 	MOVLB 0
0109 00AA  0671 	MOVWF adress
010A 3000  0672 	MOVLW 0
010B 29BC  0673 	GOTO  EEPROM_WR
           0674 			;								return;
           0675 			;							}
           0676 			;#ifndef X86
           0677 			;						case SET_ON: 
           0678 			;							{
           0679 			;								BCF(PORTC.0); 
010C 0020  0680 m016	MOVLB 0
010D 100E  0681 	BCF   PORTC,0
           0682 			;								return;
010E 0008  0683 	RETURN
           0684 			;								}
           0685 			;						case SET_OFF: 
           0686 			;							{
           0687 			;								BSF(PORTC.0); 
010F 0020  0688 m017	MOVLB 0
0110 140E  0689 	BSF   PORTC,0
           0690 			;								return;
0111 0008  0691 	RETURN
           0692 			;							}
           0693 			;#endif /* #ifndef X86 */
           0694 			;					}
           0695 			;#ifndef USE_UNION
           0696 			;                    char CmdPointer = EEPROM_RD(CmdPointerAddr);
0112 30FF  0697 m018	MOVLW 255
0113 21DE  0698 	CALL  EEPROM_RD
0114 0020  0699 	MOVLB 0
0115 00A5  0700 	MOVWF CmdPointer
           0701 			;					// *** check if there is enough space in the EEPROM for the next command
           0702 			;                    if(CmdPointer < (CmdPointerAddr - CmdWidth))
0116 30F5  0703 	MOVLW 245
0117 0225  0704 	SUBWF CmdPointer,W
0118 1803  0705 	BTFSC 0x03,Carry
0119 2920  0706 	GOTO  m019
           0707 			;                    {
           0708 			;                        // *** calculate the next address for EEPROM write
           0709 			;                        EEPROM_WR(CmdPointerAddr,(CmdPointer + CmdWidth));
011A 30FF  0710 	MOVLW 255
011B 00AA  0711 	MOVWF adress
011C 300A  0712 	MOVLW 10
011D 0725  0713 	ADDWF CmdPointer,W
011E 21BC  0714 	CALL  EEPROM_WR
           0715 			;                    }
           0716 			;                    else 
011F 2923  0717 	GOTO  m020
           0718 			;                    {
           0719 			;                        // *** EEPROM is full with commands
           0720 			;                        // *** Some errorhandling should be here
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 13

ADDR CODE  LINE SOURCE

           0721 			;						gERROR.eeprom_failure = 1;
0120 0020  0722 m019	MOVLB 0
0121 14DF  0723 	BSF   gERROR,1
           0724 			;                        return;
0122 0008  0725 	RETURN
           0726 			;                    } 
           0727 			;					// *** Write the new command without STX and CRC
           0728 			;
           0729 			;					EEPROM_WR_BLK(&gCmdBuf.cmd_buf[2], CmdPointer, (gCmdBuf.cmd_counter -4));
0123 3050  0730 m020	MOVLW 80
0124 0020  0731 	MOVLB 0
0125 00A6  0732 	MOVWF array
0126 0825  0733 	MOVF  CmdPointer,W
0127 00A7  0734 	MOVWF adress_3
0128 3004  0735 	MOVLW 4
0129 024C  0736 	SUBWF gCmdBuf,W
012A 21EB  0737 	CALL  EEPROM_WR_BLK
           0738 			;					// *** Send a Message('G'et 'C'ommand) when a new Command is received successfull
           0739 			;					USARTsend('G');
012B 3047  0740 	MOVLW 71
012C 232C  0741 	CALL  USARTsend
           0742 			;					USARTsend('C');
012D 3043  0743 	MOVLW 67
012E 232C  0744 	CALL  USARTsend
           0745 			;#else				
           0746 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
           0747 			;					{
           0748 			;						USARTsend('G');
           0749 			;						USARTsend('C');
           0750 			;					}
           0751 			;					else 
           0752 			;						gERROR.eeprom_failure = 1;
           0753 			;#endif // use union
           0754 			;#ifdef TEST
           0755 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           0756 			;#endif
           0757 			;                }
           0758 			;                else
012F 2933  0759 	GOTO  m021
           0760 			;                {
           0761 			;                    // *** Do some error handling in case of an CRC failure here
           0762 			;					gERROR.crc_failure = 1;
0130 0020  0763 	MOVLB 0
0131 145F  0764 	BSF   gERROR,0
           0765 			;                    return;
0132 0008  0766 	RETURN
           0767 			;                }
           0768 			;			}
           0769 			;		}
           0770 			;	}
           0771 			;}
0133 0008  0772 m021	RETURN
           0773 			;#ifndef USE_UNION
           0774 			;/** This function reads the pointer for commands in the EEPROM from a defined address 
           0775 			;*** in the EEPROM. After this one by one command is executed by this function. 
           0776 			;**/ 
           0777 			;void execute_commands()
           0778 			;{
           0779 execute_commands
           0780 			;	// *** get the pointer to commands in the EEPROM
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 14

ADDR CODE  LINE SOURCE

           0781 			;	char pointer = EEPROM_RD(CmdPointerAddr);
0134 30FF  0782 	MOVLW 255
0135 21DE  0783 	CALL  EEPROM_RD
0136 0020  0784 	MOVLB 0
0137 00A2  0785 	MOVWF pointer
           0786 			;	// *** are there commands to execute?
           0787 			;	if(pointer != 0)
0138 08A2  0788 	MOVF  pointer,1
0139 1903  0789 	BTFSC 0x03,Zero_
013A 2952  0790 	GOTO  m024
           0791 			;	{
           0792 			;		// *** commands available, check what to do
           0793 			;		switch(EEPROM_RD(pointer - CmdWidth)) 
013B 300A  0794 	MOVLW 10
013C 0222  0795 	SUBWF pointer,W
013D 21DE  0796 	CALL  EEPROM_RD
013E 3AFD  0797 	XORLW 253
013F 1903  0798 	BTFSC 0x03,Zero_
0140 2948  0799 	GOTO  m022
0141 3A01  0800 	XORLW 1
0142 1903  0801 	BTFSC 0x03,Zero_
0143 294C  0802 	GOTO  m023
0144 3A07  0803 	XORLW 7
0145 1903  0804 	BTFSC 0x03,Zero_
0146 294C  0805 	GOTO  m023
0147 294C  0806 	GOTO  m023
           0807 			;		{	
           0808 			;			case SET_COLOR: 
           0809 			;			{
           0810 			;				sub_func_set_color(&pointer);
0148 3022  0811 m022	MOVLW 34
0149 0020  0812 	MOVLB 0
014A 00A3  0813 	MOVWF cmdPointer
014B 226E  0814 	CALL  sub_func_set_color
           0815 			;				break;
           0816 			;			}
           0817 			;			case SET_FADE: {break;}
           0818 			;			case SET_RUN: {break;}
           0819 			;		}
           0820 			;		// *** set commandpointer to the next command
           0821 			;		EEPROM_WR(CmdPointerAddr, (pointer - CmdWidth));
014C 30FF  0822 m023	MOVLW 255
014D 0020  0823 	MOVLB 0
014E 00AA  0824 	MOVWF adress
014F 300A  0825 	MOVLW 10
0150 0222  0826 	SUBWF pointer,W
0151 29BC  0827 	GOTO  EEPROM_WR
           0828 			;	}
           0829 			;}
0152 0008  0830 m024	RETURN
           0831 
           0832   ; FILE crc.c
           0833 			; // Include-Datei zum Erstellen von CRC Pr¸fsummen
           0834 			; //
           0835 			; //
           0836 			; // Nils Weiﬂ
           0837 			; // 14.04.2012
           0838 			; // Compiler CC5x
           0839 			;
           0840 			;// 16-bit CCIT CRC
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 15

ADDR CODE  LINE SOURCE

           0841 			;
           0842 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0843 			;{
           0844 addCRC
           0845 			;	char index;
           0846 			;	char crcH,crcL;
           0847 			;	crcH = *p_crcH;
0153 0185  0848 	CLRF  FSR0H
0154 0020  0849 	MOVLB 0
0155 0826  0850 	MOVF  p_crcH,W
0156 0084  0851 	MOVWF FSR0L
0157 0800  0852 	MOVF  INDF0,W
0158 00A9  0853 	MOVWF crcH
           0854 			;	crcL = *p_crcL;
0159 0185  0855 	CLRF  FSR0H
015A 0827  0856 	MOVF  p_crcL,W
015B 0084  0857 	MOVWF FSR0L
015C 0800  0858 	MOVF  INDF0,W
015D 00AA  0859 	MOVWF crcL
           0860 			;
           0861 			;	MOVF(byte,0);
015E 0825  0862 	MOVF  byte,W
           0863 			;	
           0864 			;	XORWF(crcH,0);
015F 0629  0865 	XORWF crcH,W
           0866 			;	MOVWF(index);
0160 00A8  0867 	MOVWF index
           0868 			;	ANDLW(0xf0);
0161 39F0  0869 	ANDLW 240
           0870 			;	SWAPF(index,1);
0162 0EA8  0871 	SWAPF index,1
           0872 			;	XORWF(index,1);
0163 06A8  0873 	XORWF index,1
           0874 			;	
           0875 			;	MOVF(index,0);
0164 0828  0876 	MOVF  index,W
           0877 			;	ANDLW(0xf0);
0165 39F0  0878 	ANDLW 240
           0879 			;	XORWF(crcL,0);
0166 062A  0880 	XORWF crcL,W
           0881 			;	MOVWF(crcH);
0167 00A9  0882 	MOVWF crcH
           0883 			;	
           0884 			;	RLF(index,0);
0168 0D28  0885 	RLF   index,W
           0886 			;	RLF(index,0);
0169 0D28  0887 	RLF   index,W
           0888 			;	XORWF(crcH,1);
016A 06A9  0889 	XORWF crcH,1
           0890 			;	ANDLW(0xe0);
016B 39E0  0891 	ANDLW 224
           0892 			;	XORWF(crcH,1);
016C 06A9  0893 	XORWF crcH,1
           0894 			;		
           0895 			;	SWAPF(index,1);
016D 0EA8  0896 	SWAPF index,1
           0897 			;	XORWF(index,0);
016E 0628  0898 	XORWF index,W
           0899 			;	MOVWF(crcL);
016F 00AA  0900 	MOVWF crcL
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 16

ADDR CODE  LINE SOURCE

           0901 			;
           0902 			;	*p_crcH = crcH;
0170 0185  0903 	CLRF  FSR0H
0171 0826  0904 	MOVF  p_crcH,W
0172 0084  0905 	MOVWF FSR0L
0173 0829  0906 	MOVF  crcH,W
0174 0080  0907 	MOVWF INDF0
           0908 			;	*p_crcL = crcL;
0175 0185  0909 	CLRF  FSR0H
0176 0827  0910 	MOVF  p_crcL,W
0177 0084  0911 	MOVWF FSR0L
0178 082A  0912 	MOVF  crcL,W
0179 0080  0913 	MOVWF INDF0
           0914 			;
           0915 			;}
017A 0008  0916 	RETURN
           0917 			;
           0918 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0919 			;{
           0920 CRC
           0921 			;	if(!crcH_out)return;
017B 08FF  0922 	MOVF  crcH_out,1
017C 1903  0923 	BTFSC 0x03,Zero_
017D 0008  0924 	RETURN
           0925 			;	if(!crcL_out)return;
017E 08FF  0926 	MOVF  crcL_out,1
017F 1903  0927 	BTFSC 0x03,Zero_
0180 0008  0928 	RETURN
           0929 			;	if(!data)return;
0181 08FF  0930 	MOVF  data,1
0182 1903  0931 	BTFSC 0x03,Zero_
0183 0008  0932 	RETURN
           0933 			;	char crcH,crcL,i,byte;
           0934 			;	crcH=0xff;
0184 30FF  0935 	MOVLW 255
0185 00FF  0936 	MOVWF crcH_2
           0937 			;	crcL=0xff;
0186 30FF  0938 	MOVLW 255
0187 00FF  0939 	MOVWF crcL_2
           0940 			;
           0941 			;	for(i=0;i<length;i++)
0188 01FF  0942 	CLRF  i_2
0189 087F  0943 m025	MOVF  length,W
018A 027F  0944 	SUBWF i_2,W
018B 1803  0945 	BTFSC 0x03,Carry
018C 299D  0946 	GOTO  m026
           0947 			;	{
           0948 			;		byte = data[i];
018D 087F  0949 	MOVF  i_2,W
018E 077F  0950 	ADDWF data,W
018F 0084  0951 	MOVWF FSR0L
0190 0185  0952 	CLRF  FSR0H
0191 0800  0953 	MOVF  INDF0,W
0192 00FF  0954 	MOVWF byte_2
           0955 			;		addCRC(byte,&crcH,&crcL);
0193 087F  0956 	MOVF  byte_2,W
0194 0020  0957 	MOVLB 0
0195 00A5  0958 	MOVWF byte
0196 307F  0959 	MOVLW 127
0197 00A6  0960 	MOVWF p_crcH
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 17

ADDR CODE  LINE SOURCE

0198 307F  0961 	MOVLW 127
0199 00A7  0962 	MOVWF p_crcL
019A 2153  0963 	CALL  addCRC
           0964 			;	}
019B 0AFF  0965 	INCF  i_2,1
019C 2989  0966 	GOTO  m025
           0967 			;	
           0968 			;	*crcH_out = crcH;
019D 0185  0969 m026	CLRF  FSR0H
019E 087F  0970 	MOVF  crcH_out,W
019F 0084  0971 	MOVWF FSR0L
01A0 087F  0972 	MOVF  crcH_2,W
01A1 0080  0973 	MOVWF INDF0
           0974 			;	*crcL_out = crcL;
01A2 0185  0975 	CLRF  FSR0H
01A3 087F  0976 	MOVF  crcL_out,W
01A4 0084  0977 	MOVWF FSR0L
01A5 087F  0978 	MOVF  crcL_2,W
01A6 0080  0979 	MOVWF INDF0
           0980 			;}
01A7 0008  0981 	RETURN
           0982 			;
           0983 			;void newCRC(char* p_crcH, char* p_crcL)
           0984 			;{
           0985 newCRC
           0986 			;    if(!p_crcH) return;
01A8 0020  0987 	MOVLB 0
01A9 08A5  0988 	MOVF  p_crcH_2,1
01AA 1903  0989 	BTFSC 0x03,Zero_
01AB 0008  0990 	RETURN
           0991 			;    if(!p_crcL) return;
01AC 0020  0992 	MOVLB 0
01AD 08A6  0993 	MOVF  p_crcL_2,1
01AE 1903  0994 	BTFSC 0x03,Zero_
01AF 0008  0995 	RETURN
           0996 			;    *p_crcH = 0xff;
01B0 0185  0997 	CLRF  FSR0H
01B1 0020  0998 	MOVLB 0
01B2 0825  0999 	MOVF  p_crcH_2,W
01B3 0084  1000 	MOVWF FSR0L
01B4 30FF  1001 	MOVLW 255
01B5 0080  1002 	MOVWF INDF0
           1003 			;    *p_crcL = 0xff;
01B6 0185  1004 	CLRF  FSR0H
01B7 0826  1005 	MOVF  p_crcL_2,W
01B8 0084  1006 	MOVWF FSR0L
01B9 30FF  1007 	MOVLW 255
01BA 0080  1008 	MOVWF INDF0
           1009 			;}
01BB 0008  1010 	RETURN
           1011 
           1012   ; FILE eeprom.c
           1013 			;//Funktionen f¸r EEPROM-Zugriffe
           1014 			;
           1015 			;//Nils Weiﬂ 
           1016 			;//05.09.2011
           1017 			;//Compiler CC5x
           1018 			;
           1019 			;#ifndef X86
           1020 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 18

ADDR CODE  LINE SOURCE

           1021 			;
           1022 			;void EEPROM_WR(char adress, char data)
           1023 			;{
           1024 EEPROM_WR
01BC 0020  1025 	MOVLB 0
01BD 00AB  1026 	MOVWF data_2
           1027 			;	bit GIE_status; 
           1028 			;	//EEADRH = (char)(adress<<8);
           1029 			;    EEADRL = (char)adress;        // Adresse in Adressregister ¸bertragen
01BE 082A  1030 	MOVF  adress,W
01BF 0023  1031 	MOVLB 3
01C0 0091  1032 	MOVWF EEADRL
           1033 			;	EEDATL = data;          // Daten in Datenregister ¸bertragen
01C1 0020  1034 	MOVLB 0
01C2 082B  1035 	MOVF  data_2,W
01C3 0023  1036 	MOVLB 3
01C4 0093  1037 	MOVWF EEDATL
           1038 			;    CFGS = 0;
01C5 1315  1039 	BCF   0x195,CFGS
           1040 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
01C6 1395  1041 	BCF   0x195,EEPGD
           1042 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
01C7 1515  1043 	BSF   0x195,WREN
           1044 			;	GIE_status=GIE;			
01C8 0020  1045 	MOVLB 0
01C9 102C  1046 	BCF   0x2C,GIE_status
01CA 1B8B  1047 	BTFSC 0x0B,GIE
01CB 142C  1048 	BSF   0x2C,GIE_status
           1049 			;    GIE=0;                  // Interrups verbieten
01CC 138B  1050 	BCF   0x0B,GIE
           1051 			;    EECON2 = 0x55;
01CD 3055  1052 	MOVLW 85
01CE 0023  1053 	MOVLB 3
01CF 0096  1054 	MOVWF EECON2
           1055 			;    EECON2 = 0xAA;
01D0 30AA  1056 	MOVLW 170
01D1 0096  1057 	MOVWF EECON2
           1058 			;	WR=1; 					// Starten des Schreibens
01D2 1495  1059 	BSF   0x195,WR
           1060 			;    GIE=GIE_status;                  // Interrups erlauben
01D3 0020  1061 	MOVLB 0
01D4 1C2C  1062 	BTFSS 0x2C,GIE_status
01D5 138B  1063 	BCF   0x0B,GIE
01D6 182C  1064 	BTFSC 0x2C,GIE_status
01D7 178B  1065 	BSF   0x0B,GIE
           1066 			;	WREN=0;
01D8 0023  1067 	MOVLB 3
01D9 1115  1068 	BCF   0x195,WREN
           1069 			;	while(WR);
01DA 0023  1070 m027	MOVLB 3
01DB 1895  1071 	BTFSC 0x195,WR
01DC 29DA  1072 	GOTO  m027
           1073 			;}
01DD 0008  1074 	RETURN
           1075 			;
           1076 			;//*********************** EEPROM BYTE LESEN  **********************************************
           1077 			;
           1078 			;char EEPROM_RD(char adress)
           1079 			;{
           1080 EEPROM_RD
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 19

ADDR CODE  LINE SOURCE

01DE 0020  1081 	MOVLB 0
01DF 00AE  1082 	MOVWF adress_2
           1083 			;    char data;
           1084 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister ¸bertragen
           1085 			;    EEADRL = (char)(adress);
01E0 082E  1086 	MOVF  adress_2,W
01E1 0023  1087 	MOVLB 3
01E2 0091  1088 	MOVWF EEADRL
           1089 			;	CFGS=0;
01E3 1315  1090 	BCF   0x195,CFGS
           1091 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
01E4 1395  1092 	BCF   0x195,EEPGD
           1093 			;    RD=1;                   // Starten des Lesesn
01E5 1415  1094 	BSF   0x195,RD
           1095 			;    data = EEDATL;       // Daten aus Datenregister auslesen
01E6 0813  1096 	MOVF  EEDATL,W
01E7 0020  1097 	MOVLB 0
01E8 00AF  1098 	MOVWF data_3
           1099 			;    return data;
01E9 082F  1100 	MOVF  data_3,W
01EA 0008  1101 	RETURN
           1102 			;}
           1103 			;#endif /* #ifndef X86 */
           1104 			;
           1105 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           1106 			;
           1107 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           1108 			;{
           1109 EEPROM_WR_BLK
01EB 0020  1110 	MOVLB 0
01EC 00A8  1111 	MOVWF length_2
           1112 			;	if(!array) return;
01ED 08A6  1113 	MOVF  array,1
01EE 1903  1114 	BTFSC 0x03,Zero_
01EF 0008  1115 	RETURN
           1116 			;	char i;
           1117 			;	for(i=0;i<length;i++)
01F0 0020  1118 	MOVLB 0
01F1 01A9  1119 	CLRF  i_3
01F2 0020  1120 m028	MOVLB 0
01F3 0828  1121 	MOVF  length_2,W
01F4 0229  1122 	SUBWF i_3,W
01F5 1803  1123 	BTFSC 0x03,Carry
01F6 2A03  1124 	GOTO  m029
           1125 			;	{
           1126 			;		EEPROM_WR(adress,*array);
01F7 0827  1127 	MOVF  adress_3,W
01F8 00AA  1128 	MOVWF adress
01F9 0185  1129 	CLRF  FSR0H
01FA 0826  1130 	MOVF  array,W
01FB 0084  1131 	MOVWF FSR0L
01FC 0800  1132 	MOVF  INDF0,W
01FD 21BC  1133 	CALL  EEPROM_WR
           1134 			;		adress++;
01FE 0020  1135 	MOVLB 0
01FF 0AA7  1136 	INCF  adress_3,1
           1137 			;		array++;
0200 0AA6  1138 	INCF  array,1
           1139 			;	}
0201 0AA9  1140 	INCF  i_3,1
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 20

ADDR CODE  LINE SOURCE

0202 29F2  1141 	GOTO  m028
           1142 			;}
0203 0008  1143 m029	RETURN
           1144 			;
           1145 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           1146 			;
           1147 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           1148 			;{
           1149 EEPROM_RD_BLK
0204 00FF  1150 	MOVWF length_3
           1151 			;	if(!array) return;
0205 08FF  1152 	MOVF  array_2,1
0206 1903  1153 	BTFSC 0x03,Zero_
0207 0008  1154 	RETURN
           1155 			;	char i, temp;
           1156 			;	for(i=0;i<length;i++)
0208 01FF  1157 	CLRF  i_4
0209 087F  1158 m030	MOVF  length_3,W
020A 027F  1159 	SUBWF i_4,W
020B 1803  1160 	BTFSC 0x03,Carry
020C 2A19  1161 	GOTO  m031
           1162 			;	{
           1163 			;		temp = EEPROM_RD(adress);
020D 087F  1164 	MOVF  adress_4,W
020E 21DE  1165 	CALL  EEPROM_RD
020F 00FF  1166 	MOVWF temp_3
           1167 			;		array[i] = temp;
0210 087F  1168 	MOVF  i_4,W
0211 077F  1169 	ADDWF array_2,W
0212 0084  1170 	MOVWF FSR0L
0213 0185  1171 	CLRF  FSR0H
0214 087F  1172 	MOVF  temp_3,W
0215 0080  1173 	MOVWF INDF0
           1174 			;		adress++;
0216 0AFF  1175 	INCF  adress_4,1
           1176 			;	}
0217 0AFF  1177 	INCF  i_4,1
0218 2A09  1178 	GOTO  m030
           1179 			;}
0219 0008  1180 m031	RETURN
           1181 
           1182   ; FILE ledstrip.c
           1183 			;//Nils Weiﬂ 
           1184 			;//20.04.2012
           1185 			;//Compiler CC5x 
           1186 			;
           1187 			;#include "ledstrip.h"
           1188 			;
           1189 			;struct LedBuffer gLedBuf;
           1190 			;
           1191 			;void ledstrip_init(void)
           1192 			;{
           1193 ledstrip_init
           1194 			;	char k;
           1195 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
021A 0020  1196 	MOVLB 0
021B 01A3  1197 	CLRF  k
021C 3060  1198 m032	MOVLW 96
021D 0020  1199 	MOVLB 0
021E 0223  1200 	SUBWF k,W
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 21

ADDR CODE  LINE SOURCE

021F 1803  1201 	BTFSC 0x03,Carry
0220 2A2B  1202 	GOTO  m033
           1203 			;	{	
           1204 			;		gLedBuf.led_array[k] = 0;
0221 3020  1205 	MOVLW 32
0222 0085  1206 	MOVWF FSR0+1
0223 3041  1207 	MOVLW 65
0224 0723  1208 	ADDWF k,W
0225 0084  1209 	MOVWF FSR0
0226 1803  1210 	BTFSC 0x03,Carry
0227 0A85  1211 	INCF  FSR0+1,1
0228 0180  1212 	CLRF  INDF0
           1213 			;	}
0229 0AA3  1214 	INCF  k,1
022A 2A1C  1215 	GOTO  m032
           1216 			;}
022B 0008  1217 m033	RETURN
           1218 			;#ifndef USE_UNION
           1219 			;/***
           1220 			;*** This funktion sets the values of the global LedBuffer
           1221 			;*** only Led's where the address bit is 1 will be set to the new color
           1222 			;***/
           1223 			;
           1224 			;void ledstrip_set_color(char *address, char r, char g, char b)
           1225 			;{	
           1226 ledstrip_set_color
022C 0020  1227 	MOVLB 0
022D 00B1  1228 	MOVWF b
           1229 			;	char k,mask;
           1230 			;	mask = 0b00000001;
022E 3001  1231 	MOVLW 1
022F 00B3  1232 	MOVWF mask
           1233 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
0230 01B2  1234 	CLRF  k_2
0231 3060  1235 m034	MOVLW 96
0232 0020  1236 	MOVLB 0
0233 0232  1237 	SUBWF k_2,W
0234 1803  1238 	BTFSC 0x03,Carry
0235 2A68  1239 	GOTO  m038
           1240 			;	{	
           1241 			;		if(0 != (*address & mask))
0236 0185  1242 	CLRF  FSR0H
0237 082E  1243 	MOVF  address,W
0238 0084  1244 	MOVWF FSR0L
0239 0833  1245 	MOVF  mask,W
023A 0500  1246 	ANDWF INDF0,W
023B 1903  1247 	BTFSC 0x03,Zero_
023C 2A5B  1248 	GOTO  m035
           1249 			;		{
           1250 			;			gLedBuf.led_array[k] = b;
023D 3020  1251 	MOVLW 32
023E 0085  1252 	MOVWF FSR0+1
023F 3041  1253 	MOVLW 65
0240 0732  1254 	ADDWF k_2,W
0241 0084  1255 	MOVWF FSR0
0242 1803  1256 	BTFSC 0x03,Carry
0243 0A85  1257 	INCF  FSR0+1,1
0244 0831  1258 	MOVF  b,W
0245 0080  1259 	MOVWF INDF0
           1260 			;			k++;
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 22

ADDR CODE  LINE SOURCE

0246 0AB2  1261 	INCF  k_2,1
           1262 			;			gLedBuf.led_array[k] = g;
0247 3020  1263 	MOVLW 32
0248 0085  1264 	MOVWF FSR0+1
0249 3041  1265 	MOVLW 65
024A 0732  1266 	ADDWF k_2,W
024B 0084  1267 	MOVWF FSR0
024C 1803  1268 	BTFSC 0x03,Carry
024D 0A85  1269 	INCF  FSR0+1,1
024E 0830  1270 	MOVF  g,W
024F 0080  1271 	MOVWF INDF0
           1272 			;			k++;
0250 0AB2  1273 	INCF  k_2,1
           1274 			;			gLedBuf.led_array[k] = r;
0251 3020  1275 	MOVLW 32
0252 0085  1276 	MOVWF FSR0+1
0253 3041  1277 	MOVLW 65
0254 0732  1278 	ADDWF k_2,W
0255 0084  1279 	MOVWF FSR0
0256 1803  1280 	BTFSC 0x03,Carry
0257 0A85  1281 	INCF  FSR0+1,1
0258 082F  1282 	MOVF  r,W
0259 0080  1283 	MOVWF INDF0
           1284 			;		}
           1285 			;		else 
025A 2A5E  1286 	GOTO  m036
           1287 			;		{
           1288 			;			k++;
025B 0020  1289 m035	MOVLB 0
025C 0AB2  1290 	INCF  k_2,1
           1291 			;			k++;
025D 0AB2  1292 	INCF  k_2,1
           1293 			;		}
           1294 			;#ifdef X86
           1295 			;		mask = mask << 1;
           1296 			;		if(0 == mask)
           1297 			;#else
           1298 			;		RLF(mask,1);
025E 0020  1299 m036	MOVLB 0
025F 0DB3  1300 	RLF   mask,1
           1301 			;		if(Carry == 1) 
0260 1C03  1302 	BTFSS 0x03,Carry
0261 2A65  1303 	GOTO  m037
           1304 			;#endif
           1305 			;		{
           1306 			;			address++;
0262 0AAE  1307 	INCF  address,1
           1308 			;			mask= 0b00000001;
0263 3001  1309 	MOVLW 1
0264 00B3  1310 	MOVWF mask
           1311 			;		}
           1312 			;	}
0265 0020  1313 m037	MOVLB 0
0266 0AB2  1314 	INCF  k_2,1
0267 2A31  1315 	GOTO  m034
           1316 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
0268 3041  1317 m038	MOVLW 65
0269 0020  1318 	MOVLB 0
026A 00B4  1319 	MOVWF array_4
026B 3020  1320 	MOVLW 32
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 23

ADDR CODE  LINE SOURCE

026C 00B5  1321 	MOVWF array_4+1
026D 2AF9  1322 	GOTO  spi_send_ledbuf
           1323 			;}
           1324 			;#else
           1325 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           1326 			;{	
           1327 			;	char *address = pCmd->addr;
           1328 			;	char r = pCmd->red;
           1329 			;	char g = pCmd->green;
           1330 			;	char b = pCmd->blue;
           1331 			;	
           1332 			;	char k,mask;
           1333 			;	mask = 0b00000001;
           1334 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
           1335 			;	{	
           1336 			;		if(0 != (*address & mask))
           1337 			;		{
           1338 			;			gLedBuf.led_array[k] = b;
           1339 			;			k++;
           1340 			;			gLedBuf.led_array[k] = g;
           1341 			;			k++;
           1342 			;			gLedBuf.led_array[k] = r;
           1343 			;		}
           1344 			;		else 
           1345 			;		{
           1346 			;			k++;
           1347 			;			k++;
           1348 			;		}
           1349 			;#ifdef X86
           1350 			;		mask = mask << 1;
           1351 			;		if(0 == mask)
           1352 			;#else
           1353 			;		RLF(mask,1);
           1354 			;		if(Carry == 1) 
           1355 			;#endif
           1356 			;		{
           1357 			;			address++;
           1358 			;			mask= 0b00000001;
           1359 			;		}
           1360 			;	}
           1361 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
           1362 			;}
           1363 			;#endif
           1364 			;/** This function extracts the parameters for the set_color command
           1365 			;*** from the EEPROM in relation to the CmdWidth and give the values 
           1366 			;*** to the next function with controls the led's
           1367 			;
           1368 			;*** BYTES according to Pointer: x=Commandpointer w=Commandwith
           1369 			;							   x-w     x-w+1   x-w+2   x-w+3  x-w+4     x-w+5         x-w+6        x-w+7                            
                                     x
           1370 			;*** Example: EEPROM DATA: <SET_COLOR> <ADDR0> <ADDR1> <ADDR2> <ADDR3> <RED_VALUE> <GREEN_VALUE> <BLUE_VALUE> <not important> <not important> <SET_COLOR(nextCom
                   mand)>
           1371 			;*/ 
           1372 			;#ifndef USE_UNION
           1373 			;void sub_func_set_color(char *cmdPointer)
           1374 			;{
           1375 sub_func_set_color
           1376 			;	char r,g,b,i, temp,temp1,address[4];
           1377 			;	
           1378 			;	r = EEPROM_RD(*cmdPointer - CmdWidth + 5);
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 24

ADDR CODE  LINE SOURCE

026E 0185  1379 	CLRF  FSR0H
026F 0020  1380 	MOVLB 0
0270 0823  1381 	MOVF  cmdPointer,W
0271 0084  1382 	MOVWF FSR0L
0272 3005  1383 	MOVLW 5
0273 0200  1384 	SUBWF INDF0,W
0274 21DE  1385 	CALL  EEPROM_RD
0275 0020  1386 	MOVLB 0
0276 00A4  1387 	MOVWF r_2
           1388 			;	g = EEPROM_RD(*cmdPointer - CmdWidth + 6);
0277 0185  1389 	CLRF  FSR0H
0278 0823  1390 	MOVF  cmdPointer,W
0279 0084  1391 	MOVWF FSR0L
027A 3004  1392 	MOVLW 4
027B 0200  1393 	SUBWF INDF0,W
027C 21DE  1394 	CALL  EEPROM_RD
027D 0020  1395 	MOVLB 0
027E 00A5  1396 	MOVWF g_2
           1397 			;	b = EEPROM_RD(*cmdPointer - CmdWidth + 7);
027F 0185  1398 	CLRF  FSR0H
0280 0823  1399 	MOVF  cmdPointer,W
0281 0084  1400 	MOVWF FSR0L
0282 3003  1401 	MOVLW 3
0283 0200  1402 	SUBWF INDF0,W
0284 21DE  1403 	CALL  EEPROM_RD
0285 0020  1404 	MOVLB 0
0286 00A6  1405 	MOVWF b_2
           1406 			;	for(i=0;i<4;i++)
0287 01A7  1407 	CLRF  i_5
0288 3004  1408 m039	MOVLW 4
0289 0020  1409 	MOVLB 0
028A 0227  1410 	SUBWF i_5,W
028B 1803  1411 	BTFSC 0x03,Carry
028C 2AA2  1412 	GOTO  m040
           1413 			;	{
           1414 			;		temp1 = *cmdPointer;
028D 0185  1415 	CLRF  FSR0H
028E 0823  1416 	MOVF  cmdPointer,W
028F 0084  1417 	MOVWF FSR0L
0290 0800  1418 	MOVF  INDF0,W
0291 00A9  1419 	MOVWF temp1
           1420 			;		temp1 = temp1 - CmdWidth + 1 + i;
0292 3009  1421 	MOVLW 9
0293 0229  1422 	SUBWF temp1,W
0294 0727  1423 	ADDWF i_5,W
0295 00A9  1424 	MOVWF temp1
           1425 			;		temp = EEPROM_RD(temp1);
0296 0829  1426 	MOVF  temp1,W
0297 21DE  1427 	CALL  EEPROM_RD
0298 0020  1428 	MOVLB 0
0299 00A8  1429 	MOVWF temp_4
           1430 			;		address[i] = temp;
029A 302A  1431 	MOVLW 42
029B 0727  1432 	ADDWF i_5,W
029C 0084  1433 	MOVWF FSR0L
029D 0185  1434 	CLRF  FSR0H
029E 0828  1435 	MOVF  temp_4,W
029F 0080  1436 	MOVWF INDF0
           1437 			;	}
02A0 0AA7  1438 	INCF  i_5,1
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 25

ADDR CODE  LINE SOURCE

02A1 2A88  1439 	GOTO  m039
           1440 			;	
           1441 			;#ifdef TEST
           1442 			;	USARTsend_str("Command:");
           1443 			;	USARTsend_num(address[0],'#');
           1444 			;	USARTsend_num(address[1],'#');
           1445 			;	USARTsend_num(address[2],'#');
           1446 			;	USARTsend_num(address[3],'#');
           1447 			;	USARTsend_num(r,'R');
           1448 			;	USARTsend_num(g,'G');
           1449 			;	USARTsend_num(b,'B');
           1450 			;#endif	
           1451 			;	ledstrip_set_color(&address[0],r,g,b);
02A2 302A  1452 m040	MOVLW 42
02A3 0020  1453 	MOVLB 0
02A4 00AE  1454 	MOVWF address
02A5 0824  1455 	MOVF  r_2,W
02A6 00AF  1456 	MOVWF r
02A7 0825  1457 	MOVF  g_2,W
02A8 00B0  1458 	MOVWF g
02A9 0826  1459 	MOVF  b_2,W
02AA 2A2C  1460 	GOTO  ledstrip_set_color
           1461 			;}
           1462 
           1463   ; FILE RingBuf.c
           1464 			;
           1465 			;#include "RingBuf.h"
           1466 			;
           1467 			;#ifndef X86
           1468 			;#message Global variables are defined in RingBuf.c
           1469 			;#endif /* #ifndef X86 */
           1470 			;struct RingBuffer gRingBuf;
           1471 			;
           1472 			;void RingBufInit(void)
           1473 			;{
           1474 RingBufInit
           1475 			;	gRingBuf.read = 0;
02AB 0020  1476 	MOVLB 0
02AC 01C9  1477 	CLRF  gRingBuf+16
           1478 			;	gRingBuf.write = 0;
02AD 01CA  1479 	CLRF  gRingBuf+17
           1480 			;	gRingBuf.error_full = 0;
02AE 104B  1481 	BCF   gRingBuf+18,0
           1482 			;}
02AF 0008  1483 	RETURN
           1484 			;
           1485 			;char RingBufGet(void)
           1486 			;{
           1487 RingBufGet
           1488 			;	char result = gRingBuf.data[gRingBuf.read];
02B0 3039  1489 	MOVLW 57
02B1 0020  1490 	MOVLB 0
02B2 0749  1491 	ADDWF gRingBuf+16,W
02B3 0084  1492 	MOVWF FSR0L
02B4 0185  1493 	CLRF  FSR0H
02B5 0800  1494 	MOVF  INDF0,W
02B6 00A5  1495 	MOVWF result
           1496 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
02B7 0A49  1497 	INCF  gRingBuf+16,W
02B8 390F  1498 	ANDLW 15
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 26

ADDR CODE  LINE SOURCE

02B9 00C9  1499 	MOVWF gRingBuf+16
           1500 			;	return result;
02BA 0825  1501 	MOVF  result,W
02BB 0008  1502 	RETURN
           1503 			;}
           1504 			;
           1505 			;void RingBufPut(char value)
           1506 			;{
           1507 RingBufPut
02BC 0020  1508 	MOVLB 0
02BD 00A0  1509 	MOVWF value
           1510 			;	char writeNext = RingBufInc(gRingBuf.write);
02BE 0A4A  1511 	INCF  gRingBuf+17,W
02BF 390F  1512 	ANDLW 15
02C0 00A1  1513 	MOVWF writeNext
           1514 			;	if(writeNext != gRingBuf.read)
02C1 0821  1515 	MOVF  writeNext,W
02C2 0649  1516 	XORWF gRingBuf+16,W
02C3 1903  1517 	BTFSC 0x03,Zero_
02C4 2ACE  1518 	GOTO  m041
           1519 			;	{
           1520 			;		gRingBuf.data[gRingBuf.write] = value;
02C5 3039  1521 	MOVLW 57
02C6 074A  1522 	ADDWF gRingBuf+17,W
02C7 0084  1523 	MOVWF FSR0L
02C8 0185  1524 	CLRF  FSR0H
02C9 0820  1525 	MOVF  value,W
02CA 0080  1526 	MOVWF INDF0
           1527 			;		gRingBuf.write = writeNext;
02CB 0821  1528 	MOVF  writeNext,W
02CC 00CA  1529 	MOVWF gRingBuf+17
           1530 			;	}
           1531 			;	else gRingBuf.error_full = 1;
02CD 2AD0  1532 	GOTO  m042
02CE 0020  1533 m041	MOVLB 0
02CF 144B  1534 	BSF   gRingBuf+18,0
           1535 			;}
02D0 0008  1536 m042	RETURN
           1537 
           1538   ; FILE spi.c
           1539 			;//Nils Weiﬂ 
           1540 			;//20.04.2012
           1541 			;//Compiler CC5x
           1542 			;
           1543 			;#include "ledstrip.h"
           1544 			;
           1545 			;#ifndef X86
           1546 			;void spi_init()
           1547 			;{
           1548 spi_init
           1549 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
02D1 0021  1550 	MOVLB 1
02D2 118E  1551 	BCF   TRISC,3
           1552 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
02D3 160E  1553 	BSF   TRISC,4
           1554 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
02D4 128E  1555 	BCF   TRISC,5
           1556 			;	SSPM1 = 0;
02D5 0024  1557 	MOVLB 4
02D6 1095  1558 	BCF   0x215,SSPM1
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 27

ADDR CODE  LINE SOURCE

           1559 			;	SMP = 0;
02D7 1394  1560 	BCF   0x214,SMP
           1561 			;	CKP = 1;
02D8 1615  1562 	BSF   0x215,CKP
           1563 			;	CKE = 0;
02D9 1314  1564 	BCF   0x214,CKE
           1565 			;	SSPEN = 1;
02DA 1695  1566 	BSF   0x215,SSPEN
           1567 			;}
02DB 0008  1568 	RETURN
           1569 			;
           1570 			;char spi_send(char data)
           1571 			;{
           1572 spi_send
02DC 0020  1573 	MOVLB 0
02DD 00B8  1574 	MOVWF data_4
           1575 			;	SSPBUF = data;	
02DE 0838  1576 	MOVF  data_4,W
02DF 0024  1577 	MOVLB 4
02E0 0091  1578 	MOVWF SSPBUF
           1579 			;	while(SSPIF == 0);
02E1 0020  1580 m043	MOVLB 0
02E2 1D91  1581 	BTFSS 0x11,SSPIF
02E3 2AE1  1582 	GOTO  m043
           1583 			;	return SSPBUF;
02E4 0024  1584 	MOVLB 4
02E5 0811  1585 	MOVF  SSPBUF,W
02E6 0008  1586 	RETURN
           1587 			;}
           1588 			;#endif /* #ifndef X86 */
           1589 			;
           1590 			;/***
           1591 			;**	This function sends the array to the LED controller(WS2801)
           1592 			;**  it starts with the last byte to get a correct output
           1593 			;***/
           1594 			;void spi_send_arr(char *array, char length)
           1595 			;{
           1596 spi_send_arr
02E7 00FF  1597 	MOVWF length_4
           1598 			;	if(array == 0) return;
02E8 08FF  1599 	MOVF  array_3,1
02E9 1903  1600 	BTFSC 0x03,Zero_
02EA 0008  1601 	RETURN
           1602 			;	char i;
           1603 			;	for(i = length; i == 0; i-- )
02EB 087F  1604 	MOVF  length_4,W
02EC 00FF  1605 	MOVWF i_6
02ED 08FF  1606 m044	MOVF  i_6,1
02EE 1D03  1607 	BTFSS 0x03,Zero_
02EF 2AF8  1608 	GOTO  m045
           1609 			;	{
           1610 			;		spi_send(array[i]);
02F0 087F  1611 	MOVF  i_6,W
02F1 077F  1612 	ADDWF array_3,W
02F2 0084  1613 	MOVWF FSR0L
02F3 0185  1614 	CLRF  FSR0H
02F4 0800  1615 	MOVF  INDF0,W
02F5 22DC  1616 	CALL  spi_send
           1617 			;	} 
02F6 03FF  1618 	DECF  i_6,1
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 28

ADDR CODE  LINE SOURCE

02F7 2AED  1619 	GOTO  m044
           1620 			;}
02F8 0008  1621 m045	RETURN
           1622 			;
           1623 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1624 			;{
           1625 spi_send_ledbuf
           1626 			;	//array must be the address of the first byte
           1627 			;	char* end;
           1628 			;	//calculate where the end is
           1629 			;	end = array + (NUM_OF_LED * 3);
02F9 0020  1630 	MOVLB 0
02FA 0835  1631 	MOVF  array_4+1,W
02FB 00B7  1632 	MOVWF end+1
02FC 3060  1633 	MOVLW 96
02FD 0734  1634 	ADDWF array_4,W
02FE 00B6  1635 	MOVWF end
02FF 1803  1636 	BTFSC 0x03,Carry
0300 0AB7  1637 	INCF  end+1,1
           1638 			;	//send all
           1639 			;	for(; array < end; array++)
0301 0020  1640 m046	MOVLB 0
0302 0837  1641 	MOVF  end+1,W
0303 0235  1642 	SUBWF array_4+1,W
0304 1C03  1643 	BTFSS 0x03,Carry
0305 2B0C  1644 	GOTO  m047
0306 1D03  1645 	BTFSS 0x03,Zero_
0307 2B18  1646 	GOTO  m048
0308 0836  1647 	MOVF  end,W
0309 0234  1648 	SUBWF array_4,W
030A 1803  1649 	BTFSC 0x03,Carry
030B 2B18  1650 	GOTO  m048
           1651 			;	{
           1652 			;		spi_send(*array);
030C 0020  1653 m047	MOVLB 0
030D 0835  1654 	MOVF  array_4+1,W
030E 0085  1655 	MOVWF FSR0H
030F 0834  1656 	MOVF  array_4,W
0310 0084  1657 	MOVWF FSR0L
0311 0800  1658 	MOVF  INDF0,W
0312 22DC  1659 	CALL  spi_send
           1660 			;	}
0313 0020  1661 	MOVLB 0
0314 0AB4  1662 	INCF  array_4,1
0315 1903  1663 	BTFSC 0x03,Zero_
0316 0AB5  1664 	INCF  array_4+1,1
0317 2B01  1665 	GOTO  m046
           1666 			;}
0318 0008  1667 m048	RETURN
           1668 
           1669   ; FILE usart.c
           1670 			;// Include-Datei f¸r Serielle Kommunikation ¸ber Hardwaremodul des Pic
           1671 			; //
           1672 			; //
           1673 			; // Nils Weiﬂ
           1674 			; // 29.11.2010
           1675 			; // Compiler CC5x
           1676 			;
           1677 			;#ifndef X86
           1678 			;//*******  Initialisierungs-Funktion  *************************************************
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 29

ADDR CODE  LINE SOURCE

           1679 			;void USARTinit()
           1680 			;{
           1681 USARTinit
           1682 			;	//USART TX Pin als Ausgang
           1683 			;	TRISC.6 = 0;
0319 0021  1684 	MOVLB 1
031A 130E  1685 	BCF   TRISC,6
           1686 			;
           1687 			;    BRGH=1;					// High Baudrate activated
031B 0023  1688 	MOVLB 3
031C 151E  1689 	BSF   0x19E,BRGH
           1690 			;	BRG16=0;
031D 119F  1691 	BCF   0x19F,BRG16
           1692 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
031E 3019  1693 	MOVLW 25
031F 009B  1694 	MOVWF SPBRGL
           1695 			;	SPBRGH=0;
0320 019C  1696 	CLRF  SPBRGH
           1697 			;    SPEN = 1;               // Set_Serial_Pins;
0321 179D  1698 	BSF   0x19D,SPEN
           1699 			;    SYNC = 0;               // Set_Async_Mode;
0322 121E  1700 	BCF   0x19E,SYNC
           1701 			;    TX9 = 0;                // Set_8bit_Tx;
0323 131E  1702 	BCF   0x19E,TX9
           1703 			;    RX9 = 0;                // Set_8bit_Rx;
0324 131D  1704 	BCF   0x19D,RX9
           1705 			;    CREN = 1;               // Enable_Rx;
0325 161D  1706 	BSF   0x19D,CREN
           1707 			;    TXEN = 1;               // Enable_Tx;
0326 169E  1708 	BSF   0x19E,TXEN
           1709 			;    RCIE=1;                 // Rx Interrupt aus
0327 0021  1710 	MOVLB 1
0328 1691  1711 	BSF   0x91,RCIE
           1712 			;	ADDEN=0;				// Disable Adressdetection
0329 0023  1713 	MOVLB 3
032A 119D  1714 	BCF   0x19D,ADDEN
           1715 			;}
032B 0008  1716 	RETURN
           1717 			;
           1718 			;//*******  Sende-char-Funktion  *************************************************
           1719 			;void USARTsend(unsigned char ch)
           1720 			;{
           1721 USARTsend
032C 0020  1722 	MOVLB 0
032D 00A6  1723 	MOVWF ch
           1724 			;	while(!TXIF);
032E 0020  1725 m049	MOVLB 0
032F 1E11  1726 	BTFSS 0x11,TXIF
0330 2B2E  1727 	GOTO  m049
           1728 			;	TXREG=ch;
0331 0020  1729 	MOVLB 0
0332 0826  1730 	MOVF  ch,W
0333 0023  1731 	MOVLB 3
0334 009A  1732 	MOVWF TXREG
           1733 			;}
0335 0008  1734 	RETURN
           1735 			;#endif /* #ifndef X86 */
           1736 			;
           1737 			;//*******  Sende-String-Funktion  *************************************************
           1738 			;void USARTsend_str(const char *string)
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 30

ADDR CODE  LINE SOURCE

           1739 			;{
           1740 USARTsend_str
           1741 			; char ps;
           1742 			; ps = *string;
0336 0020  1743 	MOVLB 0
0337 0822  1744 	MOVF  string,W
0338 2012  1745 	CALL  _const1
0339 0020  1746 	MOVLB 0
033A 00A3  1747 	MOVWF ps
           1748 			; while(ps > 0)
033B 0020  1749 m050	MOVLB 0
033C 08A3  1750 	MOVF  ps,1
033D 1903  1751 	BTFSC 0x03,Zero_
033E 2B48  1752 	GOTO  m051
           1753 			;   {
           1754 			;    string++;
033F 0AA2  1755 	INCF  string,1
           1756 			;   	USARTsend(ps);
0340 0823  1757 	MOVF  ps,W
0341 232C  1758 	CALL  USARTsend
           1759 			;    ps = *string;
0342 0020  1760 	MOVLB 0
0343 0822  1761 	MOVF  string,W
0344 2012  1762 	CALL  _const1
0345 0020  1763 	MOVLB 0
0346 00A3  1764 	MOVWF ps
           1765 			;   }
0347 2B3B  1766 	GOTO  m050
           1767 			;}
0348 0008  1768 m051	RETURN
           1769 			;
           1770 			;//*******  Sende-Array-Funktion  *************************************************
           1771 			;void USARTsend_arr(char *array, char length)
           1772 			;{
           1773 USARTsend_arr
0349 00FF  1774 	MOVWF length_5
           1775 			;	if(array == 0) return;
034A 08FF  1776 	MOVF  array_5,1
034B 1903  1777 	BTFSC 0x03,Zero_
034C 0008  1778 	RETURN
           1779 			;	char i;
           1780 			;	for(i=0;i<length;i++)
034D 01FF  1781 	CLRF  i_7
034E 087F  1782 m052	MOVF  length_5,W
034F 027F  1783 	SUBWF i_7,W
0350 1803  1784 	BTFSC 0x03,Carry
0351 2B5A  1785 	GOTO  m053
           1786 			;	{
           1787 			;		USARTsend(*array);
0352 0185  1788 	CLRF  FSR0H
0353 087F  1789 	MOVF  array_5,W
0354 0084  1790 	MOVWF FSR0L
0355 0800  1791 	MOVF  INDF0,W
0356 232C  1792 	CALL  USARTsend
           1793 			;		array++;
0357 0AFF  1794 	INCF  array_5,1
           1795 			;	}
0358 0AFF  1796 	INCF  i_7,1
0359 2B4E  1797 	GOTO  m052
           1798 			;}
CC5X Version 3.4E,   File: main.c              13. May 2012  14:11   Page 31

ADDR CODE  LINE SOURCE

035A 0008  1799 m053	RETURN
           1800 
           1801 	END
           1802 
           1803 
           1804 ; *** KEY INFO ***
           1805 
           1806 ; 0x02AB P0    5 word(s)  0 % : RingBufInit
           1807 ; 0x02B0 P0   12 word(s)  0 % : RingBufGet
           1808 ; 0x02BC P0   21 word(s)  1 % : RingBufPut
           1809 ; 0x0319 P0   19 word(s)  0 % : USARTinit
           1810 ; 0x032C P0   10 word(s)  0 % : USARTsend
           1811 ; 0x0336 P0   19 word(s)  0 % : USARTsend_str
           1812 ; 0x0349 P0   18 word(s)  0 % : USARTsend_arr
           1813 ; 0x01BC P0   34 word(s)  1 % : EEPROM_WR
           1814 ; 0x01DE P0   13 word(s)  0 % : EEPROM_RD
           1815 ; 0x01EB P0   25 word(s)  1 % : EEPROM_WR_BLK
           1816 ; 0x0204 P0   22 word(s)  1 % : EEPROM_RD_BLK
           1817 ; 0x0153 P0   40 word(s)  1 % : addCRC
           1818 ; 0x017B P0   45 word(s)  2 % : CRC
           1819 ; 0x01A8 P0   20 word(s)  0 % : newCRC
           1820 ; 0x02D1 P0   11 word(s)  0 % : spi_init
           1821 ; 0x02DC P0   11 word(s)  0 % : spi_send
           1822 ; 0x02E7 P0   18 word(s)  0 % : spi_send_arr
           1823 ; 0x02F9 P0   32 word(s)  1 % : spi_send_ledbuf
           1824 ; 0x021A P0   18 word(s)  0 % : ledstrip_init
           1825 ; 0x022C P0   66 word(s)  3 % : ledstrip_set_color
           1826 ; 0x026E P0   61 word(s)  2 % : sub_func_set_color
           1827 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           1828 ; 0x005A P0   54 word(s)  2 % : init_all
           1829 ; 0x0090 P0   25 word(s)  1 % : throw_errors
           1830 ; 0x00A9 P0  139 word(s)  6 % : get_commands
           1831 ; 0x0134 P0   31 word(s)  1 % : execute_commands
           1832 ; 0x0055 P0    5 word(s)  0 % : main
           1833 ; 0x0012 P0   67 word(s)  3 % : _const1
           1834 
           1835 ; RAM usage: 161 bytes (25 local), 351 bytes free
           1836 ; Maximum call level: 3 (+2 for interrupt)
           1837 ;  Codepage 0 has  856 word(s) :  41 %
           1838 ;  Codepage 1 has    0 word(s) :   0 %
           1839 ;  Codepage 2 has    0 word(s) :   0 %
           1840 ;  Codepage 3 has    0 word(s) :   0 %
           1841 ; Total of 856 code words (10 %)
