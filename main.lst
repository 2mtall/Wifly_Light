CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  14. May 2012  11:53  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0006  0048 CKE         EQU   6
     0007  0049 SMP         EQU   7
     0001  0050 SSPM1       EQU   1
     0004  0051 CKP         EQU   4
     0005  0052 SSPEN       EQU   5
     0039  0053 gRingBuf    EQU   0x39
     004C  0054 gCmdBuf     EQU   0x4C
     005F  0055 gERROR      EQU   0x5F
     0020  0056 temp        EQU   0x20
     0025  0057 byte        EQU   0x25
     0026  0058 p_crcH      EQU   0x26
     0027  0059 p_crcL      EQU   0x27
     0028  0060 index       EQU   0x28
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 2

ADDR CODE  LINE SOURCE

     0029  0061 crcH        EQU   0x29
     002A  0062 crcL        EQU   0x2A
     007F  0063 data        EQU   0x7F
     007F  0064 length      EQU   0x7F
     007F  0065 crcH_out    EQU   0x7F
     007F  0066 crcL_out    EQU   0x7F
     007F  0067 crcH_2      EQU   0x7F
     007F  0068 crcL_2      EQU   0x7F
     007F  0069 i           EQU   0x7F
     007F  0070 byte_2      EQU   0x7F
     0025  0071 p_crcH_2    EQU   0x25
     0026  0072 p_crcL_2    EQU   0x26
     0030  0073 adress      EQU   0x30
     0031  0074 data_2      EQU   0x31
     0000  0075 GIE_status  EQU   0
     0035  0076 adress_2    EQU   0x35
     0036  0077 data_3      EQU   0x36
     0028  0078 array       EQU   0x28
     0029  0079 adress_3    EQU   0x29
     002A  0080 length_2    EQU   0x2A
     002B  0081 i_2         EQU   0x2B
     0030  0082 array_2     EQU   0x30
     0031  0083 adress_4    EQU   0x31
     0032  0084 length_3    EQU   0x32
     0033  0085 i_3         EQU   0x33
     0034  0086 temp_2      EQU   0x34
     0022  0087 k           EQU   0x22
     002D  0088 pCmd        EQU   0x2D
     002E  0089 address     EQU   0x2E
     002F  0090 r           EQU   0x2F
     0030  0091 g           EQU   0x30
     0031  0092 b           EQU   0x31
     0032  0093 k_2         EQU   0x32
     0033  0094 mask        EQU   0x33
     0025  0095 result      EQU   0x25
     0020  0096 value       EQU   0x20
     0021  0097 writeNext   EQU   0x21
     0038  0098 data_4      EQU   0x38
     007F  0099 array_3     EQU   0x7F
     007F  0100 length_4    EQU   0x7F
     007F  0101 i_4         EQU   0x7F
     0034  0102 array_4     EQU   0x34
     0036  0103 end         EQU   0x36
     0025  0104 ch          EQU   0x25
     0022  0105 string      EQU   0x22
     0023  0106 ps          EQU   0x23
     007F  0107 array_5     EQU   0x7F
     007F  0108 length_5    EQU   0x7F
     007F  0109 i_5         EQU   0x7F
     002D  0110 pDest       EQU   0x2D
     0000  0111 movePtr     EQU   0
     002E  0112 nextCmd     EQU   0x2E
     0025  0113 pSrc        EQU   0x25
     0026  0114 length_6    EQU   0x26
     0027  0115 nextCmd_2   EQU   0x27
     0022  0116 new_byte    EQU   0x22
     0023  0117 temp_3      EQU   0x23
     0024  0118 j           EQU   0x24
     0022  0119 nextCmd_3   EQU   0x22
     002C  0120 result_2    EQU   0x2C
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 3

ADDR CODE  LINE SOURCE

     0024  0121 ci          EQU   0x24
           0122 
0000 2855  0123 	GOTO main
           0124 
           0125   ; FILE main.c
           0126 			;//Nils Weiﬂ 
           0127 			;//05.09.2011
           0128 			;//Compiler CC5x/
           0129 			;
           0130 			;#define NO_CRC
           0131 			;#define MPLAB_IDE
           0132 			;
           0133 			;#include "platform.h"
           0134 			;#pragma sharedAllocation
           0135 			;
           0136 			;//*********************** ENUMERATIONS *********************************************
           0137 			;#define TRUE  1
           0138 			;#define FALSE 0
           0139 			;
           0140 			;//*********************** INCLUDEDATEIEN *********************************************
           0141 			;#include "RingBuf.h"		//clean
           0142 			;#include "usart.h"			//clean
           0143 			;#include "eeprom.h"       	//clean 
           0144 			;#include "crc.h"			//clean
           0145 			;#include "commandstorage.h"
           0146 			;#include "ledstrip.h"		//clean
           0147 			;#include "spi.h"			//clean
           0148 			;#include "timer.h"
           0149 			;
           0150 			;//*********************** GLOBAL VARIABLES *******************************************
           0151 			;static struct CommandBuffer gCmdBuf;
           0152 			;static struct LedBuffer gLedBuf;
           0153 			;// *** ERRORBITS
           0154 			;static struct {
           0155 			;		char crc_failure:1;
           0156 			;		char eeprom_failure:1;
           0157 			;}gERROR;
           0158 			;
           0159 			;#ifndef X86
           0160 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           0161 			;#pragma origin 4					//Adresse des Interrupts	
     0000  0162 	ORG 0x0004
           0163 			;interrupt InterruptRoutine(void)
           0164 			;{
           0165 InterruptRoutine
           0166 			;	if (RCIF)
0004 0020  0167 	MOVLB 0
0005 1E91  0168 	BTFSS 0x11,RCIF
0006 2811  0169 	GOTO  m002
           0170 			;	{
           0171 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 184B  0172 	BTFSC gRingBuf+18,0
0008 280D  0173 	GOTO  m001
0009 0023  0174 	MOVLB 3
000A 0819  0175 	MOVF  RCREG,W
000B 21DD  0176 	CALL  RingBufPut
           0177 			;		else 
000C 2811  0178 	GOTO  m002
           0179 			;		{
           0180 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 4

ADDR CODE  LINE SOURCE

           0181 			;			char temp = RCREG;
000D 0023  0182 m001	MOVLB 3
000E 0819  0183 	MOVF  RCREG,W
000F 0020  0184 	MOVLB 0
0010 00A0  0185 	MOVWF temp
           0186 			;		}
           0187 			;	}
           0188 			;}
0011 0009  0189 m002	RETFIE
           0190 			;#endif /* #ifndef X86 */
           0191 			;
           0192 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           0193 			;void init_all();
           0194 			;void throw_errors();
           0195 			;void execute_commands();
           0196 			;
           0197 			;//*********************** HAUPTPROGRAMM **********************************************
           0198 			;void main(void)
           0199 			;{
           0200 _const1
0012 0020  0201 	MOVLB 0
0013 00A4  0202 	MOVWF ci
0014 3000  0203 	MOVLW 0
0015 0023  0204 	MOVLB 3
0016 0092  0205 	MOVWF EEADRH
0017 0020  0206 	MOVLB 0
0018 0C24  0207 	RRF   ci,W
0019 397F  0208 	ANDLW 127
001A 3E2F  0209 	ADDLW 47
001B 0023  0210 	MOVLB 3
001C 0091  0211 	MOVWF EEADRL
001D 1803  0212 	BTFSC 0x03,Carry
001E 0A92  0213 	INCF  EEADRH,1
001F 0023  0214 	MOVLB 3
0020 1795  0215 	BSF   0x195,EEPGD
0021 1415  0216 	BSF   0x195,RD
0022 0000  0217 	NOP  
0023 0000  0218 	NOP  
0024 0020  0219 	MOVLB 0
0025 1824  0220 	BTFSC ci,0
0026 282B  0221 	GOTO  m003
0027 0023  0222 	MOVLB 3
0028 0813  0223 	MOVF  EEDATL,W
0029 397F  0224 	ANDLW 127
002A 0008  0225 	RETURN
002B 0023  0226 m003	MOVLB 3
002C 0D13  0227 	RLF   EEDATL,W
002D 0D14  0228 	RLF   EEDATH,W
002E 0008  0229 	RETURN
002F 22A0  0230 	DW    0x22A0
0030 2952  0231 	DW    0x2952
0031 294F  0232 	DW    0x294F
0032 103A  0233 	DW    0x103A
0033 32D2  0234 	DW    0x32D2
0034 32E3  0235 	DW    0x32E3
0035 3B69  0236 	DW    0x3B69
0036 3165  0237 	DW    0x3165
0037 3375  0238 	DW    0x3375
0038 32E6  0239 	DW    0x32E6
0039 1072  0240 	DW    0x1072
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 5

ADDR CODE  LINE SOURCE

003A 3AE6  0241 	DW    0x3AE6
003B 366C  0242 	DW    0x366C
003C 1000  0243 	DW    0x1000
003D 2945  0244 	DW    0x2945
003E 27D2  0245 	DW    0x27D2
003F 1D52  0246 	DW    0x1D52
0040 21A0  0247 	DW    0x21A0
0041 21D2  0248 	DW    0x21D2
0042 21AD  0249 	DW    0x21AD
0043 32E8  0250 	DW    0x32E8
0044 35E3  0251 	DW    0x35E3
0045 3320  0252 	DW    0x3320
0046 34E1  0253 	DW    0x34E1
0047 32EC  0254 	DW    0x32EC
0048 0064  0255 	DW    0x64
0049 22A0  0256 	DW    0x22A0
004A 2952  0257 	DW    0x2952
004B 294F  0258 	DW    0x294F
004C 103A  0259 	DW    0x103A
004D 22C5  0260 	DW    0x22C5
004E 2950  0261 	DW    0x2950
004F 26CF  0262 	DW    0x26CF
0050 34A0  0263 	DW    0x34A0
0051 1073  0264 	DW    0x1073
0052 3AE6  0265 	DW    0x3AE6
0053 366C  0266 	DW    0x366C
0054 0000  0267 	DW    0x0
           0268 main
           0269 			;	init_all();
0055 205A  0270 	CALL  init_all
           0271 			;    while(1)
           0272 			;    {	
           0273 			;        throw_errors();
0056 2081  0274 m004	CALL  throw_errors
           0275 			;		commandstorage_get_commands();
0057 22BA  0276 	CALL  commandstorage_get_commands
           0277 			;		commandstorage_execute_commands();
0058 2337  0278 	CALL  commandstorage_execute_commands
           0279 			;    }
0059 2856  0280 	GOTO  m004
           0281 			;}
           0282 			;//*********************** UNTERPROGRAMME **********************************************
           0283 			;
           0284 			;void init_all()
           0285 			;{
           0286 init_all
           0287 			;#ifndef X86
           0288 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           0289 			;	OSCCON = 0b01110010;
005A 3072  0290 	MOVLW 114
005B 0021  0291 	MOVLB 1
005C 0099  0292 	MOVWF OSCCON
           0293 			;#endif /* #ifndef X86 */
           0294 			;	RingBufInit();
005D 21CC  0295 	CALL  RingBufInit
           0296 			;	//initialise UART interface
           0297 			;	USARTinit();
005E 223A  0298 	CALL  USARTinit
           0299 			;	spi_init();
005F 21F2  0300 	CALL  spi_init
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 6

ADDR CODE  LINE SOURCE

           0301 			;	ledstrip_init();
0060 2165  0302 	CALL  ledstrip_init
           0303 			;
           0304 			;/** EEPROM contains FF in every cell after inital start,
           0305 			;*** so I have to delet the pointer address
           0306 			;*** otherwise the PIC thinks he has the EEPROM full with commands
           0307 			;**/
           0308 			;	if (EEPROM_RD(CmdPointerAddr) == 0xff)
0061 30FF  0309 	MOVLW 255
0062 2125  0310 	CALL  EEPROM_RD
0063 3AFF  0311 	XORLW 255
0064 1D03  0312 	BTFSS 0x03,Zero_
0065 286B  0313 	GOTO  m005
           0314 			;	EEPROM_WR(CmdPointerAddr, 0);
0066 30FF  0315 	MOVLW 255
0067 0020  0316 	MOVLB 0
0068 00B0  0317 	MOVWF adress
0069 3000  0318 	MOVLW 0
006A 2103  0319 	CALL  EEPROM_WR
           0320 			;	EEPROM_WR(CmdLoopPointerAddr, 0);
006B 30FD  0321 m005	MOVLW 253
006C 0020  0322 	MOVLB 0
006D 00B0  0323 	MOVWF adress
006E 3000  0324 	MOVLW 0
006F 2103  0325 	CALL  EEPROM_WR
           0326 			;	
           0327 			;#ifndef X86
           0328 			;	//Ausgang f¸r FET initalisieren
           0329 			;	TRISC.0 = 0;
0070 0021  0330 	MOVLB 1
0071 100E  0331 	BCF   TRISC,0
           0332 			;	//Spannungsversorgung f¸r LED's einschalten
           0333 			;	PORTC.0 = 0;
0072 0020  0334 	MOVLB 0
0073 100E  0335 	BCF   PORTC,0
           0336 			;
           0337 			;	//To Factory Restore WLAN Modul
           0338 			;	//TRISA.0 = 0;
           0339 			;	//PORTA.0 = 1;
           0340 			;#endif /* #ifndef X86 */
           0341 			;    
           0342 			;    // *** load globals variables
           0343 			;    gERROR = 0;
0074 01DF  0344 	CLRF  gERROR
           0345 			;	ClearCmdBuf;
0075 01CC  0346 	CLRF  gCmdBuf
0076 01CD  0347 	CLRF  gCmdBuf+1
           0348 			;	
           0349 			;#ifndef X86
           0350 			;	// *** allow interrupts
           0351 			;	RCIE=1;
0077 0021  0352 	MOVLB 1
0078 1691  0353 	BSF   0x91,RCIE
           0354 			;	PEIE=1;
0079 170B  0355 	BSF   0x0B,PEIE
           0356 			;	GIE=1;
007A 178B  0357 	BSF   0x0B,GIE
           0358 			;#endif /* #ifndef X86 */
           0359 			;	// *** send ready after init
           0360 			;	USARTsend('R');
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 7

ADDR CODE  LINE SOURCE

007B 3052  0361 	MOVLW 82
007C 224D  0362 	CALL  USARTsend
           0363 			;	USARTsend('D');
007D 3044  0364 	MOVLW 68
007E 224D  0365 	CALL  USARTsend
           0366 			;	USARTsend('Y');
007F 3059  0367 	MOVLW 89
0080 2A4D  0368 	GOTO  USARTsend
           0369 			;}
           0370 			;
           0371 			;void throw_errors()
           0372 			;{
           0373 throw_errors
           0374 			;	if(RingBufHasError) 
0081 0020  0375 	MOVLB 0
0082 1C4B  0376 	BTFSS gRingBuf+18,0
0083 2889  0377 	GOTO  m006
           0378 			;	{
           0379 			;		// *** if a RingBufError occure, I have to throw away the current command,
           0380 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           0381 			;		ClearCmdBuf;
0084 01CC  0382 	CLRF  gCmdBuf
0085 01CD  0383 	CLRF  gCmdBuf+1
           0384 			;		USARTsend_str(" ERROR: Receivebuffer full");
0086 01A2  0385 	CLRF  string
0087 2257  0386 	CALL  USARTsend_str
           0387 			;		// *** Re-init the Ringbuffer to get a consistent commandstring and reset error
           0388 			;		RingBufInit();
0088 21CC  0389 	CALL  RingBufInit
           0390 			;	}
           0391 			;	if(gERROR.crc_failure)
0089 0020  0392 m006	MOVLB 0
008A 1C5F  0393 	BTFSS gERROR,0
008B 2891  0394 	GOTO  m007
           0395 			;	{
           0396 			;		USARTsend_str(" ERROR: CRC-Check failed");
008C 301B  0397 	MOVLW 27
008D 00A2  0398 	MOVWF string
008E 2257  0399 	CALL  USARTsend_str
           0400 			;		gERROR.crc_failure = 0;
008F 0020  0401 	MOVLB 0
0090 105F  0402 	BCF   gERROR,0
           0403 			;	}
           0404 			;	if(gERROR.eeprom_failure)
0091 0020  0405 m007	MOVLB 0
0092 1CDF  0406 	BTFSS gERROR,1
0093 2899  0407 	GOTO  m008
           0408 			;	{
           0409 			;		USARTsend_str(" ERROR: EEPROM is full");
0094 3034  0410 	MOVLW 52
0095 00A2  0411 	MOVWF string
0096 2257  0412 	CALL  USARTsend_str
           0413 			;		gERROR.eeprom_failure = 0;
0097 0020  0414 	MOVLB 0
0098 10DF  0415 	BCF   gERROR,1
           0416 			;	}
           0417 			;}
0099 0008  0418 m008	RETURN
           0419 
           0420   ; FILE crc.c
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 8

ADDR CODE  LINE SOURCE

           0421 			; // Include-Datei zum Erstellen von CRC Pr¸fsummen
           0422 			; //
           0423 			; //
           0424 			; // Nils Weiﬂ
           0425 			; // 14.04.2012
           0426 			; // Compiler CC5x
           0427 			;
           0428 			;// 16-bit CCIT CRC
           0429 			;
           0430 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0431 			;{
           0432 addCRC
           0433 			;	char index;
           0434 			;	char crcH,crcL;
           0435 			;	crcH = *p_crcH;
009A 0185  0436 	CLRF  FSR0H
009B 0020  0437 	MOVLB 0
009C 0826  0438 	MOVF  p_crcH,W
009D 0084  0439 	MOVWF FSR0L
009E 0800  0440 	MOVF  INDF0,W
009F 00A9  0441 	MOVWF crcH
           0442 			;	crcL = *p_crcL;
00A0 0185  0443 	CLRF  FSR0H
00A1 0827  0444 	MOVF  p_crcL,W
00A2 0084  0445 	MOVWF FSR0L
00A3 0800  0446 	MOVF  INDF0,W
00A4 00AA  0447 	MOVWF crcL
           0448 			;
           0449 			;	MOVF(byte,0);
00A5 0825  0450 	MOVF  byte,W
           0451 			;	
           0452 			;	XORWF(crcH,0);
00A6 0629  0453 	XORWF crcH,W
           0454 			;	MOVWF(index);
00A7 00A8  0455 	MOVWF index
           0456 			;	ANDLW(0xf0);
00A8 39F0  0457 	ANDLW 240
           0458 			;	SWAPF(index,1);
00A9 0EA8  0459 	SWAPF index,1
           0460 			;	XORWF(index,1);
00AA 06A8  0461 	XORWF index,1
           0462 			;	
           0463 			;	MOVF(index,0);
00AB 0828  0464 	MOVF  index,W
           0465 			;	ANDLW(0xf0);
00AC 39F0  0466 	ANDLW 240
           0467 			;	XORWF(crcL,0);
00AD 062A  0468 	XORWF crcL,W
           0469 			;	MOVWF(crcH);
00AE 00A9  0470 	MOVWF crcH
           0471 			;	
           0472 			;	RLF(index,0);
00AF 0D28  0473 	RLF   index,W
           0474 			;	RLF(index,0);
00B0 0D28  0475 	RLF   index,W
           0476 			;	XORWF(crcH,1);
00B1 06A9  0477 	XORWF crcH,1
           0478 			;	ANDLW(0xe0);
00B2 39E0  0479 	ANDLW 224
           0480 			;	XORWF(crcH,1);
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 9

ADDR CODE  LINE SOURCE

00B3 06A9  0481 	XORWF crcH,1
           0482 			;		
           0483 			;	SWAPF(index,1);
00B4 0EA8  0484 	SWAPF index,1
           0485 			;	XORWF(index,0);
00B5 0628  0486 	XORWF index,W
           0487 			;	MOVWF(crcL);
00B6 00AA  0488 	MOVWF crcL
           0489 			;
           0490 			;	*p_crcH = crcH;
00B7 0185  0491 	CLRF  FSR0H
00B8 0826  0492 	MOVF  p_crcH,W
00B9 0084  0493 	MOVWF FSR0L
00BA 0829  0494 	MOVF  crcH,W
00BB 0080  0495 	MOVWF INDF0
           0496 			;	*p_crcL = crcL;
00BC 0185  0497 	CLRF  FSR0H
00BD 0827  0498 	MOVF  p_crcL,W
00BE 0084  0499 	MOVWF FSR0L
00BF 082A  0500 	MOVF  crcL,W
00C0 0080  0501 	MOVWF INDF0
           0502 			;
           0503 			;}
00C1 0008  0504 	RETURN
           0505 			;
           0506 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0507 			;{
           0508 CRC
           0509 			;	if(!crcH_out)return;
00C2 08FF  0510 	MOVF  crcH_out,1
00C3 1903  0511 	BTFSC 0x03,Zero_
00C4 0008  0512 	RETURN
           0513 			;	if(!crcL_out)return;
00C5 08FF  0514 	MOVF  crcL_out,1
00C6 1903  0515 	BTFSC 0x03,Zero_
00C7 0008  0516 	RETURN
           0517 			;	if(!data)return;
00C8 08FF  0518 	MOVF  data,1
00C9 1903  0519 	BTFSC 0x03,Zero_
00CA 0008  0520 	RETURN
           0521 			;	char crcH,crcL,i,byte;
           0522 			;	crcH=0xff;
00CB 30FF  0523 	MOVLW 255
00CC 00FF  0524 	MOVWF crcH_2
           0525 			;	crcL=0xff;
00CD 30FF  0526 	MOVLW 255
00CE 00FF  0527 	MOVWF crcL_2
           0528 			;
           0529 			;	for(i=0;i<length;i++)
00CF 01FF  0530 	CLRF  i
00D0 087F  0531 m009	MOVF  length,W
00D1 027F  0532 	SUBWF i,W
00D2 1803  0533 	BTFSC 0x03,Carry
00D3 28E4  0534 	GOTO  m010
           0535 			;	{
           0536 			;		byte = data[i];
00D4 087F  0537 	MOVF  i,W
00D5 077F  0538 	ADDWF data,W
00D6 0084  0539 	MOVWF FSR0L
00D7 0185  0540 	CLRF  FSR0H
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 10

ADDR CODE  LINE SOURCE

00D8 0800  0541 	MOVF  INDF0,W
00D9 00FF  0542 	MOVWF byte_2
           0543 			;		addCRC(byte,&crcH,&crcL);
00DA 087F  0544 	MOVF  byte_2,W
00DB 0020  0545 	MOVLB 0
00DC 00A5  0546 	MOVWF byte
00DD 307F  0547 	MOVLW 127
00DE 00A6  0548 	MOVWF p_crcH
00DF 307F  0549 	MOVLW 127
00E0 00A7  0550 	MOVWF p_crcL
00E1 209A  0551 	CALL  addCRC
           0552 			;	}
00E2 0AFF  0553 	INCF  i,1
00E3 28D0  0554 	GOTO  m009
           0555 			;	
           0556 			;	*crcH_out = crcH;
00E4 0185  0557 m010	CLRF  FSR0H
00E5 087F  0558 	MOVF  crcH_out,W
00E6 0084  0559 	MOVWF FSR0L
00E7 087F  0560 	MOVF  crcH_2,W
00E8 0080  0561 	MOVWF INDF0
           0562 			;	*crcL_out = crcL;
00E9 0185  0563 	CLRF  FSR0H
00EA 087F  0564 	MOVF  crcL_out,W
00EB 0084  0565 	MOVWF FSR0L
00EC 087F  0566 	MOVF  crcL_2,W
00ED 0080  0567 	MOVWF INDF0
           0568 			;}
00EE 0008  0569 	RETURN
           0570 			;
           0571 			;void newCRC(char* p_crcH, char* p_crcL)
           0572 			;{
           0573 newCRC
           0574 			;    if(!p_crcH) return;
00EF 0020  0575 	MOVLB 0
00F0 08A5  0576 	MOVF  p_crcH_2,1
00F1 1903  0577 	BTFSC 0x03,Zero_
00F2 0008  0578 	RETURN
           0579 			;    if(!p_crcL) return;
00F3 0020  0580 	MOVLB 0
00F4 08A6  0581 	MOVF  p_crcL_2,1
00F5 1903  0582 	BTFSC 0x03,Zero_
00F6 0008  0583 	RETURN
           0584 			;    *p_crcH = 0xff;
00F7 0185  0585 	CLRF  FSR0H
00F8 0020  0586 	MOVLB 0
00F9 0825  0587 	MOVF  p_crcH_2,W
00FA 0084  0588 	MOVWF FSR0L
00FB 30FF  0589 	MOVLW 255
00FC 0080  0590 	MOVWF INDF0
           0591 			;    *p_crcL = 0xff;
00FD 0185  0592 	CLRF  FSR0H
00FE 0826  0593 	MOVF  p_crcL_2,W
00FF 0084  0594 	MOVWF FSR0L
0100 30FF  0595 	MOVLW 255
0101 0080  0596 	MOVWF INDF0
           0597 			;}
0102 0008  0598 	RETURN
           0599 
           0600   ; FILE eeprom.c
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 11

ADDR CODE  LINE SOURCE

           0601 			;//Funktionen f¸r EEPROM-Zugriffe
           0602 			;
           0603 			;//Nils Weiﬂ 
           0604 			;//05.09.2011
           0605 			;//Compiler CC5x
           0606 			;
           0607 			;#ifndef X86
           0608 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0609 			;
           0610 			;void EEPROM_WR(char adress, char data)
           0611 			;{
           0612 EEPROM_WR
0103 0020  0613 	MOVLB 0
0104 00B1  0614 	MOVWF data_2
           0615 			;	bit GIE_status; 
           0616 			;	//EEADRH = (char)(adress<<8);
           0617 			;    EEADRL = (char)adress;        // Adresse in Adressregister ¸bertragen
0105 0830  0618 	MOVF  adress,W
0106 0023  0619 	MOVLB 3
0107 0091  0620 	MOVWF EEADRL
           0621 			;	EEDATL = data;          // Daten in Datenregister ¸bertragen
0108 0020  0622 	MOVLB 0
0109 0831  0623 	MOVF  data_2,W
010A 0023  0624 	MOVLB 3
010B 0093  0625 	MOVWF EEDATL
           0626 			;    CFGS = 0;
010C 1315  0627 	BCF   0x195,CFGS
           0628 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
010D 1395  0629 	BCF   0x195,EEPGD
           0630 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
010E 1515  0631 	BSF   0x195,WREN
           0632 			;	GIE_status=GIE;			
010F 0020  0633 	MOVLB 0
0110 1032  0634 	BCF   0x32,GIE_status
0111 1B8B  0635 	BTFSC 0x0B,GIE
0112 1432  0636 	BSF   0x32,GIE_status
           0637 			;    GIE=0;                  // Interrups verbieten
0113 138B  0638 	BCF   0x0B,GIE
           0639 			;    EECON2 = 0x55;
0114 3055  0640 	MOVLW 85
0115 0023  0641 	MOVLB 3
0116 0096  0642 	MOVWF EECON2
           0643 			;    EECON2 = 0xAA;
0117 30AA  0644 	MOVLW 170
0118 0096  0645 	MOVWF EECON2
           0646 			;	WR=1; 					// Starten des Schreibens
0119 1495  0647 	BSF   0x195,WR
           0648 			;    GIE=GIE_status;                  // Interrups erlauben
011A 0020  0649 	MOVLB 0
011B 1C32  0650 	BTFSS 0x32,GIE_status
011C 138B  0651 	BCF   0x0B,GIE
011D 1832  0652 	BTFSC 0x32,GIE_status
011E 178B  0653 	BSF   0x0B,GIE
           0654 			;	WREN=0;
011F 0023  0655 	MOVLB 3
0120 1115  0656 	BCF   0x195,WREN
           0657 			;	while(WR);
0121 0023  0658 m011	MOVLB 3
0122 1895  0659 	BTFSC 0x195,WR
0123 2921  0660 	GOTO  m011
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 12

ADDR CODE  LINE SOURCE

           0661 			;}
0124 0008  0662 	RETURN
           0663 			;
           0664 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0665 			;
           0666 			;char EEPROM_RD(char adress)
           0667 			;{
           0668 EEPROM_RD
0125 0020  0669 	MOVLB 0
0126 00B5  0670 	MOVWF adress_2
           0671 			;    char data;
           0672 			;    //EEADRH = (char)(adress<<8);        // Adresse in Adressregister ¸bertragen
           0673 			;    EEADRL = (char)(adress);
0127 0835  0674 	MOVF  adress_2,W
0128 0023  0675 	MOVLB 3
0129 0091  0676 	MOVWF EEADRL
           0677 			;	CFGS=0;
012A 1315  0678 	BCF   0x195,CFGS
           0679 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
012B 1395  0680 	BCF   0x195,EEPGD
           0681 			;    RD=1;                   // Starten des Lesesn
012C 1415  0682 	BSF   0x195,RD
           0683 			;    data = EEDATL;       // Daten aus Datenregister auslesen
012D 0813  0684 	MOVF  EEDATL,W
012E 0020  0685 	MOVLB 0
012F 00B6  0686 	MOVWF data_3
           0687 			;    return data;
0130 0836  0688 	MOVF  data_3,W
0131 0008  0689 	RETURN
           0690 			;}
           0691 			;#endif /* #ifndef X86 */
           0692 			;
           0693 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0694 			;
           0695 			;void EEPROM_WR_BLK(char *array, char adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0696 			;{
           0697 EEPROM_WR_BLK
0132 0020  0698 	MOVLB 0
0133 00AA  0699 	MOVWF length_2
           0700 			;	if(!array) return;
0134 08A8  0701 	MOVF  array,1
0135 1903  0702 	BTFSC 0x03,Zero_
0136 0008  0703 	RETURN
           0704 			;	char i;
           0705 			;	for(i=0;i<length;i++)
0137 0020  0706 	MOVLB 0
0138 01AB  0707 	CLRF  i_2
0139 0020  0708 m012	MOVLB 0
013A 082A  0709 	MOVF  length_2,W
013B 022B  0710 	SUBWF i_2,W
013C 1803  0711 	BTFSC 0x03,Carry
013D 294A  0712 	GOTO  m013
           0713 			;	{
           0714 			;		EEPROM_WR(adress,*array);
013E 0829  0715 	MOVF  adress_3,W
013F 00B0  0716 	MOVWF adress
0140 0185  0717 	CLRF  FSR0H
0141 0828  0718 	MOVF  array,W
0142 0084  0719 	MOVWF FSR0L
0143 0800  0720 	MOVF  INDF0,W
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 13

ADDR CODE  LINE SOURCE

0144 2103  0721 	CALL  EEPROM_WR
           0722 			;		adress++;
0145 0020  0723 	MOVLB 0
0146 0AA9  0724 	INCF  adress_3,1
           0725 			;		array++;
0147 0AA8  0726 	INCF  array,1
           0727 			;	}
0148 0AAB  0728 	INCF  i_2,1
0149 2939  0729 	GOTO  m012
           0730 			;}
014A 0008  0731 m013	RETURN
           0732 			;
           0733 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0734 			;
           0735 			;void EEPROM_RD_BLK(char *array, char adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0736 			;{
           0737 EEPROM_RD_BLK
014B 0020  0738 	MOVLB 0
014C 00B2  0739 	MOVWF length_3
           0740 			;	if(!array) return;
014D 08B0  0741 	MOVF  array_2,1
014E 1903  0742 	BTFSC 0x03,Zero_
014F 0008  0743 	RETURN
           0744 			;	char i, temp;
           0745 			;	for(i=0;i<length;i++)
0150 0020  0746 	MOVLB 0
0151 01B3  0747 	CLRF  i_3
0152 0020  0748 m014	MOVLB 0
0153 0832  0749 	MOVF  length_3,W
0154 0233  0750 	SUBWF i_3,W
0155 1803  0751 	BTFSC 0x03,Carry
0156 2964  0752 	GOTO  m015
           0753 			;	{
           0754 			;		temp = EEPROM_RD(adress);
0157 0831  0755 	MOVF  adress_4,W
0158 2125  0756 	CALL  EEPROM_RD
0159 0020  0757 	MOVLB 0
015A 00B4  0758 	MOVWF temp_2
           0759 			;		array[i] = temp;
015B 0833  0760 	MOVF  i_3,W
015C 0730  0761 	ADDWF array_2,W
015D 0084  0762 	MOVWF FSR0L
015E 0185  0763 	CLRF  FSR0H
015F 0834  0764 	MOVF  temp_2,W
0160 0080  0765 	MOVWF INDF0
           0766 			;		adress++;
0161 0AB1  0767 	INCF  adress_4,1
           0768 			;	}
0162 0AB3  0769 	INCF  i_3,1
0163 2952  0770 	GOTO  m014
           0771 			;}
0164 0008  0772 m015	RETURN
           0773 
           0774   ; FILE ledstrip.c
           0775 			;//Nils Weiﬂ 
           0776 			;//20.04.2012
           0777 			;//Compiler CC5x 
           0778 			;
           0779 			;#include "ledstrip.h"
           0780 			;
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 14

ADDR CODE  LINE SOURCE

           0781 			;void ledstrip_init(void)
           0782 			;{
           0783 ledstrip_init
           0784 			;	char k;
           0785 			;	for(k = 0;k < (NUM_OF_LED * 3); k++)
0165 0020  0786 	MOVLB 0
0166 01A2  0787 	CLRF  k
0167 3060  0788 m016	MOVLW 96
0168 0020  0789 	MOVLB 0
0169 0222  0790 	SUBWF k,W
016A 1803  0791 	BTFSC 0x03,Carry
016B 2976  0792 	GOTO  m017
           0793 			;	{	
           0794 			;		gLedBuf.led_array[k] = 0;
016C 3020  0795 	MOVLW 32
016D 0085  0796 	MOVWF FSR0+1
016E 3040  0797 	MOVLW 64
016F 0722  0798 	ADDWF k,W
0170 0084  0799 	MOVWF FSR0
0171 1803  0800 	BTFSC 0x03,Carry
0172 0A85  0801 	INCF  FSR0+1,1
0173 0180  0802 	CLRF  INDF0
           0803 			;	}
0174 0AA2  0804 	INCF  k,1
0175 2967  0805 	GOTO  m016
           0806 			;}
0176 0008  0807 m017	RETURN
           0808 			;
           0809 			;/***
           0810 			;*** This funktion sets the values of the global LedBuffer
           0811 			;*** only Led's where the address bit is 1 will be set to the new color
           0812 			;***/
           0813 			;void ledstrip_set_color(struct cmd_set_color *pCmd)
           0814 			;{	
           0815 ledstrip_set_color
           0816 			;	char *address = pCmd->addr;
0177 0020  0817 	MOVLB 0
0178 082D  0818 	MOVF  pCmd,W
0179 00AE  0819 	MOVWF address
           0820 			;	char r = pCmd->red;
017A 3004  0821 	MOVLW 4
017B 072D  0822 	ADDWF pCmd,W
017C 0084  0823 	MOVWF FSR0L
017D 0185  0824 	CLRF  FSR0H
017E 0800  0825 	MOVF  INDF0,W
017F 00AF  0826 	MOVWF r
           0827 			;	char g = pCmd->green;
0180 3005  0828 	MOVLW 5
0181 072D  0829 	ADDWF pCmd,W
0182 0084  0830 	MOVWF FSR0L
0183 0185  0831 	CLRF  FSR0H
0184 0800  0832 	MOVF  INDF0,W
0185 00B0  0833 	MOVWF g
           0834 			;	char b = pCmd->blue;
0186 3006  0835 	MOVLW 6
0187 072D  0836 	ADDWF pCmd,W
0188 0084  0837 	MOVWF FSR0L
0189 0185  0838 	CLRF  FSR0H
018A 0800  0839 	MOVF  INDF0,W
018B 00B1  0840 	MOVWF b
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 15

ADDR CODE  LINE SOURCE

           0841 			;	
           0842 			;	char k,mask;
           0843 			;	mask = 0b00000001;
018C 3001  0844 	MOVLW 1
018D 00B3  0845 	MOVWF mask
           0846 			;	for(k = 0; k < (NUM_OF_LED * 3); k++)
018E 01B2  0847 	CLRF  k_2
018F 3060  0848 m018	MOVLW 96
0190 0020  0849 	MOVLB 0
0191 0232  0850 	SUBWF k_2,W
0192 1803  0851 	BTFSC 0x03,Carry
0193 29C6  0852 	GOTO  m022
           0853 			;	{	
           0854 			;		if(0 != (*address & mask))
0194 0185  0855 	CLRF  FSR0H
0195 082E  0856 	MOVF  address,W
0196 0084  0857 	MOVWF FSR0L
0197 0833  0858 	MOVF  mask,W
0198 0500  0859 	ANDWF INDF0,W
0199 1903  0860 	BTFSC 0x03,Zero_
019A 29B9  0861 	GOTO  m019
           0862 			;		{
           0863 			;			gLedBuf.led_array[k] = b;
019B 3020  0864 	MOVLW 32
019C 0085  0865 	MOVWF FSR0+1
019D 3040  0866 	MOVLW 64
019E 0732  0867 	ADDWF k_2,W
019F 0084  0868 	MOVWF FSR0
01A0 1803  0869 	BTFSC 0x03,Carry
01A1 0A85  0870 	INCF  FSR0+1,1
01A2 0831  0871 	MOVF  b,W
01A3 0080  0872 	MOVWF INDF0
           0873 			;			k++;
01A4 0AB2  0874 	INCF  k_2,1
           0875 			;			gLedBuf.led_array[k] = g;
01A5 3020  0876 	MOVLW 32
01A6 0085  0877 	MOVWF FSR0+1
01A7 3040  0878 	MOVLW 64
01A8 0732  0879 	ADDWF k_2,W
01A9 0084  0880 	MOVWF FSR0
01AA 1803  0881 	BTFSC 0x03,Carry
01AB 0A85  0882 	INCF  FSR0+1,1
01AC 0830  0883 	MOVF  g,W
01AD 0080  0884 	MOVWF INDF0
           0885 			;			k++;
01AE 0AB2  0886 	INCF  k_2,1
           0887 			;			gLedBuf.led_array[k] = r;
01AF 3020  0888 	MOVLW 32
01B0 0085  0889 	MOVWF FSR0+1
01B1 3040  0890 	MOVLW 64
01B2 0732  0891 	ADDWF k_2,W
01B3 0084  0892 	MOVWF FSR0
01B4 1803  0893 	BTFSC 0x03,Carry
01B5 0A85  0894 	INCF  FSR0+1,1
01B6 082F  0895 	MOVF  r,W
01B7 0080  0896 	MOVWF INDF0
           0897 			;		}
           0898 			;		else 
01B8 29BC  0899 	GOTO  m020
           0900 			;		{
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 16

ADDR CODE  LINE SOURCE

           0901 			;			k++;
01B9 0020  0902 m019	MOVLB 0
01BA 0AB2  0903 	INCF  k_2,1
           0904 			;			k++;
01BB 0AB2  0905 	INCF  k_2,1
           0906 			;		}
           0907 			;#ifdef X86
           0908 			;		mask = mask << 1;
           0909 			;		if(0 == mask)
           0910 			;#else
           0911 			;		RLF(mask,1);
01BC 0020  0912 m020	MOVLB 0
01BD 0DB3  0913 	RLF   mask,1
           0914 			;		if(Carry == 1) 
01BE 1C03  0915 	BTFSS 0x03,Carry
01BF 29C3  0916 	GOTO  m021
           0917 			;#endif
           0918 			;		{
           0919 			;			address++;
01C0 0AAE  0920 	INCF  address,1
           0921 			;			mask= 0b00000001;
01C1 3001  0922 	MOVLW 1
01C2 00B3  0923 	MOVWF mask
           0924 			;		}
           0925 			;	}
01C3 0020  0926 m021	MOVLB 0
01C4 0AB2  0927 	INCF  k_2,1
01C5 298F  0928 	GOTO  m018
           0929 			;	spi_send_ledbuf(&gLedBuf.led_array[0]);
01C6 3040  0930 m022	MOVLW 64
01C7 0020  0931 	MOVLB 0
01C8 00B4  0932 	MOVWF array_4
01C9 3020  0933 	MOVLW 32
01CA 00B5  0934 	MOVWF array_4+1
01CB 2A1A  0935 	GOTO  spi_send_ledbuf
           0936 
           0937   ; FILE main.c
           0938 			;
           0939 			;// cc5xfree is a bit stupid so we include the other implementation files here
           0940 			;#ifndef X86
           0941 			;#include "crc.c"
           0942 			;#include "eeprom.c"
           0943 			;#include "ledstrip.c"
           0944 
           0945   ; FILE RingBuf.c
           0946 			;
           0947 			;#include "RingBuf.h"
           0948 			;
           0949 			;#ifndef X86
           0950 			;#message Global variables are defined in RingBuf.c
           0951 			;#endif /* #ifndef X86 */
           0952 			;struct RingBuffer gRingBuf;
           0953 			;
           0954 			;void RingBufInit(void)
           0955 			;{
           0956 RingBufInit
           0957 			;	gRingBuf.read = 0;
01CC 0020  0958 	MOVLB 0
01CD 01C9  0959 	CLRF  gRingBuf+16
           0960 			;	gRingBuf.write = 0;
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 17

ADDR CODE  LINE SOURCE

01CE 01CA  0961 	CLRF  gRingBuf+17
           0962 			;	gRingBuf.error_full = 0;
01CF 104B  0963 	BCF   gRingBuf+18,0
           0964 			;}
01D0 0008  0965 	RETURN
           0966 			;
           0967 			;char RingBufGet(void)
           0968 			;{
           0969 RingBufGet
           0970 			;	char result = gRingBuf.data[gRingBuf.read];
01D1 3039  0971 	MOVLW 57
01D2 0020  0972 	MOVLB 0
01D3 0749  0973 	ADDWF gRingBuf+16,W
01D4 0084  0974 	MOVWF FSR0L
01D5 0185  0975 	CLRF  FSR0H
01D6 0800  0976 	MOVF  INDF0,W
01D7 00A5  0977 	MOVWF result
           0978 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
01D8 0A49  0979 	INCF  gRingBuf+16,W
01D9 390F  0980 	ANDLW 15
01DA 00C9  0981 	MOVWF gRingBuf+16
           0982 			;	return result;
01DB 0825  0983 	MOVF  result,W
01DC 0008  0984 	RETURN
           0985 			;}
           0986 			;
           0987 			;void RingBufPut(char value)
           0988 			;{
           0989 RingBufPut
01DD 0020  0990 	MOVLB 0
01DE 00A0  0991 	MOVWF value
           0992 			;	char writeNext = RingBufInc(gRingBuf.write);
01DF 0A4A  0993 	INCF  gRingBuf+17,W
01E0 390F  0994 	ANDLW 15
01E1 00A1  0995 	MOVWF writeNext
           0996 			;	if(writeNext != gRingBuf.read)
01E2 0821  0997 	MOVF  writeNext,W
01E3 0649  0998 	XORWF gRingBuf+16,W
01E4 1903  0999 	BTFSC 0x03,Zero_
01E5 29EF  1000 	GOTO  m023
           1001 			;	{
           1002 			;		gRingBuf.data[gRingBuf.write] = value;
01E6 3039  1003 	MOVLW 57
01E7 074A  1004 	ADDWF gRingBuf+17,W
01E8 0084  1005 	MOVWF FSR0L
01E9 0185  1006 	CLRF  FSR0H
01EA 0820  1007 	MOVF  value,W
01EB 0080  1008 	MOVWF INDF0
           1009 			;		gRingBuf.write = writeNext;
01EC 0821  1010 	MOVF  writeNext,W
01ED 00CA  1011 	MOVWF gRingBuf+17
           1012 			;	}
           1013 			;	else gRingBuf.error_full = 1;
01EE 29F1  1014 	GOTO  m024
01EF 0020  1015 m023	MOVLB 0
01F0 144B  1016 	BSF   gRingBuf+18,0
           1017 			;}
01F1 0008  1018 m024	RETURN
           1019 
           1020   ; FILE spi.c
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 18

ADDR CODE  LINE SOURCE

           1021 			;//Nils Weiﬂ 
           1022 			;//20.04.2012
           1023 			;//Compiler CC5x
           1024 			;
           1025 			;#include "ledstrip.h"
           1026 			;
           1027 			;#ifndef X86
           1028 			;void spi_init()
           1029 			;{
           1030 spi_init
           1031 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
01F2 0021  1032 	MOVLB 1
01F3 118E  1033 	BCF   TRISC,3
           1034 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
01F4 160E  1035 	BSF   TRISC,4
           1036 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
01F5 128E  1037 	BCF   TRISC,5
           1038 			;	SSPM1 = 0;
01F6 0024  1039 	MOVLB 4
01F7 1095  1040 	BCF   0x215,SSPM1
           1041 			;	SMP = 0;
01F8 1394  1042 	BCF   0x214,SMP
           1043 			;	CKP = 1;
01F9 1615  1044 	BSF   0x215,CKP
           1045 			;	CKE = 0;
01FA 1314  1046 	BCF   0x214,CKE
           1047 			;	SSPEN = 1;
01FB 1695  1048 	BSF   0x215,SSPEN
           1049 			;}
01FC 0008  1050 	RETURN
           1051 			;
           1052 			;char spi_send(char data)
           1053 			;{
           1054 spi_send
01FD 0020  1055 	MOVLB 0
01FE 00B8  1056 	MOVWF data_4
           1057 			;	SSPBUF = data;	
01FF 0838  1058 	MOVF  data_4,W
0200 0024  1059 	MOVLB 4
0201 0091  1060 	MOVWF SSPBUF
           1061 			;	while(SSPIF == 0);
0202 0020  1062 m025	MOVLB 0
0203 1D91  1063 	BTFSS 0x11,SSPIF
0204 2A02  1064 	GOTO  m025
           1065 			;	return SSPBUF;
0205 0024  1066 	MOVLB 4
0206 0811  1067 	MOVF  SSPBUF,W
0207 0008  1068 	RETURN
           1069 			;}
           1070 			;#endif /* #ifndef X86 */
           1071 			;
           1072 			;/***
           1073 			;**	This function sends the array to the LED controller(WS2801)
           1074 			;**  it starts with the last byte to get a correct output
           1075 			;***/
           1076 			;void spi_send_arr(char *array, char length)
           1077 			;{
           1078 spi_send_arr
0208 00FF  1079 	MOVWF length_4
           1080 			;	if(array == 0) return;
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 19

ADDR CODE  LINE SOURCE

0209 08FF  1081 	MOVF  array_3,1
020A 1903  1082 	BTFSC 0x03,Zero_
020B 0008  1083 	RETURN
           1084 			;	char i;
           1085 			;	for(i = length; i == 0; i-- )
020C 087F  1086 	MOVF  length_4,W
020D 00FF  1087 	MOVWF i_4
020E 08FF  1088 m026	MOVF  i_4,1
020F 1D03  1089 	BTFSS 0x03,Zero_
0210 2A19  1090 	GOTO  m027
           1091 			;	{
           1092 			;		spi_send(array[i]);
0211 087F  1093 	MOVF  i_4,W
0212 077F  1094 	ADDWF array_3,W
0213 0084  1095 	MOVWF FSR0L
0214 0185  1096 	CLRF  FSR0H
0215 0800  1097 	MOVF  INDF0,W
0216 21FD  1098 	CALL  spi_send
           1099 			;	} 
0217 03FF  1100 	DECF  i_4,1
0218 2A0E  1101 	GOTO  m026
           1102 			;}
0219 0008  1103 m027	RETURN
           1104 			;
           1105 			;void spi_send_ledbuf(char *array)//!!! CHECK if GIE=0 during the sendroutine improves the result
           1106 			;{
           1107 spi_send_ledbuf
           1108 			;	//array must be the address of the first byte
           1109 			;	char* end;
           1110 			;	//calculate where the end is
           1111 			;	end = array + (NUM_OF_LED * 3);
021A 0020  1112 	MOVLB 0
021B 0835  1113 	MOVF  array_4+1,W
021C 00B7  1114 	MOVWF end+1
021D 3060  1115 	MOVLW 96
021E 0734  1116 	ADDWF array_4,W
021F 00B6  1117 	MOVWF end
0220 1803  1118 	BTFSC 0x03,Carry
0221 0AB7  1119 	INCF  end+1,1
           1120 			;	//send all
           1121 			;	for(; array < end; array++)
0222 0020  1122 m028	MOVLB 0
0223 0837  1123 	MOVF  end+1,W
0224 0235  1124 	SUBWF array_4+1,W
0225 1C03  1125 	BTFSS 0x03,Carry
0226 2A2D  1126 	GOTO  m029
0227 1D03  1127 	BTFSS 0x03,Zero_
0228 2A39  1128 	GOTO  m030
0229 0836  1129 	MOVF  end,W
022A 0234  1130 	SUBWF array_4,W
022B 1803  1131 	BTFSC 0x03,Carry
022C 2A39  1132 	GOTO  m030
           1133 			;	{
           1134 			;		spi_send(*array);
022D 0020  1135 m029	MOVLB 0
022E 0835  1136 	MOVF  array_4+1,W
022F 0085  1137 	MOVWF FSR0H
0230 0834  1138 	MOVF  array_4,W
0231 0084  1139 	MOVWF FSR0L
0232 0800  1140 	MOVF  INDF0,W
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 20

ADDR CODE  LINE SOURCE

0233 21FD  1141 	CALL  spi_send
           1142 			;	}
0234 0020  1143 	MOVLB 0
0235 0AB4  1144 	INCF  array_4,1
0236 1903  1145 	BTFSC 0x03,Zero_
0237 0AB5  1146 	INCF  array_4+1,1
0238 2A22  1147 	GOTO  m028
           1148 			;}
0239 0008  1149 m030	RETURN
           1150 
           1151   ; FILE usart.c
           1152 			;// Include-Datei f¸r Serielle Kommunikation ¸ber Hardwaremodul des Pic
           1153 			; //
           1154 			; //
           1155 			; // Nils Weiﬂ
           1156 			; // 29.11.2010
           1157 			; // Compiler CC5x
           1158 			;
           1159 			;#ifndef X86
           1160 			;//*******  Initialisierungs-Funktion  *************************************************
           1161 			;void USARTinit()
           1162 			;{
           1163 USARTinit
           1164 			;	//USART TX Pin als Ausgang
           1165 			;	TRISC.6 = 0;
023A 0021  1166 	MOVLB 1
023B 130E  1167 	BCF   TRISC,6
           1168 			;
           1169 			;    BRGH=1;					// High Baudrate activated
023C 0023  1170 	MOVLB 3
023D 151E  1171 	BSF   0x19E,BRGH
           1172 			;	BRG16=0;
023E 119F  1173 	BCF   0x19F,BRG16
           1174 			;	SPBRGL=25;				// 19200 Bps @ 8 MHz Clock
023F 3019  1175 	MOVLW 25
0240 009B  1176 	MOVWF SPBRGL
           1177 			;	SPBRGH=0;
0241 019C  1178 	CLRF  SPBRGH
           1179 			;    SPEN = 1;               // Set_Serial_Pins;
0242 179D  1180 	BSF   0x19D,SPEN
           1181 			;    SYNC = 0;               // Set_Async_Mode;
0243 121E  1182 	BCF   0x19E,SYNC
           1183 			;    TX9 = 0;                // Set_8bit_Tx;
0244 131E  1184 	BCF   0x19E,TX9
           1185 			;    RX9 = 0;                // Set_8bit_Rx;
0245 131D  1186 	BCF   0x19D,RX9
           1187 			;    CREN = 1;               // Enable_Rx;
0246 161D  1188 	BSF   0x19D,CREN
           1189 			;    TXEN = 1;               // Enable_Tx;
0247 169E  1190 	BSF   0x19E,TXEN
           1191 			;    RCIE=1;                 // Rx Interrupt aus
0248 0021  1192 	MOVLB 1
0249 1691  1193 	BSF   0x91,RCIE
           1194 			;	ADDEN=0;				// Disable Adressdetection
024A 0023  1195 	MOVLB 3
024B 119D  1196 	BCF   0x19D,ADDEN
           1197 			;}
024C 0008  1198 	RETURN
           1199 			;
           1200 			;//*******  Sende-char-Funktion  *************************************************
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 21

ADDR CODE  LINE SOURCE

           1201 			;void USARTsend(unsigned char ch)
           1202 			;{
           1203 USARTsend
024D 0020  1204 	MOVLB 0
024E 00A5  1205 	MOVWF ch
           1206 			;	while(!TXIF);
024F 0020  1207 m031	MOVLB 0
0250 1E11  1208 	BTFSS 0x11,TXIF
0251 2A4F  1209 	GOTO  m031
           1210 			;	TXREG=ch;
0252 0020  1211 	MOVLB 0
0253 0825  1212 	MOVF  ch,W
0254 0023  1213 	MOVLB 3
0255 009A  1214 	MOVWF TXREG
           1215 			;}
0256 0008  1216 	RETURN
           1217 			;#endif /* #ifndef X86 */
           1218 			;
           1219 			;//*******  Sende-String-Funktion  *************************************************
           1220 			;void USARTsend_str(const char *string)
           1221 			;{
           1222 USARTsend_str
           1223 			; char ps;
           1224 			; ps = *string;
0257 0020  1225 	MOVLB 0
0258 0822  1226 	MOVF  string,W
0259 2012  1227 	CALL  _const1
025A 0020  1228 	MOVLB 0
025B 00A3  1229 	MOVWF ps
           1230 			; while(ps > 0)
025C 0020  1231 m032	MOVLB 0
025D 08A3  1232 	MOVF  ps,1
025E 1903  1233 	BTFSC 0x03,Zero_
025F 2A69  1234 	GOTO  m033
           1235 			;   {
           1236 			;    string++;
0260 0AA2  1237 	INCF  string,1
           1238 			;   	USARTsend(ps);
0261 0823  1239 	MOVF  ps,W
0262 224D  1240 	CALL  USARTsend
           1241 			;    ps = *string;
0263 0020  1242 	MOVLB 0
0264 0822  1243 	MOVF  string,W
0265 2012  1244 	CALL  _const1
0266 0020  1245 	MOVLB 0
0267 00A3  1246 	MOVWF ps
           1247 			;   }
0268 2A5C  1248 	GOTO  m032
           1249 			;}
0269 0008  1250 m033	RETURN
           1251 			;
           1252 			;//*******  Sende-Array-Funktion  *************************************************
           1253 			;void USARTsend_arr(char *array, char length)
           1254 			;{
           1255 USARTsend_arr
026A 00FF  1256 	MOVWF length_5
           1257 			;	if(array == 0) return;
026B 08FF  1258 	MOVF  array_5,1
026C 1903  1259 	BTFSC 0x03,Zero_
026D 0008  1260 	RETURN
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 22

ADDR CODE  LINE SOURCE

           1261 			;	char i;
           1262 			;	for(i=0;i<length;i++)
026E 01FF  1263 	CLRF  i_5
026F 087F  1264 m034	MOVF  length_5,W
0270 027F  1265 	SUBWF i_5,W
0271 1803  1266 	BTFSC 0x03,Carry
0272 2A7B  1267 	GOTO  m035
           1268 			;	{
           1269 			;		USARTsend(*array);
0273 0185  1270 	CLRF  FSR0H
0274 087F  1271 	MOVF  array_5,W
0275 0084  1272 	MOVWF FSR0L
0276 0800  1273 	MOVF  INDF0,W
0277 224D  1274 	CALL  USARTsend
           1275 			;		array++;
0278 0AFF  1276 	INCF  array_5,1
           1277 			;	}
0279 0AFF  1278 	INCF  i_5,1
027A 2A6F  1279 	GOTO  m034
           1280 			;}
027B 0008  1281 m035	RETURN
           1282 
           1283   ; FILE commandstorage.c
           1284 			;/** Changelog
           1285 			; * 2012-05-08 pb:
           1286 			; * - refactor functions to access and manage a buffer for led commands, which is stored in the eeprom
           1287 			;**/
           1288 			;
           1289 			;struct led_cmd* commandstorage_read(struct led_cmd *pDest, bit movePtr)
           1290 			;{
           1291 commandstorage_read
           1292 			;	//check parameter
           1293 			;	if(0 == pDest) return 0;
027C 0020  1294 	MOVLB 0
027D 08AD  1295 	MOVF  pDest,1
027E 1903  1296 	BTFSC 0x03,Zero_
027F 3400  1297 	RETLW 0
           1298 			;
           1299 			;	//commands available in eeprom?
           1300 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
0280 30FF  1301 	MOVLW 255
0281 2125  1302 	CALL  EEPROM_RD
0282 0020  1303 	MOVLB 0
0283 00AE  1304 	MOVWF nextCmd
           1305 			;	if(0 == nextCmd) return 0;
0284 08AE  1306 	MOVF  nextCmd,1
0285 1903  1307 	BTFSC 0x03,Zero_
0286 3400  1308 	RETLW 0
           1309 			;
           1310 			;	//read command from eeprom
           1311 			;	EEPROM_RD_BLK(pDest, (nextCmd - CmdWidth), CmdWidth);
0287 0020  1312 	MOVLB 0
0288 082D  1313 	MOVF  pDest,W
0289 00B0  1314 	MOVWF array_2
028A 300A  1315 	MOVLW 10
028B 022E  1316 	SUBWF nextCmd,W
028C 00B1  1317 	MOVWF adress_4
028D 300A  1318 	MOVLW 10
028E 214B  1319 	CALL  EEPROM_RD_BLK
           1320 			;
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 23

ADDR CODE  LINE SOURCE

           1321 			;	//do we have to update the CmdPointer?
           1322 			;	if(movePtr)
028F 0020  1323 	MOVLB 0
0290 1C2F  1324 	BTFSS 0x2F,movePtr
0291 2A97  1325 	GOTO  m036
           1326 			;	{		
           1327 			;		EEPROM_WR(CmdPointerAddr, nextCmd - CmdWidth);
0292 30FF  1328 	MOVLW 255
0293 00B0  1329 	MOVWF adress
0294 300A  1330 	MOVLW 10
0295 022E  1331 	SUBWF nextCmd,W
0296 2103  1332 	CALL  EEPROM_WR
           1333 			;	}
           1334 			;	return pDest;
0297 0020  1335 m036	MOVLB 0
0298 082D  1336 	MOVF  pDest,W
0299 0008  1337 	RETURN
           1338 			;}
           1339 			;
           1340 			;bit commandstorage_write(char *pSrc, char length)
           1341 			;{
           1342 commandstorage_write
029A 0020  1343 	MOVLB 0
029B 00A6  1344 	MOVWF length_6
           1345 			;	//check parameter
           1346 			;	if(0 == pSrc) return FALSE;
029C 08A5  1347 	MOVF  pSrc,1
029D 1D03  1348 	BTFSS 0x03,Zero_
029E 2AA1  1349 	GOTO  m037
029F 1003  1350 	BCF   0x03,Carry
02A0 0008  1351 	RETURN
           1352 			;	
           1353 			;	//enought free space in eeprom?
           1354 			;	char nextCmd = EEPROM_RD(CmdPointerAddr);
02A1 30FF  1355 m037	MOVLW 255
02A2 2125  1356 	CALL  EEPROM_RD
02A3 0020  1357 	MOVLB 0
02A4 00A7  1358 	MOVWF nextCmd_2
           1359 			;	if(nextCmd >= (CmdPointerAddr - CmdWidth)) return FALSE;
02A5 30F5  1360 	MOVLW 245
02A6 0227  1361 	SUBWF nextCmd_2,W
02A7 1C03  1362 	BTFSS 0x03,Carry
02A8 2AAB  1363 	GOTO  m038
02A9 1003  1364 	BCF   0x03,Carry
02AA 0008  1365 	RETURN
           1366 			;
           1367 			;	//increase the command pointer in eeprom
           1368 			;	EEPROM_WR(CmdPointerAddr,(nextCmd + CmdWidth));
02AB 30FF  1369 m038	MOVLW 255
02AC 0020  1370 	MOVLB 0
02AD 00B0  1371 	MOVWF adress
02AE 300A  1372 	MOVLW 10
02AF 0727  1373 	ADDWF nextCmd_2,W
02B0 2103  1374 	CALL  EEPROM_WR
           1375 			;		
           1376 			;	//write data to eeprom
           1377 			;	EEPROM_WR_BLK(pSrc, nextCmd, length);
02B1 0020  1378 	MOVLB 0
02B2 0825  1379 	MOVF  pSrc,W
02B3 00A8  1380 	MOVWF array
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 24

ADDR CODE  LINE SOURCE

02B4 0827  1381 	MOVF  nextCmd_2,W
02B5 00A9  1382 	MOVWF adress_3
02B6 0826  1383 	MOVF  length_6,W
02B7 2132  1384 	CALL  EEPROM_WR_BLK
           1385 			;		
           1386 			;	return TRUE;
02B8 1403  1387 	BSF   0x03,Carry
02B9 0008  1388 	RETURN
           1389 			;}
           1390 			;
           1391 			;void commandstorage_get_commands()
           1392 			;{	
           1393 commandstorage_get_commands
           1394 			;	if(RingBufHasError)
02BA 0020  1395 	MOVLB 0
02BB 1C4B  1396 	BTFSS gRingBuf+18,0
02BC 2ABF  1397 	GOTO  m039
           1398 			;	{
           1399 			;		// *** if a RingBufError occure, I have to throw away the current command,
           1400 			;		// *** because the last byte was not saved. Commandstring is inconsistent
           1401 			;		ClearCmdBuf;
02BD 01CC  1402 	CLRF  gCmdBuf
02BE 01CD  1403 	CLRF  gCmdBuf+1
           1404 			;	}
           1405 			;
           1406 			;	if(RingBufIsNotEmpty)
02BF 0020  1407 m039	MOVLB 0
02C0 084A  1408 	MOVF  gRingBuf+17,W
02C1 0649  1409 	XORWF gRingBuf+16,W
02C2 1903  1410 	BTFSC 0x03,Zero_
02C3 2B36  1411 	GOTO  m048
           1412 			;	{
           1413 			;		// *** preload variables and 
           1414 			;		// *** get new_byte from ringbuffer
           1415 			;		char new_byte, temp, j;
           1416 			;		temp = 0;
02C4 01A3  1417 	CLRF  temp_3
           1418 			;		j = 0;
02C5 01A4  1419 	CLRF  j
           1420 			;		// *** get new byte
           1421 			;		new_byte = RingBufGet();	
02C6 21D1  1422 	CALL  RingBufGet
02C7 0020  1423 	MOVLB 0
02C8 00A2  1424 	MOVWF new_byte
           1425 			;		// *** do I wait for databytes?
           1426 			;		if(gCmdBuf.frame_counter == 0)
02C9 08CD  1427 	MOVF  gCmdBuf+1,1
02CA 1D03  1428 	BTFSS 0x03,Zero_
02CB 2AF7  1429 	GOTO  m041
           1430 			;		{
           1431 			;			// *** I don't wait for databytes
           1432 			;			// *** Do I receive a Start_of_Text sign
           1433 			;			if(new_byte == STX)
02CC 0F22  1434 	INCFSZ new_byte,W
02CD 2AE0  1435 	GOTO  m040
           1436 			;			{
           1437 			;				// *** increse the cmd_counter
           1438 			;				gCmdBuf.cmd_counter = 1;
02CE 3001  1439 	MOVLW 1
02CF 00CC  1440 	MOVWF gCmdBuf
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 25

ADDR CODE  LINE SOURCE

           1441 			;				// *** Write the startsign at the begin of the buffer
           1442 			;				gCmdBuf.cmd_buf[0] = new_byte;
02D0 0822  1443 	MOVF  new_byte,W
02D1 00CE  1444 	MOVWF gCmdBuf+2
           1445 			;                // *** Reset crc Variables
           1446 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
02D2 305D  1447 	MOVLW 93
02D3 00A5  1448 	MOVWF p_crcH_2
02D4 305E  1449 	MOVLW 94
02D5 00A6  1450 	MOVWF p_crcL_2
02D6 20EF  1451 	CALL  newCRC
           1452 			;                // *** add new_byte to crc checksum
           1453 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02D7 0020  1454 	MOVLB 0
02D8 0822  1455 	MOVF  new_byte,W
02D9 00A5  1456 	MOVWF byte
02DA 305D  1457 	MOVLW 93
02DB 00A6  1458 	MOVWF p_crcH
02DC 305E  1459 	MOVLW 94
02DD 00A7  1460 	MOVWF p_crcL
02DE 209A  1461 	CALL  addCRC
           1462 			;			}
           1463 			;			else
02DF 2B36  1464 	GOTO  m048
           1465 			;			{	
           1466 			;				// *** to avoid arrayoverflow
           1467 			;				temp = FRAMELENGTH - 2;
02E0 300D  1468 m040	MOVLW 13
02E1 0020  1469 	MOVLB 0
02E2 00A3  1470 	MOVWF temp_3
           1471 			;				// *** check if I get the framelength byte
           1472 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
02E3 0823  1473 	MOVF  temp_3,W
02E4 0222  1474 	SUBWF new_byte,W
02E5 1803  1475 	BTFSC 0x03,Carry
02E6 2B36  1476 	GOTO  m048
02E7 0B4C  1477 	DECFSZ gCmdBuf,W
02E8 2B36  1478 	GOTO  m048
           1479 			;				{
           1480 			;					gCmdBuf.frame_counter = new_byte;
02E9 0822  1481 	MOVF  new_byte,W
02EA 00CD  1482 	MOVWF gCmdBuf+1
           1483 			;					gCmdBuf.cmd_buf[1] = new_byte;
02EB 0822  1484 	MOVF  new_byte,W
02EC 00CF  1485 	MOVWF gCmdBuf+3
           1486 			;					gCmdBuf.cmd_counter = 2;
02ED 3002  1487 	MOVLW 2
02EE 00CC  1488 	MOVWF gCmdBuf
           1489 			;                    // *** add new_byte to crc checksum
           1490 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
02EF 0822  1491 	MOVF  new_byte,W
02F0 00A5  1492 	MOVWF byte
02F1 305D  1493 	MOVLW 93
02F2 00A6  1494 	MOVWF p_crcH
02F3 305E  1495 	MOVLW 94
02F4 00A7  1496 	MOVWF p_crcL
02F5 209A  1497 	CALL  addCRC
           1498 			;				}
           1499 			;			}
           1500 			;		}
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 26

ADDR CODE  LINE SOURCE

           1501 			;		else
02F6 2B36  1502 	GOTO  m048
           1503 			;		{
           1504 			;			// *** I wait for Databytes, so I save all bytes 
           1505 			;			// *** that I get until my framecounter is > 0
           1506 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
02F7 304E  1507 m041	MOVLW 78
02F8 0020  1508 	MOVLB 0
02F9 074C  1509 	ADDWF gCmdBuf,W
02FA 0084  1510 	MOVWF FSR0L
02FB 0185  1511 	CLRF  FSR0H
02FC 0822  1512 	MOVF  new_byte,W
02FD 0080  1513 	MOVWF INDF0
           1514 			;			gCmdBuf.cmd_counter++;
02FE 0ACC  1515 	INCF  gCmdBuf,1
           1516 			;			
           1517 			;            // *** add new_byte to crc checksum
           1518 			;			if(gCmdBuf.frame_counter > 2)
02FF 3003  1519 	MOVLW 3
0300 024D  1520 	SUBWF gCmdBuf+1,W
0301 1C03  1521 	BTFSS 0x03,Carry
0302 2B0A  1522 	GOTO  m042
           1523 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0303 0822  1524 	MOVF  new_byte,W
0304 00A5  1525 	MOVWF byte
0305 305D  1526 	MOVLW 93
0306 00A6  1527 	MOVWF p_crcH
0307 305E  1528 	MOVLW 94
0308 00A7  1529 	MOVWF p_crcL
0309 209A  1530 	CALL  addCRC
           1531 			;			gCmdBuf.frame_counter--;
030A 0020  1532 m042	MOVLB 0
030B 0BCD  1533 	DECFSZ gCmdBuf+1,1
           1534 			;			// *** now I have to check if my framecounter is null.
           1535 			;			// *** If it's null my string is complete 
           1536 			;			// *** and I can give the string to the crc check function.
           1537 			;			if(gCmdBuf.frame_counter == 0)
030C 2B36  1538 	GOTO  m048
           1539 			;			{
           1540 			;#ifdef NO_CRC
           1541 			;				if(1==1)
           1542 			;#else
           1543 			;                // *** verify crc checksum
           1544 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
           1545 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
           1546 			;#endif
           1547 			;                {
           1548 			;					// *** Execute the simple Commands
           1549 			;					switch(gCmdBuf.cmd_buf[2])
030D 0850  1550 	MOVF  gCmdBuf+4,W
030E 3AF8  1551 	XORLW 248
030F 1903  1552 	BTFSC 0x03,Zero_
0310 2B18  1553 	GOTO  m043
0311 3A02  1554 	XORLW 2
0312 1903  1555 	BTFSC 0x03,Zero_
0313 2B1D  1556 	GOTO  m044
0314 3A03  1557 	XORLW 3
0315 1903  1558 	BTFSC 0x03,Zero_
0316 2B20  1559 	GOTO  m045
0317 2B23  1560 	GOTO  m046
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 27

ADDR CODE  LINE SOURCE

           1561 			;					{
           1562 			;						case DELETE: 
           1563 			;							{
           1564 			;								EEPROM_WR(CmdPointerAddr,0);
0318 30FF  1565 m043	MOVLW 255
0319 0020  1566 	MOVLB 0
031A 00B0  1567 	MOVWF adress
031B 3000  1568 	MOVLW 0
031C 2903  1569 	GOTO  EEPROM_WR
           1570 			;								return;
           1571 			;							}
           1572 			;#ifndef X86
           1573 			;						case SET_ON: 
           1574 			;							{
           1575 			;								BCF(PORTC.0); 
031D 0020  1576 m044	MOVLB 0
031E 100E  1577 	BCF   PORTC,0
           1578 			;								return;
031F 0008  1579 	RETURN
           1580 			;								}
           1581 			;						case SET_OFF: 
           1582 			;							{
           1583 			;								BSF(PORTC.0); 
0320 0020  1584 m045	MOVLB 0
0321 140E  1585 	BSF   PORTC,0
           1586 			;								return;
0322 0008  1587 	RETURN
           1588 			;							}
           1589 			;#endif /* #ifndef X86 */
           1590 			;					}			
           1591 			;					if( commandstorage_write(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4)))
0323 3050  1592 m046	MOVLW 80
0324 0020  1593 	MOVLB 0
0325 00A5  1594 	MOVWF pSrc
0326 3004  1595 	MOVLW 4
0327 024C  1596 	SUBWF gCmdBuf,W
0328 229A  1597 	CALL  commandstorage_write
0329 1C03  1598 	BTFSS 0x03,Carry
032A 2B30  1599 	GOTO  m047
           1600 			;					{
           1601 			;						USARTsend('G');
032B 3047  1602 	MOVLW 71
032C 224D  1603 	CALL  USARTsend
           1604 			;						USARTsend('C');
032D 3043  1605 	MOVLW 67
032E 224D  1606 	CALL  USARTsend
           1607 			;					}
           1608 			;					else 
032F 2B36  1609 	GOTO  m048
           1610 			;						gERROR.eeprom_failure = 1;
0330 0020  1611 m047	MOVLB 0
0331 14DF  1612 	BSF   gERROR,1
           1613 			;#ifdef TEST
           1614 			;					USARTsend_arr(&gCmdBuf.cmd_buf[2], (gCmdBuf.cmd_counter - 4));
           1615 			;#endif
           1616 			;                }
           1617 			;                else
0332 2B36  1618 	GOTO  m048
           1619 			;                {
           1620 			;                    // *** Do some error handling in case of an CRC failure here
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 28

ADDR CODE  LINE SOURCE

           1621 			;					gERROR.crc_failure = 1;
0333 0020  1622 	MOVLB 0
0334 145F  1623 	BSF   gERROR,0
           1624 			;                    return;
0335 0008  1625 	RETURN
           1626 			;                }
           1627 			;			}
           1628 			;		}
           1629 			;	}
           1630 			;}
0336 0008  1631 m048	RETURN
           1632 			;
           1633 			;void commandstorage_execute_commands()
           1634 			;{
           1635 commandstorage_execute_commands
           1636 			;	// *** get the pointer to commands in the EEPROM
           1637 			;	struct led_cmd nextCmd;
           1638 			;
           1639 			;	// read next command from eeprom and move command pointer in eeprom to the next command (TRUE)
           1640 			;	struct led_cmd *result = commandstorage_read(&nextCmd, TRUE);
0337 3022  1641 	MOVLW 34
0338 0020  1642 	MOVLB 0
0339 00AD  1643 	MOVWF pDest
033A 142F  1644 	BSF   0x2F,movePtr
033B 227C  1645 	CALL  commandstorage_read
033C 0020  1646 	MOVLB 0
033D 00AC  1647 	MOVWF result_2
           1648 			;	if(0 != result)
033E 08AC  1649 	MOVF  result_2,1
033F 1903  1650 	BTFSC 0x03,Zero_
0340 2B50  1651 	GOTO  m050
           1652 			;	{
           1653 			;		// *** commands available, check what to do
           1654 			;		switch(nextCmd.cmd) 
0341 0822  1655 	MOVF  nextCmd_3,W
0342 3AFD  1656 	XORLW 253
0343 1903  1657 	BTFSC 0x03,Zero_
0344 2B4C  1658 	GOTO  m049
0345 3A01  1659 	XORLW 1
0346 1903  1660 	BTFSC 0x03,Zero_
0347 2B50  1661 	GOTO  m050
0348 3A07  1662 	XORLW 7
0349 1903  1663 	BTFSC 0x03,Zero_
034A 2B50  1664 	GOTO  m050
034B 2B50  1665 	GOTO  m050
           1666 			;		{	
           1667 			;			case SET_COLOR: 
           1668 			;			{
           1669 			;				ledstrip_set_color(&nextCmd.data.set_color);
034C 3023  1670 m049	MOVLW 35
034D 0020  1671 	MOVLB 0
034E 00AD  1672 	MOVWF pCmd
034F 2177  1673 	CALL  ledstrip_set_color
           1674 			;				break;
           1675 			;			}
           1676 			;			case SET_FADE: {break;}
           1677 			;			case SET_RUN: {break;}
           1678 			;		}
           1679 
           1680   ; FILE main.c
CC5X Version 3.4E,   File: main.c              14. May 2012  11:53   Page 29

ADDR CODE  LINE SOURCE

           1681 			;#include "RingBuf.c"
           1682 			;#include "spi.c"
           1683 			;#include "timer.c"
           1684 			;#include "usart.c"
           1685 			;#include "commandstorage.c"
0350 0008  1686 m050	RETURN
           1687 
           1688 	END
           1689 
           1690 
           1691 ; *** KEY INFO ***
           1692 
           1693 ; 0x01CC P0    5 word(s)  0 % : RingBufInit
           1694 ; 0x01D1 P0   12 word(s)  0 % : RingBufGet
           1695 ; 0x01DD P0   21 word(s)  1 % : RingBufPut
           1696 ; 0x023A P0   19 word(s)  0 % : USARTinit
           1697 ; 0x024D P0   10 word(s)  0 % : USARTsend
           1698 ; 0x0257 P0   19 word(s)  0 % : USARTsend_str
           1699 ; 0x026A P0   18 word(s)  0 % : USARTsend_arr
           1700 ; 0x0103 P0   34 word(s)  1 % : EEPROM_WR
           1701 ; 0x0125 P0   13 word(s)  0 % : EEPROM_RD
           1702 ; 0x0132 P0   25 word(s)  1 % : EEPROM_WR_BLK
           1703 ; 0x014B P0   26 word(s)  1 % : EEPROM_RD_BLK
           1704 ; 0x009A P0   40 word(s)  1 % : addCRC
           1705 ; 0x00C2 P0   45 word(s)  2 % : CRC
           1706 ; 0x00EF P0   20 word(s)  0 % : newCRC
           1707 ; 0x027C P0   30 word(s)  1 % : commandstorage_read
           1708 ; 0x029A P0   32 word(s)  1 % : commandstorage_write
           1709 ; 0x02BA P0  125 word(s)  6 % : commandstorage_get_commands
           1710 ; 0x0337 P0   26 word(s)  1 % : commandstorage_execute_commands
           1711 ; 0x01F2 P0   11 word(s)  0 % : spi_init
           1712 ; 0x01FD P0   11 word(s)  0 % : spi_send
           1713 ; 0x0208 P0   18 word(s)  0 % : spi_send_arr
           1714 ; 0x021A P0   32 word(s)  1 % : spi_send_ledbuf
           1715 ; 0x0165 P0   18 word(s)  0 % : ledstrip_init
           1716 ; 0x0177 P0   85 word(s)  4 % : ledstrip_set_color
           1717 ; 0x0004 P0   14 word(s)  0 % : InterruptRoutine
           1718 ; 0x005A P0   39 word(s)  1 % : init_all
           1719 ; 0x0081 P0   25 word(s)  1 % : throw_errors
           1720 ; 0x0055 P0    5 word(s)  0 % : main
           1721 ; 0x0012 P0   67 word(s)  3 % : _const1
           1722 
           1723 ; RAM usage: 160 bytes (25 local), 352 bytes free
           1724 ; Maximum call level: 4 (+2 for interrupt)
           1725 ;  Codepage 0 has  846 word(s) :  41 %
           1726 ;  Codepage 1 has    0 word(s) :   0 %
           1727 ;  Codepage 2 has    0 word(s) :   0 %
           1728 ;  Codepage 3 has    0 word(s) :   0 %
           1729 ; Total of 846 code words (10 %)
