CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 1

ADDR CODE  LINE SOURCE

           0001 
           0002 ; CC5X Version 3.4E, Copyright (c) B Knudsen Data
           0003 ; C compiler for the PICmicro family
           0004 ; ************  25. Apr 2012  18:18  *************
           0005 
           0006 	processor  16F1936
           0007 	radix  DEC
           0008 
     0000  0009 INDF0       EQU   0x00
     0004  0010 FSR0        EQU   0x04
     0004  0011 FSR0L       EQU   0x04
     0005  0012 FSR0H       EQU   0x05
     0000  0013 Carry       EQU   0
     0002  0014 Zero_       EQU   2
     000E  0015 PORTC       EQU   0x0E
     008E  0016 TRISC       EQU   0x8E
     0099  0017 OSCCON      EQU   0x99
     0191  0018 EEADRL      EQU   0x191
     0192  0019 EEADRH      EQU   0x192
     0193  0020 EEDATL      EQU   0x193
     0194  0021 EEDATH      EQU   0x194
     0196  0022 EECON2      EQU   0x196
     0199  0023 RCREG       EQU   0x199
     019A  0024 TXREG       EQU   0x19A
     019B  0025 SPBRGL      EQU   0x19B
     019C  0026 SPBRGH      EQU   0x19C
     0211  0027 SSPBUF      EQU   0x211
     0006  0028 PEIE        EQU   6
     0007  0029 GIE         EQU   7
     0003  0030 SSPIF       EQU   3
     0004  0031 TXIF        EQU   4
     0005  0032 RCIF        EQU   5
     0005  0033 RCIE        EQU   5
     0000  0034 RD          EQU   0
     0001  0035 WR          EQU   1
     0002  0036 WREN        EQU   2
     0006  0037 CFGS        EQU   6
     0007  0038 EEPGD       EQU   7
     0003  0039 ADDEN       EQU   3
     0004  0040 CREN        EQU   4
     0006  0041 RX9         EQU   6
     0007  0042 SPEN        EQU   7
     0002  0043 BRGH        EQU   2
     0004  0044 SYNC        EQU   4
     0005  0045 TXEN        EQU   5
     0006  0046 TX9         EQU   6
     0003  0047 BRG16       EQU   3
     0005  0048 SSPEN       EQU   5
     002B  0049 gRingBuf    EQU   0x2B
     0025  0050 result      EQU   0x25
     0020  0051 value       EQU   0x20
     0021  0052 writeNext   EQU   0x21
     0024  0053 ch          EQU   0x24
     0022  0054 putstr      EQU   0x22
     0023  0055 ps          EQU   0x23
     007F  0056 array       EQU   0x7F
     007F  0057 length      EQU   0x7F
     007F  0058 i           EQU   0x7F
     0026  0059 adress      EQU   0x26
     0027  0060 data        EQU   0x27
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 2

ADDR CODE  LINE SOURCE

     0000  0061 GIE_status  EQU   0
     0026  0062 adress_2    EQU   0x26
     0027  0063 data_2      EQU   0x27
     007F  0064 array_2     EQU   0x7F
     007F  0065 adress_3    EQU   0x7F
     007F  0066 length_2    EQU   0x7F
     007F  0067 i_2         EQU   0x7F
     007F  0068 array_3     EQU   0x7F
     007F  0069 adress_4    EQU   0x7F
     007F  0070 length_3    EQU   0x7F
     007F  0071 i_3         EQU   0x7F
     007F  0072 temp        EQU   0x7F
     0025  0073 byte        EQU   0x25
     0026  0074 p_crcH      EQU   0x26
     0027  0075 p_crcL      EQU   0x27
     0028  0076 index       EQU   0x28
     0029  0077 crcH        EQU   0x29
     002A  0078 crcL        EQU   0x2A
     007F  0079 data_3      EQU   0x7F
     007F  0080 length_4    EQU   0x7F
     007F  0081 crcH_out    EQU   0x7F
     007F  0082 crcL_out    EQU   0x7F
     007F  0083 crcH_2      EQU   0x7F
     007F  0084 crcL_2      EQU   0x7F
     007F  0085 i_4         EQU   0x7F
     007F  0086 byte_2      EQU   0x7F
     0025  0087 p_crcH_2    EQU   0x25
     0026  0088 p_crcL_2    EQU   0x26
     007F  0089 data_4      EQU   0x7F
     007F  0090 data_5      EQU   0x7F
     007F  0091 array_4     EQU   0x7F
     007F  0092 length_5    EQU   0x7F
     007F  0093 i_5         EQU   0x7F
     0023  0094 k           EQU   0x23
     007F  0095 red         EQU   0x7F
     007F  0096 green       EQU   0x7F
     007F  0097 blue        EQU   0x7F
     007F  0098 k_2         EQU   0x7F
     007F  0099 selector    EQU   0x7F
     003E  0100 gCmdBuf     EQU   0x3E
     0053  0101 gERROR      EQU   0x53
     0020  0102 temp_2      EQU   0x20
     0022  0103 i_6         EQU   0x22
     0022  0104 new_byte    EQU   0x22
     0023  0105 temp_3      EQU   0x23
     0024  0106 j           EQU   0x24
     0025  0107 CmdPointer  EQU   0x25
     0024  0108 ci          EQU   0x24
           0109 
0000 2814  0110 	GOTO main
           0111 
           0112   ; FILE main.c
           0113 			;//Nils Weiﬂ 
           0114 			;//05.09.2011
           0115 			;//Compiler CC5x/
           0116 			;
           0117 			;#pragma sharedAllocation
           0118 			;
           0119 			;//*********************** ENUMERATIONS *********************************************
           0120 			;#define TRUE  1
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 3

ADDR CODE  LINE SOURCE

           0121 			;#define FALSE 0
           0122 			;
           0123 			;#define STX 0xFF
           0124 			;#define SET_COLOR 0xFD
           0125 			;#define SET_FADE 0xFC
           0126 			;#define SET_RUN 0xFB
           0127 			;#define WAIT 0xFE
           0128 			;#define SET_ON 0xFA
           0129 			;#define SET_OFF 0xF9
           0130 			;#define DELETE 0xF8
           0131 			;
           0132 			;// *** ERRORBITS
           0133 			;#define crc_failure 0
           0134 			;#define eeprom_failure 1
           0135 			;
           0136 			;#define FRAMELENGTH 16			// *** max length of one commandframe
           0137 			;#define CmdPointerAddr 0xff		// *** Address at EERPOM, where the Commandpointer is saved
           0138 			;
           0139 			;//*********************** INCLUDEDATEIEN *********************************************
           0140 			;#pragma codepage 1
     0000  0141 	ORG 0x0800
           0142 
           0143   ; FILE include_files\RingBuf.c
           0144 			;
           0145 			;//#include "unused_files/RingBuf.h"
           0146 			;//#include "RingBuf.h"
           0147 			;
           0148 			;
           0149 			;#message Global variables are defined in RingBuf.c
           0150 			;
           0151 			;struct RingBuffer gRingBuf;
           0152 			;
           0153 			;void RingBufInit(void)
           0154 			;{
           0155 _const1
0800 0020  0156 	MOVLB 0
0801 00A4  0157 	MOVWF ci
0802 3008  0158 	MOVLW 8
0803 0023  0159 	MOVLB 3
0804 0092  0160 	MOVWF EEADRH
0805 0020  0161 	MOVLB 0
0806 0C24  0162 	RRF   ci,W
0807 397F  0163 	ANDLW 127
0808 3E1D  0164 	ADDLW 29
0809 0023  0165 	MOVLB 3
080A 0091  0166 	MOVWF EEADRL
080B 1803  0167 	BTFSC 0x03,Carry
080C 0A92  0168 	INCF  EEADRH,1
080D 0023  0169 	MOVLB 3
080E 1795  0170 	BSF   0x195,EEPGD
080F 1415  0171 	BSF   0x195,RD
0810 0000  0172 	NOP  
0811 0000  0173 	NOP  
0812 0020  0174 	MOVLB 0
0813 1824  0175 	BTFSC ci,0
0814 2819  0176 	GOTO  m001
0815 0023  0177 	MOVLB 3
0816 0813  0178 	MOVF  EEDATL,W
0817 397F  0179 	ANDLW 127
0818 0008  0180 	RETURN
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 4

ADDR CODE  LINE SOURCE

0819 0023  0181 m001	MOVLB 3
081A 0D13  0182 	RLF   EEDATL,W
081B 0D14  0183 	RLF   EEDATH,W
081C 0008  0184 	RETURN
081D 2945  0185 	DW    0x2945
081E 27D2  0186 	DW    0x27D2
081F 1D52  0187 	DW    0x1D52
0820 2920  0188 	DW    0x2920
0821 31E5  0189 	DW    0x31E5
0822 34E5  0190 	DW    0x34E5
0823 32F6  0191 	DW    0x32F6
0824 3AE2  0192 	DW    0x3AE2
0825 3366  0193 	DW    0x3366
0826 3965  0194 	DW    0x3965
0827 3320  0195 	DW    0x3320
0828 3675  0196 	DW    0x3675
0829 006C  0197 	DW    0x6C
082A 2945  0198 	DW    0x2945
082B 27D2  0199 	DW    0x27D2
082C 1D52  0200 	DW    0x1D52
082D 21A0  0201 	DW    0x21A0
082E 21D2  0202 	DW    0x21D2
082F 21AD  0203 	DW    0x21AD
0830 32E8  0204 	DW    0x32E8
0831 35E3  0205 	DW    0x35E3
0832 3320  0206 	DW    0x3320
0833 34E1  0207 	DW    0x34E1
0834 32EC  0208 	DW    0x32EC
0835 0064  0209 	DW    0x64
0836 2945  0210 	DW    0x2945
0837 27D2  0211 	DW    0x27D2
0838 1D52  0212 	DW    0x1D52
0839 22A0  0213 	DW    0x22A0
083A 2845  0214 	DW    0x2845
083B 27D2  0215 	DW    0x27D2
083C 104D  0216 	DW    0x104D
083D 39E9  0217 	DW    0x39E9
083E 3320  0218 	DW    0x3320
083F 3675  0219 	DW    0x3675
0840 006C  0220 	DW    0x6C
           0221 RingBufInit
           0222 			;	gRingBuf.read = 0;
0841 0020  0223 	MOVLB 0
0842 01BB  0224 	CLRF  gRingBuf+16
           0225 			;	gRingBuf.write = 0;
0843 01BC  0226 	CLRF  gRingBuf+17
           0227 			;	gRingBuf.error_full = 0;
0844 103D  0228 	BCF   gRingBuf+18,0
           0229 			;}
0845 0008  0230 	RETURN
           0231 			;
           0232 			;char RingBufGet(void)
           0233 			;{
           0234 RingBufGet
           0235 			;	char result = gRingBuf.data[gRingBuf.read];
0846 302B  0236 	MOVLW 43
0847 0020  0237 	MOVLB 0
0848 073B  0238 	ADDWF gRingBuf+16,W
0849 0084  0239 	MOVWF FSR0L
084A 0185  0240 	CLRF  FSR0H
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 5

ADDR CODE  LINE SOURCE

084B 0800  0241 	MOVF  INDF0,W
084C 00A5  0242 	MOVWF result
           0243 			;	gRingBuf.read = RingBufInc(gRingBuf.read);
084D 0A3B  0244 	INCF  gRingBuf+16,W
084E 390F  0245 	ANDLW 15
084F 00BB  0246 	MOVWF gRingBuf+16
           0247 			;	return result;
0850 0825  0248 	MOVF  result,W
0851 0008  0249 	RETURN
           0250 			;}
           0251 			;
           0252 			;void RingBufPut(char value)
           0253 			;{
           0254 RingBufPut
0852 0020  0255 	MOVLB 0
0853 00A0  0256 	MOVWF value
           0257 			;	char writeNext = RingBufInc(gRingBuf.write);
0854 0A3C  0258 	INCF  gRingBuf+17,W
0855 390F  0259 	ANDLW 15
0856 00A1  0260 	MOVWF writeNext
           0261 			;	if(writeNext != gRingBuf.read)
0857 0821  0262 	MOVF  writeNext,W
0858 063B  0263 	XORWF gRingBuf+16,W
0859 1903  0264 	BTFSC 0x03,Zero_
085A 2864  0265 	GOTO  m002
           0266 			;	{
           0267 			;		gRingBuf.data[gRingBuf.write] = value;
085B 302B  0268 	MOVLW 43
085C 073C  0269 	ADDWF gRingBuf+17,W
085D 0084  0270 	MOVWF FSR0L
085E 0185  0271 	CLRF  FSR0H
085F 0820  0272 	MOVF  value,W
0860 0080  0273 	MOVWF INDF0
           0274 			;		gRingBuf.write = writeNext;
0861 0821  0275 	MOVF  writeNext,W
0862 00BC  0276 	MOVWF gRingBuf+17
           0277 			;	}
           0278 			;	else gRingBuf.error_full = 1;
0863 2866  0279 	GOTO  m003
0864 0020  0280 m002	MOVLB 0
0865 143D  0281 	BSF   gRingBuf+18,0
           0282 			;}
0866 0008  0283 m003	RETURN
           0284 
           0285   ; FILE include_files\usart.c
           0286 			;// Include-Datei f¸r Serielle Kommunikation ¸ber Hardwaremodul des Pic
           0287 			; //
           0288 			; //
           0289 			; // Nils Weiﬂ
           0290 			; // 29.11.2010
           0291 			; // Compiler CC5x
           0292 			;
           0293 			;//*******  Initialisierungs-Funktion  *************************************************
           0294 			;void USARTinit()
           0295 			;{
           0296 USARTinit
           0297 			;	//USART TX Pin als Ausgang
           0298 			;	TRISC.6 = 0;
0867 0021  0299 	MOVLB 1
0868 130E  0300 	BCF   TRISC,6
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 6

ADDR CODE  LINE SOURCE

           0301 			;
           0302 			;    BRGH=1;					// High Baudrate activated
0869 0023  0303 	MOVLB 3
086A 151E  0304 	BSF   0x19E,BRGH
           0305 			;	BRG16=1;
086B 159F  0306 	BSF   0x19F,BRG16
           0307 			;	SPBRGL=68;				// 57600 Bps @ 16 MHz Clock
086C 3044  0308 	MOVLW 68
086D 009B  0309 	MOVWF SPBRGL
           0310 			;	SPBRGH=0;
086E 019C  0311 	CLRF  SPBRGH
           0312 			;    SPEN = 1;               // Set_Serial_Pins;
086F 179D  0313 	BSF   0x19D,SPEN
           0314 			;    SYNC = 0;               // Set_Async_Mode;
0870 121E  0315 	BCF   0x19E,SYNC
           0316 			;    TX9 = 0;                // Set_8bit_Tx;
0871 131E  0317 	BCF   0x19E,TX9
           0318 			;    RX9 = 0;                // Set_8bit_Rx;
0872 131D  0319 	BCF   0x19D,RX9
           0320 			;    CREN = 1;               // Enable_Rx;
0873 161D  0321 	BSF   0x19D,CREN
           0322 			;    TXEN = 1;               // Enable_Tx;
0874 169E  0323 	BSF   0x19E,TXEN
           0324 			;    RCIE=1;                 // Rx Interrupt aus
0875 0021  0325 	MOVLB 1
0876 1691  0326 	BSF   0x91,RCIE
           0327 			;	ADDEN=0;				// Disable Adressdetection
0877 0023  0328 	MOVLB 3
0878 119D  0329 	BCF   0x19D,ADDEN
           0330 			;}
0879 0008  0331 	RETURN
           0332 			;
           0333 			;//*******  Sende-char-Funktion  *************************************************
           0334 			;void USARTsend(unsigned char ch)
           0335 			;{
           0336 USARTsend
087A 0020  0337 	MOVLB 0
087B 00A4  0338 	MOVWF ch
           0339 			;	while(!TXIF);
087C 0020  0340 m004	MOVLB 0
087D 1E11  0341 	BTFSS 0x11,TXIF
087E 287C  0342 	GOTO  m004
           0343 			;	TXREG=ch;
087F 0020  0344 	MOVLB 0
0880 0824  0345 	MOVF  ch,W
0881 0023  0346 	MOVLB 3
0882 009A  0347 	MOVWF TXREG
           0348 			;}
0883 0008  0349 	RETURN
           0350 			;
           0351 			;//*******  Sende-String-Funktion  *************************************************
           0352 			;void USARTsend_str(const char *putstr)
           0353 			;{
           0354 USARTsend_str
           0355 			; char ps;
           0356 			; ps = *putstr;
0884 0020  0357 	MOVLB 0
0885 0822  0358 	MOVF  putstr,W
0886 2000  0359 	CALL  _const1
0887 0020  0360 	MOVLB 0
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 7

ADDR CODE  LINE SOURCE

0888 00A3  0361 	MOVWF ps
           0362 			;
           0363 			;  while(ps > 0)
0889 0020  0364 m005	MOVLB 0
088A 08A3  0365 	MOVF  ps,1
088B 1903  0366 	BTFSC 0x03,Zero_
088C 289A  0367 	GOTO  m006
           0368 			;   {
           0369 			;    putstr++;
088D 0AA2  0370 	INCF  putstr,1
           0371 			;    if (ps == 0) break;
088E 08A3  0372 	MOVF  ps,1
088F 1903  0373 	BTFSC 0x03,Zero_
0890 289A  0374 	GOTO  m006
           0375 			;   	USARTsend(ps);
0891 0020  0376 	MOVLB 0
0892 0823  0377 	MOVF  ps,W
0893 207A  0378 	CALL  USARTsend
           0379 			;    ps = *putstr;
0894 0020  0380 	MOVLB 0
0895 0822  0381 	MOVF  putstr,W
0896 2000  0382 	CALL  _const1
0897 0020  0383 	MOVLB 0
0898 00A3  0384 	MOVWF ps
           0385 			;   }
0899 2889  0386 	GOTO  m005
           0387 			;}
089A 0008  0388 m006	RETURN
           0389 			;
           0390 			;//*******  Sende-Array-Funktion  *************************************************
           0391 			;void USARTsend_arr(char *array, char length)
           0392 			;{
           0393 USARTsend_arr
089B 00FF  0394 	MOVWF length
           0395 			;	if(array == 0) return;
089C 08FF  0396 	MOVF  array,1
089D 1903  0397 	BTFSC 0x03,Zero_
089E 0008  0398 	RETURN
           0399 			;	char i;
           0400 			;	for(i=0;i<length;i++)
089F 01FF  0401 	CLRF  i
08A0 087F  0402 m007	MOVF  length,W
08A1 027F  0403 	SUBWF i,W
08A2 1803  0404 	BTFSC 0x03,Carry
08A3 28AC  0405 	GOTO  m008
           0406 			;	{
           0407 			;		USARTsend(*array);
08A4 0185  0408 	CLRF  FSR0H
08A5 087F  0409 	MOVF  array,W
08A6 0084  0410 	MOVWF FSR0L
08A7 0800  0411 	MOVF  INDF0,W
08A8 207A  0412 	CALL  USARTsend
           0413 			;		array++;
08A9 0AFF  0414 	INCF  array,1
           0415 			;	}
08AA 0AFF  0416 	INCF  i,1
08AB 28A0  0417 	GOTO  m007
           0418 			;}
08AC 0008  0419 m008	RETURN
           0420 
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 8

ADDR CODE  LINE SOURCE

           0421   ; FILE include_files\eeprom_nt.c
           0422 			;//Funktionen f¸r EEPROM-Zugriffe
           0423 			;
           0424 			;//Nils Weiﬂ 
           0425 			;//05.09.2011
           0426 			;//Compiler CC5x
           0427 			;
           0428 			;//*********************** EEPROM BYTE SCHREIBEN  **********************************************
           0429 			;
           0430 			;void EEPROM_WR(int adress, char data)
           0431 			;{
           0432 EEPROM_WR
08AD 0020  0433 	MOVLB 0
08AE 00A7  0434 	MOVWF data
           0435 			;	bit GIE_status; 
           0436 			;	EEADRH = (char)(adress<<8);
08AF 0023  0437 	MOVLB 3
08B0 0192  0438 	CLRF  EEADRH
           0439 			;    EEADRL = (char)adress;        // Adresse in Adressregister ¸bertragen
08B1 0020  0440 	MOVLB 0
08B2 0826  0441 	MOVF  adress,W
08B3 0023  0442 	MOVLB 3
08B4 0091  0443 	MOVWF EEADRL
           0444 			;	EEDATL = data;          // Daten in Datenregister ¸bertragen
08B5 0020  0445 	MOVLB 0
08B6 0827  0446 	MOVF  data,W
08B7 0023  0447 	MOVLB 3
08B8 0093  0448 	MOVWF EEDATL
           0449 			;    CFGS = 0;
08B9 1315  0450 	BCF   0x195,CFGS
           0451 			;	EEPGD = 0;                // Auswahl: Programmspeicher lesen oder EEPROM
08BA 1395  0452 	BCF   0x195,EEPGD
           0453 			;    WREN = 1;                 // Schreiben ins EEPROM erlauben
08BB 1515  0454 	BSF   0x195,WREN
           0455 			;	GIE_status=GIE;			
08BC 0020  0456 	MOVLB 0
08BD 1028  0457 	BCF   0x28,GIE_status
08BE 1B8B  0458 	BTFSC 0x0B,GIE
08BF 1428  0459 	BSF   0x28,GIE_status
           0460 			;    GIE=0;                  // Interrups verbieten
08C0 138B  0461 	BCF   0x0B,GIE
           0462 			;    EECON2 = 0x55;
08C1 3055  0463 	MOVLW 85
08C2 0023  0464 	MOVLB 3
08C3 0096  0465 	MOVWF EECON2
           0466 			;    EECON2 = 0xAA;
08C4 30AA  0467 	MOVLW 170
08C5 0096  0468 	MOVWF EECON2
           0469 			;	WR=1; 					// Starten des Schreibens
08C6 1495  0470 	BSF   0x195,WR
           0471 			;    GIE=GIE_status;                  // Interrups erlauben
08C7 0020  0472 	MOVLB 0
08C8 1C28  0473 	BTFSS 0x28,GIE_status
08C9 138B  0474 	BCF   0x0B,GIE
08CA 1828  0475 	BTFSC 0x28,GIE_status
08CB 178B  0476 	BSF   0x0B,GIE
           0477 			;	WREN=0;
08CC 0023  0478 	MOVLB 3
08CD 1115  0479 	BCF   0x195,WREN
           0480 			;	while(WR);
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 9

ADDR CODE  LINE SOURCE

08CE 0023  0481 m009	MOVLB 3
08CF 1895  0482 	BTFSC 0x195,WR
08D0 28CE  0483 	GOTO  m009
           0484 			;}
08D1 0008  0485 	RETURN
           0486 			;
           0487 			;//*********************** EEPROM BYTE LESEN  **********************************************
           0488 			;
           0489 			;char EEPROM_RD(int adress)
           0490 			;{
           0491 EEPROM_RD
           0492 			;    char data;
           0493 			;    EEADRH = (char)(adress<<8);        // Adresse in Adressregister ¸bertragen
08D2 0023  0494 	MOVLB 3
08D3 0192  0495 	CLRF  EEADRH
           0496 			;    EEADRL = (char)(adress);
08D4 0020  0497 	MOVLB 0
08D5 0826  0498 	MOVF  adress_2,W
08D6 0023  0499 	MOVLB 3
08D7 0091  0500 	MOVWF EEADRL
           0501 			;	CFGS=0;
08D8 1315  0502 	BCF   0x195,CFGS
           0503 			;	EEPGD=0;                // Auswahl: Programmspeicher lesen oder EEPROM
08D9 1395  0504 	BCF   0x195,EEPGD
           0505 			;    RD=1;                   // Starten des Lesesn
08DA 1415  0506 	BSF   0x195,RD
           0507 			;    data = EEDATL;       // Daten aus Datenregister auslesen
08DB 0813  0508 	MOVF  EEDATL,W
08DC 0020  0509 	MOVLB 0
08DD 00A7  0510 	MOVWF data_2
           0511 			;    return data;
08DE 0827  0512 	MOVF  data_2,W
08DF 0008  0513 	RETURN
           0514 			;}
           0515 			;
           0516 			;//*********************** EEPROM BYTEARRAY SCHREIBEN  **************************************
           0517 			;
           0518 			;void EEPROM_WR_BLK(char *array, int adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0519 			;{
           0520 EEPROM_WR_BLK
08E0 00FF  0521 	MOVWF length_2
           0522 			;	if(!array) return;
08E1 08FF  0523 	MOVF  array_2,1
08E2 1903  0524 	BTFSC 0x03,Zero_
08E3 0008  0525 	RETURN
           0526 			;	char i;
           0527 			;	for(i=0;i<length;i++)
08E4 01FF  0528 	CLRF  i_2
08E5 087F  0529 m010	MOVF  length_2,W
08E6 027F  0530 	SUBWF i_2,W
08E7 1803  0531 	BTFSC 0x03,Carry
08E8 28F5  0532 	GOTO  m011
           0533 			;	{
           0534 			;		EEPROM_WR(adress,*array);
08E9 087F  0535 	MOVF  adress_3,W
08EA 0020  0536 	MOVLB 0
08EB 00A6  0537 	MOVWF adress
08EC 0185  0538 	CLRF  FSR0H
08ED 087F  0539 	MOVF  array_2,W
08EE 0084  0540 	MOVWF FSR0L
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 10

ADDR CODE  LINE SOURCE

08EF 0800  0541 	MOVF  INDF0,W
08F0 20AD  0542 	CALL  EEPROM_WR
           0543 			;		adress++;
08F1 0AFF  0544 	INCF  adress_3,1
           0545 			;		array++;
08F2 0AFF  0546 	INCF  array_2,1
           0547 			;	}
08F3 0AFF  0548 	INCF  i_2,1
08F4 28E5  0549 	GOTO  m010
           0550 			;}
08F5 0008  0551 m011	RETURN
           0552 			;
           0553 			;//*********************** EEPROM BYTEARRAY LESEN  **************************************
           0554 			;
           0555 			;void EEPROM_RD_BLK(char *array, int adress, char length)			//Zum Ausf¸hren eines beliebigen Befehls durch den Programmcode
           0556 			;{
           0557 EEPROM_RD_BLK
08F6 00FF  0558 	MOVWF length_3
           0559 			;	if(!array) return;
08F7 08FF  0560 	MOVF  array_3,1
08F8 1903  0561 	BTFSC 0x03,Zero_
08F9 0008  0562 	RETURN
           0563 			;	char i, temp;
           0564 			;	for(i=0;i<length;i++)
08FA 01FF  0565 	CLRF  i_3
08FB 087F  0566 m012	MOVF  length_3,W
08FC 027F  0567 	SUBWF i_3,W
08FD 1803  0568 	BTFSC 0x03,Carry
08FE 290D  0569 	GOTO  m013
           0570 			;	{
           0571 			;		temp = EEPROM_RD(adress);
08FF 087F  0572 	MOVF  adress_4,W
0900 0020  0573 	MOVLB 0
0901 00A6  0574 	MOVWF adress_2
0902 20D2  0575 	CALL  EEPROM_RD
0903 00FF  0576 	MOVWF temp
           0577 			;		array[i] = temp;
0904 087F  0578 	MOVF  i_3,W
0905 077F  0579 	ADDWF array_3,W
0906 0084  0580 	MOVWF FSR0L
0907 0185  0581 	CLRF  FSR0H
0908 087F  0582 	MOVF  temp,W
0909 0080  0583 	MOVWF INDF0
           0584 			;		adress++;
090A 0AFF  0585 	INCF  adress_4,1
           0586 			;	}
090B 0AFF  0587 	INCF  i_3,1
090C 28FB  0588 	GOTO  m012
           0589 
           0590   ; FILE main.c
           0591 			;#include "inline.h"
           0592 			;#include "include_files\Ringbuf.h"
           0593 			;#include "include_files\usart.h"
           0594 			;#include "include_files\eeprom_nt.c"        // 2do* Check EEPROM routines for failure, I use new routines now
090D 0008  0595 m013	RETURN
           0596 
           0597   ; FILE include_files\crc.c
           0598 			; // Include-Datei zum Erstellen von CRC Pr¸fsummen
           0599 			; //
           0600 			; //
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 11

ADDR CODE  LINE SOURCE

           0601 			; // Nils Weiﬂ
           0602 			; // 14.04.2012
           0603 			; // Compiler CC5x
           0604 			;
           0605 			;// 16-bit CCIT CRC
           0606 			;
           0607 			;void addCRC(char byte, char* p_crcH, char* p_crcL)
           0608 			;{
           0609 addCRC
           0610 			;	char index;
           0611 			;	char crcH,crcL;
           0612 			;	crcH = *p_crcH;
090E 0185  0613 	CLRF  FSR0H
090F 0020  0614 	MOVLB 0
0910 0826  0615 	MOVF  p_crcH,W
0911 0084  0616 	MOVWF FSR0L
0912 0800  0617 	MOVF  INDF0,W
0913 00A9  0618 	MOVWF crcH
           0619 			;	crcL = *p_crcL;
0914 0185  0620 	CLRF  FSR0H
0915 0827  0621 	MOVF  p_crcL,W
0916 0084  0622 	MOVWF FSR0L
0917 0800  0623 	MOVF  INDF0,W
0918 00AA  0624 	MOVWF crcL
           0625 			;
           0626 			;	MOVF(byte,0);
0919 0825  0627 	MOVF  byte,W
           0628 			;	
           0629 			;	XORWF(crcH,0);
091A 0629  0630 	XORWF crcH,W
           0631 			;	MOVWF(index);
091B 00A8  0632 	MOVWF index
           0633 			;	ANDLW(0xf0);
091C 39F0  0634 	ANDLW 240
           0635 			;	SWAPF(index,1);
091D 0EA8  0636 	SWAPF index,1
           0637 			;	XORWF(index,1);
091E 06A8  0638 	XORWF index,1
           0639 			;	
           0640 			;	MOVF(index,0);
091F 0828  0641 	MOVF  index,W
           0642 			;	ANDLW(0xf0);
0920 39F0  0643 	ANDLW 240
           0644 			;	XORWF(crcL,0);
0921 062A  0645 	XORWF crcL,W
           0646 			;	MOVWF(crcH);
0922 00A9  0647 	MOVWF crcH
           0648 			;	
           0649 			;	RLF(index,0);
0923 0D28  0650 	RLF   index,W
           0651 			;	RLF(index,0);
0924 0D28  0652 	RLF   index,W
           0653 			;	XORWF(crcH,1);
0925 06A9  0654 	XORWF crcH,1
           0655 			;	ANDLW(0xe0);
0926 39E0  0656 	ANDLW 224
           0657 			;	XORWF(crcH,1);
0927 06A9  0658 	XORWF crcH,1
           0659 			;		
           0660 			;	SWAPF(index,1);
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 12

ADDR CODE  LINE SOURCE

0928 0EA8  0661 	SWAPF index,1
           0662 			;	XORWF(index,0);
0929 0628  0663 	XORWF index,W
           0664 			;	MOVWF(crcL);
092A 00AA  0665 	MOVWF crcL
           0666 			;
           0667 			;	*p_crcH = crcH;
092B 0185  0668 	CLRF  FSR0H
092C 0826  0669 	MOVF  p_crcH,W
092D 0084  0670 	MOVWF FSR0L
092E 0829  0671 	MOVF  crcH,W
092F 0080  0672 	MOVWF INDF0
           0673 			;	*p_crcL = crcL;
0930 0185  0674 	CLRF  FSR0H
0931 0827  0675 	MOVF  p_crcL,W
0932 0084  0676 	MOVWF FSR0L
0933 082A  0677 	MOVF  crcL,W
0934 0080  0678 	MOVWF INDF0
           0679 			;
           0680 			;}
0935 0008  0681 	RETURN
           0682 			;
           0683 			;void CRC(char *data, char length, char* crcH_out, char* crcL_out)
           0684 			;{
           0685 CRC
           0686 			;	if(!crcH_out)return;
0936 08FF  0687 	MOVF  crcH_out,1
0937 1903  0688 	BTFSC 0x03,Zero_
0938 0008  0689 	RETURN
           0690 			;	if(!crcL_out)return;
0939 08FF  0691 	MOVF  crcL_out,1
093A 1903  0692 	BTFSC 0x03,Zero_
093B 0008  0693 	RETURN
           0694 			;	if(!data)return;
093C 08FF  0695 	MOVF  data_3,1
093D 1903  0696 	BTFSC 0x03,Zero_
093E 0008  0697 	RETURN
           0698 			;	char crcH,crcL,i,byte;
           0699 			;	crcH=0xff;
093F 30FF  0700 	MOVLW 255
0940 00FF  0701 	MOVWF crcH_2
           0702 			;	crcL=0xff;
0941 30FF  0703 	MOVLW 255
0942 00FF  0704 	MOVWF crcL_2
           0705 			;
           0706 			;	for(i=0;i<length;i++)
0943 01FF  0707 	CLRF  i_4
0944 087F  0708 m014	MOVF  length_4,W
0945 027F  0709 	SUBWF i_4,W
0946 1803  0710 	BTFSC 0x03,Carry
0947 2958  0711 	GOTO  m015
           0712 			;	{
           0713 			;		byte = data[i];
0948 087F  0714 	MOVF  i_4,W
0949 077F  0715 	ADDWF data_3,W
094A 0084  0716 	MOVWF FSR0L
094B 0185  0717 	CLRF  FSR0H
094C 0800  0718 	MOVF  INDF0,W
094D 00FF  0719 	MOVWF byte_2
           0720 			;		addCRC(byte,&crcH,&crcL);
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 13

ADDR CODE  LINE SOURCE

094E 087F  0721 	MOVF  byte_2,W
094F 0020  0722 	MOVLB 0
0950 00A5  0723 	MOVWF byte
0951 307F  0724 	MOVLW 127
0952 00A6  0725 	MOVWF p_crcH
0953 307F  0726 	MOVLW 127
0954 00A7  0727 	MOVWF p_crcL
0955 210E  0728 	CALL  addCRC
           0729 			;	}
0956 0AFF  0730 	INCF  i_4,1
0957 2944  0731 	GOTO  m014
           0732 			;	
           0733 			;	*crcH_out = crcH;
0958 0185  0734 m015	CLRF  FSR0H
0959 087F  0735 	MOVF  crcH_out,W
095A 0084  0736 	MOVWF FSR0L
095B 087F  0737 	MOVF  crcH_2,W
095C 0080  0738 	MOVWF INDF0
           0739 			;	*crcL_out = crcL;
095D 0185  0740 	CLRF  FSR0H
095E 087F  0741 	MOVF  crcL_out,W
095F 0084  0742 	MOVWF FSR0L
0960 087F  0743 	MOVF  crcL_2,W
0961 0080  0744 	MOVWF INDF0
           0745 			;}
0962 0008  0746 	RETURN
           0747 			;
           0748 			;void newCRC(char* p_crcH, char* p_crcL)
           0749 			;{
           0750 newCRC
           0751 			;    if(!p_crcH) return;
0963 0020  0752 	MOVLB 0
0964 08A5  0753 	MOVF  p_crcH_2,1
0965 1903  0754 	BTFSC 0x03,Zero_
0966 0008  0755 	RETURN
           0756 			;    if(!p_crcL) return;
0967 0020  0757 	MOVLB 0
0968 08A6  0758 	MOVF  p_crcL_2,1
0969 1903  0759 	BTFSC 0x03,Zero_
096A 0008  0760 	RETURN
           0761 			;    *p_crcH = 0xff;
096B 0185  0762 	CLRF  FSR0H
096C 0020  0763 	MOVLB 0
096D 0825  0764 	MOVF  p_crcH_2,W
096E 0084  0765 	MOVWF FSR0L
096F 30FF  0766 	MOVLW 255
0970 0080  0767 	MOVWF INDF0
           0768 			;    *p_crcL = 0xff;
0971 0185  0769 	CLRF  FSR0H
0972 0826  0770 	MOVF  p_crcL_2,W
0973 0084  0771 	MOVWF FSR0L
0974 30FF  0772 	MOVLW 255
0975 0080  0773 	MOVWF INDF0
           0774 			;}
0976 0008  0775 	RETURN
           0776 
           0777   ; FILE include_files\spi.c
           0778 			;//Nils Weiﬂ 
           0779 			;//20.04.2012
           0780 			;//Compiler CC5x
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 14

ADDR CODE  LINE SOURCE

           0781 			;void spi_init()
           0782 			;{
           0783 spi_init
           0784 			;	TRISC.3 = 0;        // Make port RC3 an output(SPI Clock)
0977 0021  0785 	MOVLB 1
0978 118E  0786 	BCF   TRISC,3
           0787 			;    TRISC.4 = 1;        // Make port RC4 an input(SPI Data In)
0979 160E  0788 	BSF   TRISC,4
           0789 			;    TRISC.5 = 0;        // Make port RC5 an output(SPI Data Out)
097A 128E  0790 	BCF   TRISC,5
           0791 			;    /* 
           0792 			;	SMP = 0;
           0793 			;	CKP = 0;
           0794 			;	CKE = 0;
           0795 			;	*/
           0796 			;	SSPEN = 1;
097B 0024  0797 	MOVLB 4
097C 1695  0798 	BSF   0x215,SSPEN
           0799 			;}
097D 0008  0800 	RETURN
           0801 			;
           0802 			;void spi_send(char data)
           0803 			;{
           0804 spi_send
097E 00FF  0805 	MOVWF data_4
           0806 			;	SSPBUF = data;	
097F 087F  0807 	MOVF  data_4,W
0980 0024  0808 	MOVLB 4
0981 0091  0809 	MOVWF SSPBUF
           0810 			;	while(SSPIF == 0);
0982 0020  0811 m016	MOVLB 0
0983 1D91  0812 	BTFSS 0x11,SSPIF
0984 2982  0813 	GOTO  m016
           0814 			;}
0985 0008  0815 	RETURN
           0816 			;
           0817 			;char spi_receive(char data)
           0818 			;{
           0819 spi_receive
0986 00FF  0820 	MOVWF data_5
           0821 			;	SSPBUF = data;	
0987 087F  0822 	MOVF  data_5,W
0988 0024  0823 	MOVLB 4
0989 0091  0824 	MOVWF SSPBUF
           0825 			;	while(SSPIF == 0);
098A 0020  0826 m017	MOVLB 0
098B 1D91  0827 	BTFSS 0x11,SSPIF
098C 298A  0828 	GOTO  m017
           0829 			;	return SSPBUF;
098D 0024  0830 	MOVLB 4
098E 0811  0831 	MOVF  SSPBUF,W
098F 0008  0832 	RETURN
           0833 			;}
           0834 			;/***
           0835 			;**	This function sends the array to the LED controller(WS2801)
           0836 			;**  it starts with the last byte to get a correct output
           0837 			;***/
           0838 			;void spi_send_arr(char *array, char length)
           0839 			;{
           0840 spi_send_arr
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 15

ADDR CODE  LINE SOURCE

0990 00FF  0841 	MOVWF length_5
           0842 			;	if(array == 0) return;
0991 087F  0843 	MOVF  array_4,W
0992 047F  0844 	IORWF array_4+1,W
0993 1903  0845 	BTFSC 0x03,Zero_
0994 0008  0846 	RETURN
           0847 			;	char i;
           0848 			;	for(i = (length - 1); i > 0; i-- )
0995 037F  0849 	DECF  length_5,W
0996 00FF  0850 	MOVWF i_5
0997 08FF  0851 m018	MOVF  i_5,1
0998 1903  0852 	BTFSC 0x03,Zero_
0999 29A5  0853 	GOTO  m019
           0854 			;	{
           0855 			;		spi_send(array[i]);
099A 087F  0856 	MOVF  array_4+1,W
099B 0085  0857 	MOVWF FSR0+1
099C 087F  0858 	MOVF  i_5,W
099D 077F  0859 	ADDWF array_4,W
099E 0084  0860 	MOVWF FSR0
099F 1803  0861 	BTFSC 0x03,Carry
09A0 0A85  0862 	INCF  FSR0+1,1
09A1 0800  0863 	MOVF  INDF0,W
09A2 217E  0864 	CALL  spi_send
           0865 			;	} 
09A3 03FF  0866 	DECF  i_5,1
09A4 2997  0867 	GOTO  m018
           0868 
           0869   ; FILE include_files\spi.h
           0870 			;#ifndef _SPI_H_
           0871 			;#define _SPI_H_
           0872 			;
           0873 			;//Nils Weiﬂ 
           0874 			;//20.04.2012
           0875 			;//Compiler CC5x
           0876 			;
           0877 			;void spi_init();
           0878 			;void spi_send(char data);
           0879 			;char spi_receive(char data);
           0880 			;void spi_send_arr(char *array, char length);
           0881 			;
           0882 			;#include "include_files\spi.c"
09A5 0008  0883 m019	RETURN
           0884 
           0885   ; FILE include_files\ledstrip.c
           0886 			;//Nils Weiﬂ 
           0887 			;//20.04.2012
           0888 			;//Compiler CC5x
           0889 			;
           0890 			;static struct LedBuffer gLedBuf;
           0891 			;
           0892 			;void ledstrip_init(void)
           0893 			;{
           0894 ledstrip_init
           0895 			;	char k;
           0896 			;	for(k = 0;k < BUFFERSIZE; k++)
09A6 0020  0897 	MOVLB 0
09A7 01A3  0898 	CLRF  k
09A8 3060  0899 m020	MOVLW 96
09A9 0020  0900 	MOVLB 0
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 16

ADDR CODE  LINE SOURCE

09AA 0223  0901 	SUBWF k,W
09AB 1803  0902 	BTFSC 0x03,Carry
09AC 29BF  0903 	GOTO  m021
           0904 			;	{
           0905 			;		gLedBuf.led_array[k] = 0;
09AD 3020  0906 	MOVLW 32
09AE 0085  0907 	MOVWF FSR0+1
09AF 3034  0908 	MOVLW 52
09B0 0723  0909 	ADDWF k,W
09B1 0084  0910 	MOVWF FSR0
09B2 1803  0911 	BTFSC 0x03,Carry
09B3 0A85  0912 	INCF  FSR0+1,1
09B4 0180  0913 	CLRF  INDF0
           0914 			;		gLedBuf.led_ctrl_array[k] = 0;
09B5 3020  0915 	MOVLW 32
09B6 0085  0916 	MOVWF FSR0+1
09B7 3094  0917 	MOVLW 148
09B8 0723  0918 	ADDWF k,W
09B9 0084  0919 	MOVWF FSR0
09BA 1803  0920 	BTFSC 0x03,Carry
09BB 0A85  0921 	INCF  FSR0+1,1
09BC 0180  0922 	CLRF  INDF0
           0923 			;	}
09BD 0AA3  0924 	INCF  k,1
09BE 29A8  0925 	GOTO  m020
           0926 			;}
09BF 0008  0927 m021	RETURN
           0928 			;
           0929 			;void ledstrip_set_color(char red, char green, char blue)
           0930 			;{
           0931 ledstrip_set_color
09C0 00FF  0932 	MOVWF blue
           0933 			;	char k,selector;
           0934 			;	selector = 0;
09C1 01FF  0935 	CLRF  selector
           0936 			;	for(k = 0; k < BUFFERSIZE; k++)
09C2 01FF  0937 	CLRF  k_2
09C3 3060  0938 m022	MOVLW 96
09C4 027F  0939 	SUBWF k_2,W
09C5 1803  0940 	BTFSC 0x03,Carry
09C6 29F5  0941 	GOTO  m027
           0942 			;	{	
           0943 			;		switch (selector)
09C7 087F  0944 	MOVF  selector,W
09C8 1903  0945 	BTFSC 0x03,Zero_
09C9 29D1  0946 	GOTO  m023
09CA 3A01  0947 	XORLW 1
09CB 1903  0948 	BTFSC 0x03,Zero_
09CC 29DD  0949 	GOTO  m024
09CD 3A03  0950 	XORLW 3
09CE 1903  0951 	BTFSC 0x03,Zero_
09CF 29E9  0952 	GOTO  m025
09D0 29F3  0953 	GOTO  m026
           0954 			;		{
           0955 			;			case 0: 
           0956 			;				{
           0957 			;					gLedBuf.led_array[k] = red;
09D1 3020  0958 m023	MOVLW 32
09D2 0085  0959 	MOVWF FSR0+1
09D3 3034  0960 	MOVLW 52
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 17

ADDR CODE  LINE SOURCE

09D4 077F  0961 	ADDWF k_2,W
09D5 0084  0962 	MOVWF FSR0
09D6 1803  0963 	BTFSC 0x03,Carry
09D7 0A85  0964 	INCF  FSR0+1,1
09D8 087F  0965 	MOVF  red,W
09D9 0080  0966 	MOVWF INDF0
           0967 			;					selector = 1;
09DA 3001  0968 	MOVLW 1
09DB 00FF  0969 	MOVWF selector
           0970 			;				} break;
09DC 29F3  0971 	GOTO  m026
           0972 			;			case 1:
           0973 			;				{	
           0974 			;					gLedBuf.led_array[k] = green;
09DD 3020  0975 m024	MOVLW 32
09DE 0085  0976 	MOVWF FSR0+1
09DF 3034  0977 	MOVLW 52
09E0 077F  0978 	ADDWF k_2,W
09E1 0084  0979 	MOVWF FSR0
09E2 1803  0980 	BTFSC 0x03,Carry
09E3 0A85  0981 	INCF  FSR0+1,1
09E4 087F  0982 	MOVF  green,W
09E5 0080  0983 	MOVWF INDF0
           0984 			;					selector = 2;
09E6 3002  0985 	MOVLW 2
09E7 00FF  0986 	MOVWF selector
           0987 			;				}break;
09E8 29F3  0988 	GOTO  m026
           0989 			;			case 2:
           0990 			;				{
           0991 			;					gLedBuf.led_array[k] = blue;
09E9 3020  0992 m025	MOVLW 32
09EA 0085  0993 	MOVWF FSR0+1
09EB 3034  0994 	MOVLW 52
09EC 077F  0995 	ADDWF k_2,W
09ED 0084  0996 	MOVWF FSR0
09EE 1803  0997 	BTFSC 0x03,Carry
09EF 0A85  0998 	INCF  FSR0+1,1
09F0 087F  0999 	MOVF  blue,W
09F1 0080  1000 	MOVWF INDF0
           1001 			;					selector = 0;
09F2 01FF  1002 	CLRF  selector
           1003 			;				}break;
           1004 			;		}
           1005 			;	}
09F3 0AFF  1006 m026	INCF  k_2,1
09F4 29C3  1007 	GOTO  m022
           1008 			;	spi_send_arr(&gLedBuf.led_array[0], BUFFERSIZE);
09F5 3034  1009 m027	MOVLW 52
09F6 00FF  1010 	MOVWF array_4
09F7 3020  1011 	MOVLW 32
09F8 00FF  1012 	MOVWF array_4+1
09F9 3060  1013 	MOVLW 96
09FA 2990  1014 	GOTO  spi_send_arr
           1015 
           1016   ; FILE include_files\ledstrip.h
           1017 			;#ifndef _LEDSTRIP_H_
           1018 			;#define _LEDSTRIP_H_
           1019 			;
           1020 			;//Nils Weiﬂ 
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 18

ADDR CODE  LINE SOURCE

           1021 			;//20.04.2012
           1022 			;//Compiler CC5x
           1023 			;
           1024 			;#include "include_files\spi.h"
           1025 			;
           1026 			;#define NUM_OF_LED 32
           1027 			;#define BUFFERSIZE (NUM_OF_LED*3)
           1028 			;
           1029 			;struct LedBuffer{
           1030 			;	char led_array[BUFFERSIZE];
           1031 			;	char led_ctrl_array[BUFFERSIZE];
           1032 			;	};
           1033 			;extern struct LedBuffer gLedBuf;
           1034 			;
           1035 			;void ledstrip_init(void);
           1036 			;void ledstrip_set_color(char red, char green, char blue);
           1037 			;
           1038 			;#include "include_files\ledstrip.c"
           1039 
           1040   ; FILE main.c
           1041 			;#include "include_files\crc.c"
           1042 			;#include "include_files\spi.h"
           1043 			;#include "include_files\ledstrip.h"
           1044 			;
           1045 			;//*********************** GLOBAL VARIABLES *******************************************
           1046 			;struct CommandBuffer{
           1047 			;    char cmd_counter;
           1048 			;    char frame_counter;
           1049 			;    char cmd_buf[FRAMELENGTH];
           1050 			;    char crcH;
           1051 			;    char crcL;
           1052 			;};
           1053 			;static struct CommandBuffer gCmdBuf;
           1054 			;static char gEepromPointer;	
           1055 			;static char gERROR;
           1056 			;
           1057 			;//*********************** INTERRUPTSERVICEROUTINE ************************************
           1058 			;#pragma origin 4					//Adresse des Interrupts	
     0000  1059 	ORG 0x0004
           1060 			;interrupt InterruptRoutine(void)
           1061 			;{
           1062 InterruptRoutine
           1063 			;	if (RCIF)
0004 0020  1064 	MOVLB 0
0005 1E91  1065 	BTFSS 0x11,RCIF
0006 2813  1066 	GOTO  m029
           1067 			;	{
           1068 			;		if(!RingBufHasError) RingBufPut(RCREG);
0007 183D  1069 	BTFSC gRingBuf+18,0
0008 280F  1070 	GOTO  m028
0009 0023  1071 	MOVLB 3
000A 0819  1072 	MOVF  RCREG,W
000B 3188  1073 	MOVLP 8
000C 2052  1074 	CALL  RingBufPut
000D 3180  1075 	MOVLP 0
           1076 			;		else 
000E 2813  1077 	GOTO  m029
           1078 			;		{
           1079 			;			//Register lesen um Schnittstellen Fehler zu vermeiden
           1080 			;			char temp = RCREG;
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 19

ADDR CODE  LINE SOURCE

000F 0023  1081 m028	MOVLB 3
0010 0819  1082 	MOVF  RCREG,W
0011 0020  1083 	MOVLB 0
0012 00A0  1084 	MOVWF temp_2
           1085 			;		}
           1086 			;	}
           1087 			;}
0013 0009  1088 m029	RETFIE
           1089 			;
           1090 			;//*********************** FUNKTIONSPROTOTYPEN ****************************************
           1091 			;void init_all();
           1092 			;void throw_errors();
           1093 			;void read_commands();
           1094 			;void execute_commands();
           1095 			;
           1096 			;//*********************** HAUPTPROGRAMM **********************************************
           1097 			;void main(void)
           1098 			;{
           1099 main
           1100 			;	init_all();
0014 2018  1101 	CALL  init_all
           1102 			;	
           1103 			;    while(1)
           1104 			;    {	
           1105 			;        throw_errors();
0015 2040  1106 m030	CALL  throw_errors
           1107 			;		read_commands();
0016 205C  1108 	CALL  read_commands
           1109 			;    }
0017 2815  1110 	GOTO  m030
           1111 			;}
           1112 			;//*********************** UNTERPROGRAMME **********************************************
           1113 			;
           1114 			;void init_all()
           1115 			;{
           1116 init_all
           1117 			;	//OSZILLATOR initialisieren: 4xPLL deactivated;INTOSC 16MHz
           1118 			;	OSCCON = 0b01111010;		
0018 307A  1119 	MOVLW 122
0019 0021  1120 	MOVLB 1
001A 0099  1121 	MOVWF OSCCON
           1122 			;	RingBufInit();
001B 3188  1123 	MOVLP 8
001C 2041  1124 	CALL  RingBufInit
001D 3180  1125 	MOVLP 0
           1126 			;	//initialise UART interface
           1127 			;	USARTinit();
001E 3188  1128 	MOVLP 8
001F 2067  1129 	CALL  USARTinit
0020 3180  1130 	MOVLP 0
           1131 			;	spi_init();
0021 3188  1132 	MOVLP 8
0022 2177  1133 	CALL  spi_init
0023 3180  1134 	MOVLP 0
           1135 			;	ledstrip_init();
0024 3188  1136 	MOVLP 8
0025 21A6  1137 	CALL  ledstrip_init
0026 3180  1138 	MOVLP 0
           1139 			;	
           1140 			;	//Ausgang f¸r FET initalisieren
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 20

ADDR CODE  LINE SOURCE

           1141 			;	TRISC.0 = 0;
0027 0021  1142 	MOVLB 1
0028 100E  1143 	BCF   TRISC,0
           1144 			;	//Spannungsversorgung f¸r LED's einschalten
           1145 			;	PORTC.0 = 0;
0029 0020  1146 	MOVLB 0
002A 100E  1147 	BCF   PORTC,0
           1148 			;
           1149 			;	//To Factory Restore WLAN Modul
           1150 			;	//TRISA.0=0;
           1151 			;	//PORTA.0 = 1;
           1152 			;    
           1153 			;    // *** load globals variables
           1154 			;    gERROR = 0;
002B 01D3  1155 	CLRF  gERROR
           1156 			;    gCmdBuf.cmd_counter = 0;
002C 01BE  1157 	CLRF  gCmdBuf
           1158 			;    gCmdBuf.frame_counter = 0;
002D 01BF  1159 	CLRF  gCmdBuf+1
           1160 			;	
           1161 			;	char i;
           1162 			;	for(i=0;i<FRAMELENGTH;i++)
002E 01A2  1163 	CLRF  i_6
002F 3010  1164 m031	MOVLW 16
0030 0020  1165 	MOVLB 0
0031 0222  1166 	SUBWF i_6,W
0032 1803  1167 	BTFSC 0x03,Carry
0033 283B  1168 	GOTO  m032
           1169 			;	{
           1170 			;        gCmdBuf.cmd_buf[i] = 0;
0034 3040  1171 	MOVLW 64
0035 0722  1172 	ADDWF i_6,W
0036 0084  1173 	MOVWF FSR0L
0037 0185  1174 	CLRF  FSR0H
0038 0180  1175 	CLRF  INDF0
           1176 			;	}
0039 0AA2  1177 	INCF  i_6,1
003A 282F  1178 	GOTO  m031
           1179 			;    
           1180 			;	// *** allow interrupts
           1181 			;	RCIE=1;
003B 0021  1182 m032	MOVLB 1
003C 1691  1183 	BSF   0x91,RCIE
           1184 			;	PEIE=1;
003D 170B  1185 	BSF   0x0B,PEIE
           1186 			;	GIE=1;
003E 178B  1187 	BSF   0x0B,GIE
           1188 			;	
           1189 			;}
003F 0008  1190 	RETURN
           1191 			;
           1192 			;void throw_errors()
           1193 			;{
           1194 throw_errors
           1195 			;	if(RingBufHasError) 
0040 0020  1196 	MOVLB 0
0041 1C3D  1197 	BTFSS gRingBuf+18,0
0042 2847  1198 	GOTO  m033
           1199 			;	{
           1200 			;		USARTsend_str("ERROR: Receivebuffer full");
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 21

ADDR CODE  LINE SOURCE

0043 01A2  1201 	CLRF  putstr
0044 3188  1202 	MOVLP 8
0045 2084  1203 	CALL  USARTsend_str
0046 3180  1204 	MOVLP 0
           1205 			;	}
           1206 			;	if(gERROR.crc_failure)
0047 0020  1207 m033	MOVLB 0
0048 1C53  1208 	BTFSS gERROR,0
0049 2851  1209 	GOTO  m034
           1210 			;	{
           1211 			;		USARTsend_str("ERROR: CRC-Check failed");
004A 301A  1212 	MOVLW 26
004B 00A2  1213 	MOVWF putstr
004C 3188  1214 	MOVLP 8
004D 2084  1215 	CALL  USARTsend_str
004E 3180  1216 	MOVLP 0
           1217 			;		gERROR.crc_failure = 0;
004F 0020  1218 	MOVLB 0
0050 1053  1219 	BCF   gERROR,0
           1220 			;	}
           1221 			;	if(gERROR.eeprom_failure)
0051 0020  1222 m034	MOVLB 0
0052 1CD3  1223 	BTFSS gERROR,1
0053 285B  1224 	GOTO  m035
           1225 			;	{
           1226 			;		USARTsend_str("ERROR: EEPROM is full");
0054 3032  1227 	MOVLW 50
0055 00A2  1228 	MOVWF putstr
0056 3188  1229 	MOVLP 8
0057 2084  1230 	CALL  USARTsend_str
0058 3180  1231 	MOVLP 0
           1232 			;		gERROR.eeprom_failure = 0;
0059 0020  1233 	MOVLB 0
005A 10D3  1234 	BCF   gERROR,1
           1235 			;	}
           1236 			;}
005B 0008  1237 m035	RETURN
           1238 			;
           1239 			;/** This function reads one byte from the ringbuffer and check
           1240 			;*** for framestart, framelength, or databyte 
           1241 			;*** if a frame is complete, the function save the frame as a new
           1242 			;*** command in the internal EEPROM and calculate the Pointer for the next Command
           1243 			;**/
           1244 			;void read_commands()
           1245 			;{	
           1246 read_commands
           1247 			;	if(RingBufIsNotEmpty)
005C 0020  1248 	MOVLB 0
005D 083C  1249 	MOVF  gRingBuf+17,W
005E 063B  1250 	XORWF gRingBuf+16,W
005F 1903  1251 	BTFSC 0x03,Zero_
0060 28FD  1252 	GOTO  m043
           1253 			;	{
           1254 			;		// *** preload variables and 
           1255 			;		// *** get new_byte from ringbuffer
           1256 			;		char new_byte, temp, j;
           1257 			;		// *** get new byte
           1258 			;		new_byte = RingBufGet();	
0061 3188  1259 	MOVLP 8
0062 2046  1260 	CALL  RingBufGet
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 22

ADDR CODE  LINE SOURCE

0063 3180  1261 	MOVLP 0
0064 0020  1262 	MOVLB 0
0065 00A2  1263 	MOVWF new_byte
           1264 			;		// *** do I wait for databytes?
           1265 			;		if(gCmdBuf.frame_counter == 0)
0066 08BF  1266 	MOVF  gCmdBuf+1,1
0067 1D03  1267 	BTFSS 0x03,Zero_
0068 289A  1268 	GOTO  m037
           1269 			;		{
           1270 			;			// *** I don't wait for databytes
           1271 			;			// *** Do I receive a Start_of_Text sign
           1272 			;			if(new_byte == STX)
0069 0F22  1273 	INCFSZ new_byte,W
006A 2881  1274 	GOTO  m036
           1275 			;			{
           1276 			;				// *** Do some cleaning
           1277 			;				gCmdBuf.cmd_counter = 1;
006B 3001  1278 	MOVLW 1
006C 00BE  1279 	MOVWF gCmdBuf
           1280 			;				// *** Write the startsign at the begin of the buffer
           1281 			;				gCmdBuf.cmd_buf[0] = new_byte;
006D 0822  1282 	MOVF  new_byte,W
006E 00C0  1283 	MOVWF gCmdBuf+2
           1284 			;                // *** Reset crc Variables
           1285 			;                newCRC(&gCmdBuf.crcH, &gCmdBuf.crcL);
006F 3050  1286 	MOVLW 80
0070 00A5  1287 	MOVWF p_crcH_2
0071 3051  1288 	MOVLW 81
0072 00A6  1289 	MOVWF p_crcL_2
0073 3188  1290 	MOVLP 8
0074 2163  1291 	CALL  newCRC
0075 3180  1292 	MOVLP 0
           1293 			;                // *** add new_byte to crc checksum
           1294 			;                addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0076 0020  1295 	MOVLB 0
0077 0822  1296 	MOVF  new_byte,W
0078 00A5  1297 	MOVWF byte
0079 3050  1298 	MOVLW 80
007A 00A6  1299 	MOVWF p_crcH
007B 3051  1300 	MOVLW 81
007C 00A7  1301 	MOVWF p_crcL
007D 3188  1302 	MOVLP 8
007E 210E  1303 	CALL  addCRC
007F 3180  1304 	MOVLP 0
           1305 			;			}
           1306 			;			else
0080 28FD  1307 	GOTO  m043
           1308 			;			{	
           1309 			;				// *** to avoid arrayoverflow
           1310 			;				temp = FRAMELENGTH - 2;
0081 300E  1311 m036	MOVLW 14
0082 0020  1312 	MOVLB 0
0083 00A3  1313 	MOVWF temp_3
           1314 			;				// *** check if I get the framelength byte
           1315 			;				if((new_byte < temp) && (gCmdBuf.cmd_counter == 1))
0084 0823  1316 	MOVF  temp_3,W
0085 0222  1317 	SUBWF new_byte,W
0086 1803  1318 	BTFSC 0x03,Carry
0087 28FD  1319 	GOTO  m043
0088 0B3E  1320 	DECFSZ gCmdBuf,W
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 23

ADDR CODE  LINE SOURCE

0089 28FD  1321 	GOTO  m043
           1322 			;				{
           1323 			;					gCmdBuf.frame_counter = new_byte;
008A 0822  1324 	MOVF  new_byte,W
008B 00BF  1325 	MOVWF gCmdBuf+1
           1326 			;					gCmdBuf.cmd_buf[1] = new_byte;
008C 0822  1327 	MOVF  new_byte,W
008D 00C1  1328 	MOVWF gCmdBuf+3
           1329 			;					gCmdBuf.cmd_counter = 2;
008E 3002  1330 	MOVLW 2
008F 00BE  1331 	MOVWF gCmdBuf
           1332 			;                    // *** add new_byte to crc checksum
           1333 			;                    addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
0090 0822  1334 	MOVF  new_byte,W
0091 00A5  1335 	MOVWF byte
0092 3050  1336 	MOVLW 80
0093 00A6  1337 	MOVWF p_crcH
0094 3051  1338 	MOVLW 81
0095 00A7  1339 	MOVWF p_crcL
0096 3188  1340 	MOVLP 8
0097 210E  1341 	CALL  addCRC
0098 3180  1342 	MOVLP 0
           1343 			;				}
           1344 			;			}
           1345 			;		}
           1346 			;		else
0099 28FD  1347 	GOTO  m043
           1348 			;		{
           1349 			;			// *** I wait for Databytes, so I save all bytes 
           1350 			;			// *** that I get until my framecounter is > 0
           1351 			;			gCmdBuf.cmd_buf[gCmdBuf.cmd_counter] = new_byte;
009A 3040  1352 m037	MOVLW 64
009B 0020  1353 	MOVLB 0
009C 073E  1354 	ADDWF gCmdBuf,W
009D 0084  1355 	MOVWF FSR0L
009E 0185  1356 	CLRF  FSR0H
009F 0822  1357 	MOVF  new_byte,W
00A0 0080  1358 	MOVWF INDF0
           1359 			;			gCmdBuf.cmd_counter++;
00A1 0ABE  1360 	INCF  gCmdBuf,1
           1361 			;			gCmdBuf.frame_counter--;
00A2 03BF  1362 	DECF  gCmdBuf+1,1
           1363 			;            // *** add new_byte to crc checksum
           1364 			;            addCRC(new_byte, &gCmdBuf.crcH, &gCmdBuf.crcL);
00A3 0822  1365 	MOVF  new_byte,W
00A4 00A5  1366 	MOVWF byte
00A5 3050  1367 	MOVLW 80
00A6 00A6  1368 	MOVWF p_crcH
00A7 3051  1369 	MOVLW 81
00A8 00A7  1370 	MOVWF p_crcL
00A9 3188  1371 	MOVLP 8
00AA 210E  1372 	CALL  addCRC
00AB 3180  1373 	MOVLP 0
           1374 			;			// *** now I have to check if my framecounter is null.
           1375 			;			// *** If it's null my string is complete 
           1376 			;			// *** and I can give the string to the crc check function.
           1377 			;			if(gCmdBuf.frame_counter == 0)
00AC 0020  1378 	MOVLB 0
00AD 08BF  1379 	MOVF  gCmdBuf+1,1
00AE 1D03  1380 	BTFSS 0x03,Zero_
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 24

ADDR CODE  LINE SOURCE

00AF 28FD  1381 	GOTO  m043
           1382 			;			{
           1383 			;                // *** verify crc checksum
           1384 			;                if( (gCmdBuf.crcL == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 1]) &&
00B0 303F  1385 	MOVLW 63
00B1 073E  1386 	ADDWF gCmdBuf,W
00B2 0084  1387 	MOVWF FSR0L
00B3 0185  1388 	CLRF  FSR0H
00B4 0851  1389 	MOVF  gCmdBuf+19,W
00B5 0600  1390 	XORWF INDF0,W
00B6 1D03  1391 	BTFSS 0x03,Zero_
00B7 28FA  1392 	GOTO  m042
           1393 			;                    (gCmdBuf.crcH == gCmdBuf.cmd_buf[gCmdBuf.cmd_counter - 2]) )
00B8 303E  1394 	MOVLW 62
00B9 073E  1395 	ADDWF gCmdBuf,W
00BA 0084  1396 	MOVWF FSR0L
00BB 0185  1397 	CLRF  FSR0H
00BC 0850  1398 	MOVF  gCmdBuf+18,W
00BD 0600  1399 	XORWF INDF0,W
00BE 1D03  1400 	BTFSS 0x03,Zero_
00BF 28FA  1401 	GOTO  m042
           1402 			;                {
           1403 			;					// *** check if the new command is a "delete EEPROM" command
           1404 			;					if(gCmdBuf.cmd_buf[2] == DELETE)
00C0 0842  1405 	MOVF  gCmdBuf+4,W
00C1 3AF8  1406 	XORLW 248
00C2 1D03  1407 	BTFSS 0x03,Zero_
00C3 28CB  1408 	GOTO  m038
           1409 			;					{	
           1410 			;						// *** Reset the Pointer in EEPROM
           1411 			;						EEPROM_WR(CmdPointerAddr, 0);
00C4 30FF  1412 	MOVLW 255
00C5 00A6  1413 	MOVWF adress
00C6 3000  1414 	MOVLW 0
00C7 3188  1415 	MOVLP 8
00C8 20AD  1416 	CALL  EEPROM_WR
00C9 3180  1417 	MOVLP 0
           1418 			;						return;
00CA 0008  1419 	RETURN
           1420 			;					}
           1421 			;					
           1422 			;                    // *** copy new command             
           1423 			;                    // !!!*** ATTENTION check value of cmd_counter after if statement. 
           1424 			;                    // *** cmd_counter should point to crcL to copy only the command 
           1425 			;                    // *** whitout crc, STX and framelength
           1426 			;                    gCmdBuf.cmd_counter =- 2;
00CB 30FE  1427 m038	MOVLW 254
00CC 0020  1428 	MOVLB 0
00CD 00BE  1429 	MOVWF gCmdBuf
           1430 			;                    
           1431 			;                    char CmdPointer = EEPROM_RD(CmdPointerAddr);
00CE 30FF  1432 	MOVLW 255
00CF 00A6  1433 	MOVWF adress_2
00D0 3188  1434 	MOVLP 8
00D1 20D2  1435 	CALL  EEPROM_RD
00D2 3180  1436 	MOVLP 0
00D3 0020  1437 	MOVLB 0
00D4 00A5  1438 	MOVWF CmdPointer
           1439 			;                    if(CmdPointer < 241)
00D5 30F1  1440 	MOVLW 241
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 25

ADDR CODE  LINE SOURCE

00D6 0225  1441 	SUBWF CmdPointer,W
00D7 1803  1442 	BTFSC 0x03,Carry
00D8 28E1  1443 	GOTO  m039
           1444 			;                    {
           1445 			;                        // *** calculate the next address for EEPROM write
           1446 			;                        EEPROM_WR(CmdPointerAddr,CmdPointer + 10);
00D9 30FF  1447 	MOVLW 255
00DA 00A6  1448 	MOVWF adress
00DB 300A  1449 	MOVLW 10
00DC 0725  1450 	ADDWF CmdPointer,W
00DD 3188  1451 	MOVLP 8
00DE 20AD  1452 	CALL  EEPROM_WR
00DF 3180  1453 	MOVLP 0
           1454 			;                    }
           1455 			;                    else 
00E0 28E4  1456 	GOTO  m040
           1457 			;                    {
           1458 			;                        // *** EEPROM is full with commands
           1459 			;                        // *** Some errorhandling should be here
           1460 			;						gERROR.eeprom_failure = 1;
00E1 0020  1461 m039	MOVLB 0
00E2 14D3  1462 	BSF   gERROR,1
           1463 			;                        return;
00E3 0008  1464 	RETURN
           1465 			;                    }
           1466 			;                        
           1467 			;                    
           1468 			;                    for(j = 2;j < gCmdBuf.cmd_counter; j++)
00E4 3002  1469 m040	MOVLW 2
00E5 0020  1470 	MOVLB 0
00E6 00A4  1471 	MOVWF j
00E7 0020  1472 m041	MOVLB 0
00E8 083E  1473 	MOVF  gCmdBuf,W
00E9 0224  1474 	SUBWF j,W
00EA 1803  1475 	BTFSC 0x03,Carry
00EB 28FD  1476 	GOTO  m043
           1477 			;                    {	
           1478 			;                        EEPROM_WR(CmdPointer, gCmdBuf.cmd_buf[j]);
00EC 0825  1479 	MOVF  CmdPointer,W
00ED 00A6  1480 	MOVWF adress
00EE 3040  1481 	MOVLW 64
00EF 0724  1482 	ADDWF j,W
00F0 0084  1483 	MOVWF FSR0L
00F1 0185  1484 	CLRF  FSR0H
00F2 0800  1485 	MOVF  INDF0,W
00F3 3188  1486 	MOVLP 8
00F4 20AD  1487 	CALL  EEPROM_WR
00F5 3180  1488 	MOVLP 0
           1489 			;                        CmdPointer ++;
00F6 0020  1490 	MOVLB 0
00F7 0AA5  1491 	INCF  CmdPointer,1
           1492 			;                    }
00F8 0AA4  1493 	INCF  j,1
00F9 28E7  1494 	GOTO  m041
           1495 			;                }
           1496 			;                else
           1497 			;                {
           1498 			;                    // *** Do some error handling in case of an CRC failure here
           1499 			;					gERROR.crc_failure = 1;
00FA 0020  1500 m042	MOVLB 0
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 26

ADDR CODE  LINE SOURCE

00FB 1453  1501 	BSF   gERROR,0
           1502 			;                    return;
00FC 0008  1503 	RETURN
           1504 			;                }
           1505 			;			}
           1506 			;		}
           1507 			;	}
           1508 			;}
00FD 0008  1509 m043	RETURN
           1510 			;
           1511 			;/** This function reads the pointer for commands in the EEPROM from a defined address 
           1512 			;*** in the EEPROM. After this one by one command is executed by this function. 
           1513 			;**/ 
           1514 			;void execute_commands()
           1515 			;{
           1516 execute_commands
           1517 			;	
           1518 			;}
00FE 0008  1519 	RETURN
           1520 
           1521 	END
           1522 
           1523 
           1524 ; *** KEY INFO ***
           1525 
           1526 ; 0x0004 P0   16 word(s)  0 % : InterruptRoutine
           1527 ; 0x0018 P0   40 word(s)  1 % : init_all
           1528 ; 0x0040 P0   28 word(s)  1 % : throw_errors
           1529 ; 0x005C P0  162 word(s)  7 % : read_commands
           1530 ; 0x00FE P0    1 word(s)  0 % : execute_commands
           1531 ; 0x0014 P0    4 word(s)  0 % : main
           1532 
           1533 ; 0x0841 P1    5 word(s)  0 % : RingBufInit
           1534 ; 0x0846 P1   12 word(s)  0 % : RingBufGet
           1535 ; 0x0852 P1   21 word(s)  1 % : RingBufPut
           1536 ; 0x0867 P1   19 word(s)  0 % : USARTinit
           1537 ; 0x087A P1   10 word(s)  0 % : USARTsend
           1538 ; 0x0884 P1   23 word(s)  1 % : USARTsend_str
           1539 ; 0x089B P1   18 word(s)  0 % : USARTsend_arr
           1540 ; 0x0800 P1   65 word(s)  3 % : _const1
           1541 ; 0x08AD P1   37 word(s)  1 % : EEPROM_WR
           1542 ; 0x08D2 P1   14 word(s)  0 % : EEPROM_RD
           1543 ; 0x08E0 P1   22 word(s)  1 % : EEPROM_WR_BLK
           1544 ; 0x08F6 P1   24 word(s)  1 % : EEPROM_RD_BLK
           1545 ; 0x090E P1   40 word(s)  1 % : addCRC
           1546 ; 0x0936 P1   45 word(s)  2 % : CRC
           1547 ; 0x0963 P1   20 word(s)  0 % : newCRC
           1548 ; 0x0977 P1    7 word(s)  0 % : spi_init
           1549 ; 0x097E P1    8 word(s)  0 % : spi_send
           1550 ; 0x0986 P1   10 word(s)  0 % : spi_receive
           1551 ; 0x0990 P1   22 word(s)  1 % : spi_send_arr
           1552 ; 0x09A6 P1   26 word(s)  1 % : ledstrip_init
           1553 ; 0x09C0 P1   59 word(s)  2 % : ledstrip_set_color
           1554 
           1555 ; RAM usage: 244 bytes (11 local), 268 bytes free
           1556 ; Maximum call level: 3 (+2 for interrupt)
           1557 ;  Codepage 0 has  252 word(s) :  12 %
           1558 ;  Codepage 1 has  507 word(s) :  24 %
           1559 ;  Codepage 2 has    0 word(s) :   0 %
           1560 ;  Codepage 3 has    0 word(s) :   0 %
CC5X Version 3.4E,   File: main.c              25. Apr 2012  18:18   Page 27

ADDR CODE  LINE SOURCE

           1561 ; Total of 759 code words (9 %)
